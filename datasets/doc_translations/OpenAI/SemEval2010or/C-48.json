{
    "id": "C-48",
    "original_text": "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes. Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query. An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15. Such queries are useful for correlating events occurring within the network. In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries. Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm. Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)). In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network. Finally, experiments on a small scale testbed validate the feasibility of DIMs. Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1. INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3]. Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc. In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes. For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20. Such range queries can be used in two distinct ways. They can help users efficiently drill-down their search for events of interest. The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms. More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions. For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras. In traditional database systems, such range queries are supported using pre-computed indices. Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability. For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network). Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries. In this paper, we present just such a data structure, that we call a DIM1 . DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network. DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3). DIMs trace their lineage to datacentric storage systems [23]. The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events. Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes. DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion. We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3). We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6). Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)). In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network. Experiments on a small scale testbed validate the feasibility of DIMs (Section 6). Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity. We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks. DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18]. All such systems will likely be integrated to a sensor network database system such as TinyDB [17]. Application designers could then choose the appropriate method of information access. For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots. Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2. RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques. The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature. Indexing techniques essentially trade-off some data insertion cost to enable efficient querying. Indexing has, for long, been a classical research problem in the database community [5, 2]. Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space. Our approach essentially represents a geographic embedding of such structures in a sensor field. There is one important difference. The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]). The index structure is decided not only by the data, but also by the order in which data is inserted. Our current design is not data dependent. Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11]. While there has been some work on distributed indexing, the problem has not been extensively explored. There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries. Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19]. Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network. The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology. More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context. Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17]. Our work is similar in spirit to this body of literature. In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17]. Our work departs from prior work in this area in two significant respects. Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations. This hashing is the key to scaling multi-dimensional range searches. In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system. Our work avoids query flooding by an appropriate choice of hashing. Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT). This index is used to direct queries to nodes that have detected relevant data. Our work differs from SRT in three key aspects. First, SRT is built on single attributes while DIM supports mulitple attributes. Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values. Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node. A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25]. These approaches work well for relatively long-lived queries. Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous. GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location. We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries. DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3. THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment. In these networks, nodes (either individually or collaboratively) will generate events. An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level). The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk . Such a query returns all events whose attribute values fall into the corresponding ranges. Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries. As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network. It is possible to implement range queries by flooding a query within the network. However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently. The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries. Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes. The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme. The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby. The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function. Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later. Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node. Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries. This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location. The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X. In GPSR, this is called greedy-mode forwarding. When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids. GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation. For all of this to work, DIMs make two assumptions that are consistent with the literature [23]. First, all nodes know the approximate geographic boundaries of the network. These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol. Second, each node knows its geographic location. Node locations can be automatically determined by a localization system or by other means. Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles. We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone. Intuitively, a zone is a subdivision of the geographic extent of a sensor field. A zone is defined by the following constructive procedure. Consider a rectangle R on the x-y plane. Intuitively, R is the bounding rectangle that contains all sensors withing the network. We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles. If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis). That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on. We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z). The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows. If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1. If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1. The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings. Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111. Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree. The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z. The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known. Two zones are called sibling zones if their zone codes are the same except for the last bit. For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones. The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree. We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree. For a zone Z, let p be the first level(Z) − 1 digits of code(Z). Let backup(Z) be the backup zone of zone Z. If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences). If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field. Now we describe how zones are mapped to nodes. Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node. If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone. In general, however, the node placements within a sensor field are likely to be less regular than the grid. For some k, some zones may be empty and other zones might have more than one node situated within them. One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest). Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones. To precisely understand the associations between zones and nodes, we define the notion of zone ownership. For any given placement of network nodes, consider a node A. Let ZA to be the largest zone that includes only node A and no other node. Then, we say that A owns ZA. Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node. For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner. To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z). In our example, that empty zones owner would also be the node that owns 1110, its backup zone. Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network? In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone. In practice, however, communication voids and obstacles make the algorithm much more challenging. In particular, resolving the ownership of zones that do not contain any nodes is complicated. Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone. Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted. The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary). These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed. We now describe the algorithm, and illustrate it using examples. In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes). When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network. The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range. Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly. In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A). Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors. Figure 2 illustrates the results of applying this algorithm for the network in Figure 1. Figure 3 describes the corresponding zone tree. Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM. Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1. This binary tree forms the index that we will use in the following event and query processing procedures. We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes. Notice that in Figure 2, there is an empty zone whose code should be 110. In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction. As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent. We describe event insertion in the next step. Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up. We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM. There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone. As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field. We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . . Am. For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node. We will relax this assumption shortly. Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1. Our hashing scheme assigns a k bit zone code to an event as follows. For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1. For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1). We repeat this procedure until all k bits have been assigned. As an example, consider event E = 0.3, 0.8 . For this event, the 5-bit zone code is code(ZA) = 01110. Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code. This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees. In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes. Rather, suppose the encoding node is A and its own zone code is of length kA. Then, given an event E, node A only hashes E to a zone code of length kA. We denote the zone code assigned to an event E by code(E). As we describe below, as the event is routed, code(E) is refined by intermediate nodes. This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone. We call this node the owner of the event. Consider an event E that has just been generated at a node A. After encoding event E, node A compares code(E) with code(A). If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner. To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored. A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1). The message contains the event E, code(E), and the target geographic location for storing the event. In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes. GPSR now delivers this message to the next hop towards addr(Z ) from A. This next hop node (call it B) does not immediately forward the message. Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have. Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings. DIM treats NULL as an extreme value for range comparisons. As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E). B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message. In this manner, as the event wends its way to its owner, its zone code gets refined. Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message. If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next). If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided. When this condition holds, C knows for sure that no other nodes have overlapped zones with it. In this case, we call C an internal node. Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided. If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap. To do this, C now sets itself to be the owner of E and continues forwarding the message. Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary. Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message. If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally. If this does not happen, there are two possibilities. The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code. This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone. Figures 6 through 8 show an example of this data-driven zone shrinking. Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other. Suppose that A inserts an event E = 0.4, 0.8, 0.9 . A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own. B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A. Upon receiving this request, A also shrinks its zone from 0 to 00. A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code). Let us label this node D. D now tries to initiate delivery to the centroid of the new zone. This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone. A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows). A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking. Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone). However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own. X will shrink its zone to resolve the overlap. If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary. In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm. The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 . Figure 6 also works as an example where the outer perimeter is traversed. Event E inserted by A will eventually be stored in node B. Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node. But if Bs nominal radio range intersects the network boundary, it then has two choices. It can assume that there will not be any nodes outside the network boundary and so B is an internal node. This is an aggressive approach. On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet. B will then force the message walking another perimeter before storing it. In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone. The event will end up being stored at a different node than the real owner. In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery. Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event. To do this, a node C, say, needs to know the zone codes of its neighboring nodes. We deploy GPSRs beaconing message to piggyback the zone codes for nodes. So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism. The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries. In Section 3.5, we address robustness of event insertion to packet loss or to node failures. Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure. In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message. Procedure Send-Message is used to send either an event message or a query message. If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries. Routing a point query is identical to routing an event. Thus, the rest of this section details how range queries are routed. The key challenge in routing zone queries is brought out by the following strawman design. If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones. This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined. Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries. We describe this algorithm here. The first step of the algorithm is to map a range query to a zone code prefix. Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do. The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree. The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)). Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q). Our approach to split a query Q into subqueries is as follows. If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1. Then A decides the half that overlaps with its own zone. Lets call it QA. If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it. For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 . The splitting steps is shown in Figure 2. After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 . This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting. A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above. More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split. Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split). Figure 10 describes the pseudo-code for the zone splitting algorithm. As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier. Every query message contains 4 By point queries, we mean the equality condition on all indexed keys. DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator. Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting. We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms. Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure. We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided. These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above. When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries. At this time, those zones can also transfer to the new node those events they store but which should belong to the new node. Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node. Node deletion may also cause zone expansion. In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1). The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone. Now, we turn our attention to node failures. Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node. But how does a node decide if its sibling has failed? If the sibling is within radio range, the absence of GPSR beaconing messages can detect this. Once it detects this, the node can expand its zone. A different approach is needed for detecting siblings who are not within radio range. These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship. In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives. Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B. A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal. A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead. If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data. To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes. Mirror replication is conceptually easy. Suppose an event E has a zone code code(E). Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E). This technique essentially creates a mirror DIM. A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed. Clearly, the trade-off here is an approximate doubling of both insertion and query costs. There exists a far cheaper technique to ensure resilience to random node failures. Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails. This node is defined as the node responsible for As zones backup zone (see Section 3.1). The basic idea is that A replicates each data item it has in this node. We call this node As local replica. Let As local replica be B. Often B will be a radio neighbor of A and can be detected from GPSR beacons. Sometimes, however, this is not the case, and B will have to be explicitly discovered. We use an explicit message for discovering the local replica. Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion. Node A sends a message whose geographic destination is a random nearby location chosen by A. The location is close enough to A such that GPSR will guarantee that the message will delivered back to A. In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A). Then the packet will be delivered in GPSR perimeter mode. Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location. Once the packet comes back to A, it will know the location of its local replica and can start to send replicas. In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic. However, a nodes local replica itself may fail. There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas. The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss. For event insertion, a simple ACK scheme suffices. Of course, queries and responses can be lost as well. In this case, there exists an efficient approach for error recovery. This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment). After a conservative timeout, the querier can re-issue the queries selectively to these zones. If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4. DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks. In the next section, we validate these analyses using detailed packet-level simulations. Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network. Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network. It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against. In DIMs, event insertion essentially uses geographic routing. In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23]. On the other hand, the query delivery cost depends upon the size of ranges specified in the query. Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range. Thus, when the querier is far from the queried zone, there are two components to the query delivery cost. The first, which is proportional to √ N, is the cost to deliver the query near the covering zone. If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes. Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx. To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely. In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query. For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . . N is equally likely, the average query delivery cost of uniformly distributed queries is O(N). Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding. However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic. Somewhat more realistic is a situation where all query sizes are bounded by a constant B. In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B). Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone. Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N). The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ). In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N). Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)). Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions). How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries? A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network. This scheme incurs an insertion cost of O( √ N), and a zero query cost. However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot. A second alternative implementation would store events at the node where they are generated. Queries are flooded 71 throughout the network, and nodes that have matching data respond. Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17]. The flooding scheme incurs a zero insertion cost, but an O(N) query cost. It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]). In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute. A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute. Each sub-query is then hashed to the appropriate location. The nodes that receive a sub-query only return events that match all other attribute ranges. In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N). Suppose that the range of the first attribute contains r discrete values. Then the cost to deliver queries is O(r √ N). Thus, asymptotically, GHT-Rs perform similarly to DIMs. In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5. DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries. In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations. Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2. We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter. This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query. In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3. Of those mechanisms, the only one we did not implement is mirror replication. We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work. Our DIM implementation in ns-2 is 2800 lines of code. Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2. This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals. Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R). For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes. Each node has a radio range of 40m. For the results presented here, each node has on average 20 nodes within its nominal radio range. We have conducted experiments at other node densities; they are in agreement with the results presented here. In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event). We have conducted experiments for three different event value distributions. Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely. Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range. The normal event distribution represents a skewed data set. Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network. As we shall see, this represents a fairly skewed data set. Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries. The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential. Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed. For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time. Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results. The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space. Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero). DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events). The reason for this is interesting. In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20]. By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided. Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs. Figure 13 plots the average query cost for a bounded uniform query size distribution. For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost. For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion. Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4. Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 . Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding). Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range. Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query). The superior scaling of DIMs is evident in these graphs. Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare. This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations. As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low. Figure 12 describes the efficacy of local replication. To obtain this figure, we conducted the following experiment. On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers. Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query. The figure plots the fraction of expected responses actually received, with and without replication. As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect. We note that DIMs (as currently designed) are not perfect. When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck. This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.) This is a standard problem that the database indices have dealt with by tree re-balancing. In our case, simpler solutions might be possible (and we discuss this in Section 7). However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions. Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space). Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way. As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely. For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution. For normally distributed events, the insertion costs be much better than this. Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution. Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range). We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones. We leave an understanding of this to future work. Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms. Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6. IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines. To implement DIMs, we had to develop and test an independent implementation of GPSR. Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented. The software architecture of DIM/GPSR system is shown in Figure 16. The entire system (about 5000 lines of code) is event-driven and multi-threaded. The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions. The GPSR system is implemented as user-level daemon process. Applications are executed as clients. For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination. We tested our implementation on a testbed consisting of 8 PC-104 class machines. Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication. These boxes are laid out in an office building with a total spatial separation of over a hundred feet. We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location. The network topology is approximately a chain. On this testbed, we inserted queries and events from a single designated node. Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all). Our queries span four sizes, returning 1, 4, 9 and 16 events respectively. Figure 17 plots the number of events received for different sized queries. It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier. With that adjustment, the number of responses matches our expectation. Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed. While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs. Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7. CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks. Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR. We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future. There are several interesting future directions that we intend to pursue. One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots. Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution. Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves. A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range. Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8. REFERENCES [1] J. Aspnes and G. Shah. Skip Graphs. In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley. Multidimensional Binary Search Trees Used for Associative Searching. Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri. Towards Sensor Database Systems. In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong. Freenet: A Distributed Anonymous Information Storage and Retrieval System. In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability. Springer, New York, 2001. [5] D. Comer. The Ubiquitous B-tree. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley. Quad Trees: A Data Structure for Retrieval on Composite Keys. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann. DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks? In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani. Similarity Search in High Dimensions via Hashing. In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker. The Sensor Network as a Database. Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker. DIFS: A Distributed Index for Features in Sensor Networks. In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman. R-trees: A Dynamic Index Structure for Spatial Searching. In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica. Complex Queries in DHT-based Peer-to-Peer Networks. In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002. Springer-Verlag. [13] P. Indyk and R. Motwani. Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality. In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala. Locality-preserving Hashing in Multidimensional Spaces. In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin. Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks. In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung. GPSR: Greedy Perimeter Stateless Routing for Wireless Networks. In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong. The Design of an Acquisitional Query Processor for Sensor Networks. In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong. TAG: a Tiny AGregation Service for ad-hoc Sensor Networks. In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker. A Scalable Content-Addressable Network. In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker. GHT: A Geographic Hash Table for Data-Centric Storage. In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet. Spatial Data Structures. In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan. On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks. In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin. Data-Centric Storage in Sensornets. In Proc. ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan. Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications. In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang. A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks. In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75",
    "original_translation": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75",
    "original_sentences": [
        "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
        "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
        "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
        "Such queries are useful for correlating events occurring within the network.",
        "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
        "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
        "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
        "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
        "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
        "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
        "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
        "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
        "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
        "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
        "Such range queries can be used in two distinct ways.",
        "They can help users efficiently drill-down their search for events of interest.",
        "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
        "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
        "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
        "In traditional database systems, such range queries are supported using pre-computed indices.",
        "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
        "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
        "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
        "In this paper, we present just such a data structure, that we call a DIM1 .",
        "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
        "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
        "DIMs trace their lineage to datacentric storage systems [23].",
        "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
        "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
        "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
        "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
        "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
        "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
        "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
        "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
        "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
        "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
        "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
        "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
        "Application designers could then choose the appropriate method of information access.",
        "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
        "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
        "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
        "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
        "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
        "Indexing has, for long, been a classical research problem in the database community [5, 2].",
        "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
        "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
        "There is one important difference.",
        "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
        "The index structure is decided not only by the data, but also by the order in which data is inserted.",
        "Our current design is not data dependent.",
        "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
        "While there has been some work on distributed indexing, the problem has not been extensively explored.",
        "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
        "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
        "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
        "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
        "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
        "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
        "Our work is similar in spirit to this body of literature.",
        "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
        "Our work departs from prior work in this area in two significant respects.",
        "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
        "This hashing is the key to scaling multi-dimensional range searches.",
        "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
        "Our work avoids query flooding by an appropriate choice of hashing.",
        "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
        "This index is used to direct queries to nodes that have detected relevant data.",
        "Our work differs from SRT in three key aspects.",
        "First, SRT is built on single attributes while DIM supports mulitple attributes.",
        "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
        "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
        "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
        "These approaches work well for relatively long-lived queries.",
        "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
        "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
        "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
        "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
        "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
        "In these networks, nodes (either individually or collaboratively) will generate events.",
        "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
        "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
        "Such a query returns all events whose attribute values fall into the corresponding ranges.",
        "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
        "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
        "It is possible to implement range queries by flooding a query within the network.",
        "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
        "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
        "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
        "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
        "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
        "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
        "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
        "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
        "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
        "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
        "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
        "In GPSR, this is called greedy-mode forwarding.",
        "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
        "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
        "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
        "First, all nodes know the approximate geographic boundaries of the network.",
        "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
        "Second, each node knows its geographic location.",
        "Node locations can be automatically determined by a localization system or by other means.",
        "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
        "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
        "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
        "A zone is defined by the following constructive procedure.",
        "Consider a rectangle R on the x-y plane.",
        "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
        "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
        "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
        "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
        "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
        "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
        "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
        "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
        "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
        "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
        "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
        "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
        "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
        "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
        "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
        "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
        "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
        "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
        "Let backup(Z) be the backup zone of zone Z.",
        "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
        "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
        "Now we describe how zones are mapped to nodes.",
        "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
        "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
        "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
        "For some k, some zones may be empty and other zones might have more than one node situated within them.",
        "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
        "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
        "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
        "For any given placement of network nodes, consider a node A.",
        "Let ZA to be the largest zone that includes only node A and no other node.",
        "Then, we say that A owns ZA.",
        "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
        "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
        "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
        "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
        "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
        "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
        "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
        "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
        "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
        "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
        "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
        "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
        "We now describe the algorithm, and illustrate it using examples.",
        "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
        "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
        "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
        "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
        "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
        "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
        "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
        "Figure 3 describes the corresponding zone tree.",
        "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
        "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
        "This binary tree forms the index that we will use in the following event and query processing procedures.",
        "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
        "Notice that in Figure 2, there is an empty zone whose code should be 110.",
        "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
        "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
        "We describe event insertion in the next step.",
        "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
        "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
        "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
        "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
        "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
        "Am.",
        "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
        "We will relax this assumption shortly.",
        "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
        "Our hashing scheme assigns a k bit zone code to an event as follows.",
        "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
        "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
        "We repeat this procedure until all k bits have been assigned.",
        "As an example, consider event E = 0.3, 0.8 .",
        "For this event, the 5-bit zone code is code(ZA) = 01110.",
        "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
        "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
        "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
        "Rather, suppose the encoding node is A and its own zone code is of length kA.",
        "Then, given an event E, node A only hashes E to a zone code of length kA.",
        "We denote the zone code assigned to an event E by code(E).",
        "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
        "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
        "We call this node the owner of the event.",
        "Consider an event E that has just been generated at a node A.",
        "After encoding event E, node A compares code(E) with code(A).",
        "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
        "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
        "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
        "The message contains the event E, code(E), and the target geographic location for storing the event.",
        "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
        "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
        "This next hop node (call it B) does not immediately forward the message.",
        "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
        "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
        "DIM treats NULL as an extreme value for range comparisons.",
        "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
        "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
        "In this manner, as the event wends its way to its owner, its zone code gets refined.",
        "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
        "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
        "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
        "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
        "In this case, we call C an internal node.",
        "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
        "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
        "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
        "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
        "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
        "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
        "If this does not happen, there are two possibilities.",
        "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
        "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
        "Figures 6 through 8 show an example of this data-driven zone shrinking.",
        "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
        "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
        "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
        "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
        "Upon receiving this request, A also shrinks its zone from 0 to 00.",
        "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
        "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
        "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
        "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
        "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
        "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
        "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
        "X will shrink its zone to resolve the overlap.",
        "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
        "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
        "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
        "Figure 6 also works as an example where the outer perimeter is traversed.",
        "Event E inserted by A will eventually be stored in node B.",
        "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
        "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
        "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
        "This is an aggressive approach.",
        "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
        "B will then force the message walking another perimeter before storing it.",
        "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
        "The event will end up being stored at a different node than the real owner.",
        "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
        "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
        "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
        "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
        "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
        "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
        "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
        "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
        "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
        "Procedure Send-Message is used to send either an event message or a query message.",
        "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
        "Routing a point query is identical to routing an event.",
        "Thus, the rest of this section details how range queries are routed.",
        "The key challenge in routing zone queries is brought out by the following strawman design.",
        "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
        "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
        "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
        "We describe this algorithm here.",
        "The first step of the algorithm is to map a range query to a zone code prefix.",
        "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
        "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
        "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
        "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
        "Our approach to split a query Q into subqueries is as follows.",
        "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
        "Then A decides the half that overlaps with its own zone.",
        "Lets call it QA.",
        "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
        "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
        "The splitting steps is shown in Figure 2.",
        "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
        "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
        "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
        "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
        "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
        "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
        "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
        "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
        "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
        "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
        "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
        "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
        "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
        "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
        "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
        "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
        "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
        "Node deletion may also cause zone expansion.",
        "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
        "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
        "Now, we turn our attention to node failures.",
        "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
        "But how does a node decide if its sibling has failed?",
        "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
        "Once it detects this, the node can expand its zone.",
        "A different approach is needed for detecting siblings who are not within radio range.",
        "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
        "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
        "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
        "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
        "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
        "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
        "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
        "Mirror replication is conceptually easy.",
        "Suppose an event E has a zone code code(E).",
        "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
        "This technique essentially creates a mirror DIM.",
        "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
        "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
        "There exists a far cheaper technique to ensure resilience to random node failures.",
        "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
        "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
        "The basic idea is that A replicates each data item it has in this node.",
        "We call this node As local replica.",
        "Let As local replica be B.",
        "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
        "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
        "We use an explicit message for discovering the local replica.",
        "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
        "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
        "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
        "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
        "Then the packet will be delivered in GPSR perimeter mode.",
        "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
        "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
        "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
        "However, a nodes local replica itself may fail.",
        "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
        "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
        "For event insertion, a simple ACK scheme suffices.",
        "Of course, queries and responses can be lost as well.",
        "In this case, there exists an efficient approach for error recovery.",
        "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
        "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
        "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
        "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
        "In the next section, we validate these analyses using detailed packet-level simulations.",
        "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
        "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
        "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
        "In DIMs, event insertion essentially uses geographic routing.",
        "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
        "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
        "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
        "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
        "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
        "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
        "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
        "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
        "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
        "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
        "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
        "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
        "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
        "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
        "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
        "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
        "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
        "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
        "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
        "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
        "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
        "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
        "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
        "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
        "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
        "A second alternative implementation would store events at the node where they are generated.",
        "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
        "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
        "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
        "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
        "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
        "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
        "Each sub-query is then hashed to the appropriate location.",
        "The nodes that receive a sub-query only return events that match all other attribute ranges.",
        "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
        "Suppose that the range of the first attribute contains r discrete values.",
        "Then the cost to deliver queries is O(r √ N).",
        "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
        "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
        "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
        "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
        "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
        "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
        "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
        "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
        "Of those mechanisms, the only one we did not implement is mirror replication.",
        "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
        "Our DIM implementation in ns-2 is 2800 lines of code.",
        "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
        "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
        "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
        "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
        "Each node has a radio range of 40m.",
        "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
        "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
        "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
        "We have conducted experiments for three different event value distributions.",
        "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
        "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
        "The normal event distribution represents a skewed data set.",
        "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
        "As we shall see, this represents a fairly skewed data set.",
        "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
        "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
        "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
        "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
        "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
        "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
        "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
        "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
        "The reason for this is interesting.",
        "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
        "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
        "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
        "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
        "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
        "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
        "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
        "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
        "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
        "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
        "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
        "The superior scaling of DIMs is evident in these graphs.",
        "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
        "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
        "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
        "Figure 12 describes the efficacy of local replication.",
        "To obtain this figure, we conducted the following experiment.",
        "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
        "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
        "The figure plots the fraction of expected responses actually received, with and without replication.",
        "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
        "We note that DIMs (as currently designed) are not perfect.",
        "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
        "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
        "This is a standard problem that the database indices have dealt with by tree re-balancing.",
        "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
        "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
        "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
        "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
        "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
        "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
        "For normally distributed events, the insertion costs be much better than this.",
        "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
        "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
        "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
        "We leave an understanding of this to future work.",
        "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
        "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
        "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
        "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
        "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
        "The software architecture of DIM/GPSR system is shown in Figure 16.",
        "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
        "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
        "The GPSR system is implemented as user-level daemon process.",
        "Applications are executed as clients.",
        "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
        "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
        "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
        "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
        "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
        "The network topology is approximately a chain.",
        "On this testbed, we inserted queries and events from a single designated node.",
        "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
        "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
        "Figure 17 plots the number of events received for different sized queries.",
        "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
        "With that adjustment, the number of responses matches our expectation.",
        "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
        "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
        "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
        "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
        "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
        "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
        "There are several interesting future directions that we intend to pursue.",
        "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
        "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
        "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
        "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
        "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
        "REFERENCES [1] J. Aspnes and G. Shah.",
        "Skip Graphs.",
        "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
        "Multidimensional Binary Search Trees Used for Associative Searching.",
        "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
        "Towards Sensor Database Systems.",
        "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
        "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
        "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
        "Springer, New York, 2001. [5] D. Comer.",
        "The Ubiquitous B-tree.",
        "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
        "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
        "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
        "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
        "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
        "Similarity Search in High Dimensions via Hashing.",
        "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
        "The Sensor Network as a Database.",
        "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
        "DIFS: A Distributed Index for Features in Sensor Networks.",
        "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
        "R-trees: A Dynamic Index Structure for Spatial Searching.",
        "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
        "Complex Queries in DHT-based Peer-to-Peer Networks.",
        "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
        "Springer-Verlag. [13] P. Indyk and R. Motwani.",
        "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
        "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
        "Locality-preserving Hashing in Multidimensional Spaces.",
        "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
        "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
        "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
        "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
        "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
        "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
        "The Design of an Acquisitional Query Processor for Sensor Networks.",
        "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
        "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
        "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
        "A Scalable Content-Addressable Network.",
        "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
        "GHT: A Geographic Hash Table for Data-Centric Storage.",
        "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
        "Spatial Data Structures.",
        "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
        "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
        "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
        "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
        "Data-Centric Storage in Sensornets.",
        "In Proc.",
        "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
        "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
        "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
        "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
        "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
    ],
    "translated_text_sentences": [
        "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos.",
        "Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional.",
        "Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15.",
        "Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red.",
        "En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales.",
        "Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR.",
        "Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)).",
        "En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado.",
        "Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs.",
        "Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1.",
        "En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3].",
        "Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc.",
        "En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos.",
        "Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20.",
        "Tales consultas de rango se pueden utilizar de dos formas distintas.",
        "Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés.",
        "La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos.",
        "Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones.",
        "Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras.",
        "En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados.",
        "Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente.",
        "Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red).",
        "Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales.",
        "En este artículo, presentamos una estructura de datos que llamamos DIM1.",
        "Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores.",
        "Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3).",
        "Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23].",
        "El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos.",
        "Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos.",
        "Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida.",
        "Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3).",
        "Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6).",
        "Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)).",
        "En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado.",
        "Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6).",
        "Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos.",
        "Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores.",
        "Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18].",
        "Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17].",
        "Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información.",
        "Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes.",
        "Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica).",
        "TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación.",
        "La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura.",
        "Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes.",
        "La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2].",
        "Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos.",
        "Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial.",
        "Hay una diferencia importante.",
        "Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]).",
        "La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos.",
        "Nuestro diseño actual no depende de datos.",
        "Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11].",
        "Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente.",
        "Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial.",
        "Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19].",
        "Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente.",
        "Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente.",
        "El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores.",
        "Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17].",
        "Nuestro trabajo es similar en espíritu a este cuerpo de literatura.",
        "De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17].",
        "Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos.",
        "A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones.",
        "Este hash es la clave para escalar búsquedas de rango multidimensionales.",
        "En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema.",
        "Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing.",
        "Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT).",
        "Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes.",
        "Nuestro trabajo difiere de SRT en tres aspectos clave.",
        "Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos.",
        "Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente.",
        "Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo.",
        "Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25].",
        "Estos enfoques funcionan bien para consultas relativamente duraderas.",
        "Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente.",
        "Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada.",
        "También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional.",
        "DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones.",
        "El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno.",
        "En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos.",
        "Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza).",
        "El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk.",
        "Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes.",
        "Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango.",
        "Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red.",
        "Es posible implementar consultas de rango inundando una consulta dentro de la red.",
        "Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia.",
        "La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas.",
        "Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas.",
        "El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente.",
        "La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca.",
        "La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad.",
        "Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante.",
        "Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo.",
        "Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas.",
        "Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada.",
        "El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X.",
        "En GPSR, esto se llama reenvío en modo voraz.",
        "Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos.",
        "GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida.",
        "Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23].",
        "Primero, todos los nodos conocen los límites geográficos aproximados de la red.",
        "Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple.",
        "Segundo, cada nodo conoce su ubicación geográfica.",
        "Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios.",
        "Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos.",
        "Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica.",
        "De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores.",
        "Una zona se define mediante el siguiente procedimiento constructivo.",
        "Considera un rectángulo R en el plano x-y.",
        "De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red.",
        "Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual.",
        "Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x).",
        "Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente.",
        "Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z).",
        "El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera.",
        "Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1.",
        "Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1.",
        "Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits.",
        "Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111.",
        "Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol.",
        "La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z.",
        "Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona.",
        "Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit.",
        "Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas.",
        "El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona.",
        "Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano.",
        "Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z).",
        "Que backup(Z) sea la zona de respaldo de la zona Z.",
        "Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias).",
        "Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor.",
        "Ahora describimos cómo se asignan las zonas a los nodos.",
        "Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo.",
        "Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta.",
        "En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula.",
        "Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas.",
        "Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía).",
        "Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños.",
        "Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona.",
        "Para cualquier ubicación dada de los nodos de la red, considera un nodo A.",
        "Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo.",
        "Entonces, decimos que A posee ZA.",
        "Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo.",
        "Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario.",
        "Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z.",
        "En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo.",
        "Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores?",
        "En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida.",
        "En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante.",
        "En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado.",
        "Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local.",
        "Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento.",
        "La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite).",
        "Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente.",
        "Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos.",
        "En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos).",
        "Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red.",
        "El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio.",
        "Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia.",
        "En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A).",
        "Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos.",
        "La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1.",
        "La Figura 3 describe el árbol de zonas correspondiente.",
        "Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM.",
        "El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1.",
        "Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas.",
        "Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos.",
        "Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110.",
        "En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección.",
        "Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta.",
        "Describimos la inserción de eventos en el siguiente paso.",
        "Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos.",
        "Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM.",
        "Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada.",
        "Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores.",
        "Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1...",
        "Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español?",
        "Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo.",
        "Relajaremos esta suposición pronto.",
        "Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1.",
        "Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera.",
        "Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1.",
        "Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1).",
        "Repetimos este procedimiento hasta que se hayan asignado todos los k bits.",
        "Como ejemplo, considera el evento E = 0.3, 0.8.",
        "Para este evento, el código de zona de 5 bits es código(ZA) = 01110.",
        "Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona.",
        "Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d.",
        "En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos.",
        "Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA.",
        "Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA.",
        "Denotamos el código de zona asignado a un evento E como code(E).",
        "Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios.",
        "Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona.",
        "Llamamos a este nodo el propietario del evento.",
        "Consideremos un evento E que acaba de ser generado en un nodo A.",
        "Después de codificar el evento E, el nodo A compara el código(E) con el código(A).",
        "Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario.",
        "Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado.",
        "Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1).",
        "El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento.",
        "En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios.",
        "GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A.",
        "Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje.",
        "Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen.",
        "Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes.",
        "DIM trata a NULL como un valor extremo para comparaciones de rango.",
        "Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E).",
        "B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje.",
        "De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando.",
        "Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante.",
        "Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación).",
        "Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos.",
        "Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él.",
        "En este caso, llamamos a C un nodo interno.",
        "Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos.",
        "Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición.",
        "Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje.",
        "Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido.",
        "Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje.",
        "Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente.",
        "Si esto no sucede, hay dos posibilidades.",
        "El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento.",
        "Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona.",
        "Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos.",
        "Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí.",
        "Supongamos que A inserta un evento E = 0.4, 0.8, 0.9.",
        "A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio.",
        "B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A.",
        "Al recibir esta solicitud, A también reduce su zona de 0 a 00.",
        "Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo).",
        "Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona.",
        "Esta Figura 6: Los nodos A y B han reclamado la misma zona.",
        "La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>.",
        "Figura 8: El diseño de la zona después de la contracción.",
        "Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona).",
        "Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya.",
        "X reducirá su zona para resolver la superposición.",
        "Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido.",
        "De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo.",
        "La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red.",
        "La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior.",
        "El evento E insertado por A eventualmente será almacenado en el nodo B.",
        "Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno.",
        "Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones.",
        "Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno.",
        "Esta es un enfoque agresivo.",
        "Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado.",
        "B luego forzará el mensaje caminando otro perímetro antes de almacenarlo.",
        "En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona.",
        "El evento terminará siendo almacenado en un nodo diferente al del propietario real.",
        "Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos.",
        "Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento.",
        "Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos.",
        "Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos.",
        "Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos.",
        "Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos.",
        "En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos.",
        "La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona.",
        "En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje.",
        "El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta.",
        "Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango.",
        "Enrutar una consulta de punto es idéntico a enrutar un evento.",
        "Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango.",
        "El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja.",
        "Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas.",
        "Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos.",
        "En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas.",
        "Describimos este algoritmo aquí.",
        "El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona.",
        "Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace.",
        "El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol.",
        "El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)).",
        "Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q).",
        "Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente.",
        "Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1.",
        "Entonces A decide la mitad que se superpone con su propia zona.",
        "Llamémoslo QA.",
        "Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora.",
        "Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9.",
        "Los pasos de división se muestran en la Figura 2.",
        "Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9.",
        "Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división.",
        "A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente.",
        "Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división.",
        "De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior).",
        "La Figura 10 describe el pseudo-código para el algoritmo de división de zonas.",
        "Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante.",
        "Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas.",
        "Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador.",
        "Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción.",
        "Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos.",
        "Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona.",
        "Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas.",
        "Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente.",
        "Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona.",
        "En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo.",
        "Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo.",
        "La eliminación de un nodo también puede causar la expansión de la zona.",
        "Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1).",
        "La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana.",
        "Ahora dirigimos nuestra atención a las fallas de nodos.",
        "Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo.",
        "Pero, ¿cómo decide un nodo si su hermano ha fallado?",
        "Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo.",
        "Una vez que lo detecta, el nodo puede expandir su zona.",
        "Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio.",
        "Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona.",
        "En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos.",
        "Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B.",
        "A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR.",
        "Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar.",
        "Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos.",
        "Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos.",
        "La replicación de espejos es conceptualmente fácil.",
        "Supongamos que un evento E tiene un código de zona code(E).",
        "Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E.",
        "Esta técnica crea esencialmente un DIM espejo.",
        "Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado.",
        "Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta.",
        "Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos.",
        "Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle.",
        "Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1).",
        "La idea básica es que A replica cada elemento de datos que tiene en este nodo.",
        "Llamamos a este nodo como réplica local.",
        "Que la réplica local de A sea B.",
        "A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR.",
        "A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B.",
        "Utilizamos un mensaje explícito para descubrir la réplica local.",
        "Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos.",
        "El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A.",
        "La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A.",
        "Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A).",
        "Entonces el paquete será entregado en modo de perímetro GPSR.",
        "Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente.",
        "Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas.",
        "En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red.",
        "Sin embargo, la réplica local de un nodo en sí misma puede fallar.",
        "Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos.",
        "El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes.",
        "Para la inserción de eventos, un esquema de ACK simple es suficiente.",
        "Por supuesto, las consultas y respuestas también pueden perderse.",
        "En este caso, existe un enfoque eficiente para la recuperación de errores.",
        "Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo).",
        "Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas.",
        "Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4.",
        "En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores.",
        "En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete.",
        "Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red.",
        "El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red.",
        "No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs.",
        "En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico.",
        "En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23].",
        "Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta.",
        "Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta.",
        "Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta.",
        "El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura.",
        "Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta.",
        "Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx.",
        "Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables.",
        "En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta.",
        "Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1...",
        "Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N).",
        "Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación.",
        "Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista.",
        "Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B.",
        "En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B).",
        "Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura.",
        "Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N).",
        "La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k).",
        "En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N).",
        "Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)).",
        "Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica).",
        "¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales?",
        "Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores.",
        "Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero.",
        "Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico.",
        "Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados.",
        "Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden.",
        "Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17].",
        "El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N).",
        "Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]).",
        "En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero).",
        "Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo.",
        "Cada subconsulta se hashea luego a la ubicación apropiada.",
        "Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos.",
        "En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N).",
        "Supongamos que el rango del primer atributo contiene r valores discretos.",
        "Entonces, el costo de entregar consultas es O(r √ N).",
        "Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs.",
        "En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas.",
        "DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales.",
        "En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones.",
        "Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2.",
        "Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro.",
        "Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta.",
        "Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3.",
        "De todos esos mecanismos, el único que no implementamos es la replicación de espejo.",
        "Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros.",
        "Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código.",
        "Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2.",
        "Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro.",
        "Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R).",
        "Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos.",
        "Cada nodo tiene un alcance de radio de 40m.",
        "Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal.",
        "Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí.",
        "En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento).",
        "Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes.",
        "Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad.",
        "Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo.",
        "La distribución normal de eventos representa un conjunto de datos sesgado.",
        "Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats.",
        "Como veremos, esto representa un conjunto de datos bastante sesgado.",
        "Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas.",
        "Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial.",
        "Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme.",
        "Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable.",
        "Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos.",
        "Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio.",
        "La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero).",
        "DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente).",
        "La razón de esto es interesante.",
        "En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20].",
        "Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos.",
        "Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT.",
        "La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada.",
        "Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas.",
        "Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión.",
        "Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4.",
        "Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5.",
        "Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación).",
        "Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos.",
        "La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible).",
        "La superior escalabilidad de las DIMs es evidente en estos gráficos.",
        "Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras.",
        "Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas.",
        "Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas.",
        "La Figura 12 describe la eficacia de la replicación local.",
        "Para obtener esta cifra, llevamos a cabo el siguiente experimento.",
        "En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas.",
        "Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta.",
        "La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación.",
        "Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar.",
        "Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos.",
        "Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella.",
        "Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables).",
        "Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles.",
        "En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7).",
        "Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones.",
        "Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio).",
        "También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera.",
        "Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables.",
        "Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial.",
        "Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto.",
        "Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme.",
        "Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado).",
        "Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas.",
        "Dejamos la comprensión de esto para trabajos futuros.",
        "También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs.",
        "El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6.",
        "Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104.",
        "Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR.",
        "Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas.",
        "La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16.",
        "El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo.",
        "El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR.",
        "El sistema GPSR se implementa como un proceso demonio a nivel de usuario.",
        "Las aplicaciones se ejecutan como clientes.",
        "Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro.",
        "Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104.",
        "Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación.",
        "Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies.",
        "Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación.",
        "La topología de red es aproximadamente en forma de cadena.",
        "En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado.",
        "Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total).",
        "Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente.",
        "La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños.",
        "Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante.",
        "Con ese ajuste, el número de respuestas coincide con nuestra expectativa.",
        "Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas.",
        "Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs.",
        "Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7.",
        "CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores.",
        "Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR.",
        "Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro.",
        "Hay varias direcciones futuras interesantes que tenemos la intención de seguir.",
        "Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión.",
        "A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos.",
        "Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos.",
        "Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional.",
        "Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8.",
        "REFERENCIAS [1] J. Aspnes y G. Shah.",
        "Gráficos de salto.",
        "En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley.",
        "Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas.",
        "Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri.",
        "Hacia sistemas de bases de datos de sensores.",
        "En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong.",
        "Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo.",
        "Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad.",
        "Springer, Nueva York, 2001. [5] D. Comer.",
        "El árbol B ubicuo.",
        "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley.",
        "Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas.",
        "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann.",
        "DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores?",
        "En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani.",
        "Búsqueda de similitud en dimensiones altas a través de hash.",
        "En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker.",
        "La red de sensores como una base de datos.",
        "Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker.",
        "DIFS: Un Índice Distribuido para Características en Redes de Sensores.",
        "En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman.",
        "R-trees: Una estructura de índice dinámica para búsquedas espaciales.",
        "En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica.",
        "Consultas complejas en redes peer-to-peer basadas en DHT.",
        "En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002.",
        "Springer-Verlag. [13] P. Indyk y R. Motwani.",
        "Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad.",
        "En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala.",
        "Hashing preservador de la localidad en espacios multidimensionales.",
        "En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997.",
        "ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin.",
        "Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores.",
        "En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung.",
        "GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas.",
        "En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong.",
        "El diseño de un procesador de consultas adquisitivo para redes de sensores.",
        "En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong.",
        "TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc.",
        "En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker.",
        "Una Red Escalable de Dirección de Contenido.",
        "En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker.",
        "GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos.",
        "En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet.",
        "Estructuras de datos espaciales.",
        "En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385.",
        "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan.",
        "Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores.",
        "En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin.",
        "Almacenamiento centrado en datos en redes de sensores.",
        "En Proc.",
        "Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan.",
        "Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet.",
        "En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang.",
        "Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala.",
        "En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75"
    ],
    "error_count": 5,
    "keys": {
        "sensor network": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a <br>sensor network</br> for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the <br>sensor network</br>.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a <br>sensor network</br> database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the <br>sensor network</br> context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a <br>sensor network</br> database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a <br>sensor network</br>, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the <br>sensor network</br> were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the <br>sensor network</br>?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense <br>sensor network</br>, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the <br>sensor network</br>.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The <br>sensor network</br> as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on <br>sensor network</br> Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "More importantly, they can be used by application software running within a <br>sensor network</br> for correlating events and triggering actions.",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the <br>sensor network</br>.",
                "All such systems will likely be integrated to a <br>sensor network</br> database system such as TinyDB [17].",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the <br>sensor network</br> context.",
                "In fact, DIMs could become an important component of a <br>sensor network</br> database system such as TinyDB [17]."
            ],
            "translated_annotated_samples": [
                "Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una <br>red de sensores</br> para correlacionar eventos y activar acciones.",
                "Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la <br>red de sensores</br>.",
                "Todos esos sistemas probablemente se integrarán a un sistema de base de datos de <br>red de sensores</br> como TinyDB [17].",
                "El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de <br>redes de sensores</br>.",
                "De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de <br>red de sensores</br> como TinyDB [17]."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una <br>red de sensores</br> para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la <br>red de sensores</br>. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de <br>red de sensores</br> como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de <br>redes de sensores</br>. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de <br>red de sensores</br> como TinyDB [17]. ",
            "candidates": [],
            "error": [
                [
                    "red de sensores",
                    "red de sensores",
                    "red de sensores",
                    "redes de sensores",
                    "red de sensores"
                ]
            ]
        },
        "multidimensional range query": {
            "translated_key": "consulta de rango multidimensional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a <br>multidimensional range query</br>.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based <br>multidimensional range query</br> mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a <br>multidimensional range query</br>.",
                "Finally, we implemented GHT-R, our GHT-based <br>multidimensional range query</br> mechanism in ns-2."
            ],
            "translated_annotated_samples": [
                "Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una <br>consulta de rango multidimensional</br>.",
                "Finalmente, implementamos GHT-R, nuestro mecanismo de <br>consulta de rango multidimensional</br> basado en GHT en ns-2."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una <br>consulta de rango multidimensional</br>. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de <br>consulta de rango multidimensional</br> basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "distributed index": {
            "translated_key": "índice distribuido",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a <br>distributed index</br> that scalably supports multi-dimensional range queries.",
                "Our <br>distributed index</br> for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 <br>distributed index</br> for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a <br>distributed index</br>, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A <br>distributed index</br> for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "In this paper, we describe the design of a <br>distributed index</br> that scalably supports multi-dimensional range queries.",
                "Our <br>distributed index</br> for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "DIMs leverage two key ideas: in-network 1 <br>distributed index</br> for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "Madden et al. [17] also describe a <br>distributed index</br>, called Semantic Routing Trees (SRT).",
                "DIFS: A <br>distributed index</br> for Features in Sensor Networks."
            ],
            "translated_annotated_samples": [
                "En este artículo, describimos el diseño de un <br>índice distribuido</br> que admite de manera escalable consultas de rango multidimensionales.",
                "Nuestro <br>índice distribuido</br> para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR.",
                "Las DIMs aprovechan dos ideas clave: un <br>Índice Distribuido</br> en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3).",
                "Madden et al. [17] también describen un <br>índice distribuido</br>, llamado Árboles de Enrutamiento Semántico (SRT).",
                "DIFS: Un <br>Índice Distribuido</br> para Características en Redes de Sensores."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un <br>índice distribuido</br> que admite de manera escalable consultas de rango multidimensionales. Nuestro <br>índice distribuido</br> para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un <br>Índice Distribuido</br> en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un <br>índice distribuido</br>, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un <br>Índice Distribuido</br> para Características en Redes de Sensores. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "centralized index": {
            "translated_key": "índice centralizado",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a <br>centralized index</br> for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "For sensor networks, we assert that a <br>centralized index</br> for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network)."
            ],
            "translated_annotated_samples": [
                "Para las redes de sensores, afirmamos que un <br>índice centralizado</br> para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red)."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un <br>índice centralizado</br> para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "distributed datum structure": {
            "translated_key": "estructura de datos distribuida",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "datacentric storage system": {
            "translated_key": "sistemas de almacenamiento centrados en datos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to <br>datacentric storage system</br>s [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "DIMs trace their lineage to <br>datacentric storage system</br>s [23]."
            ],
            "translated_annotated_samples": [
                "Las DIMs rastrean su linaje hasta los <br>sistemas de almacenamiento centrados en datos</br> [23]."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los <br>sistemas de almacenamiento centrados en datos</br> [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "geographic routing": {
            "translated_key": "enrutamiento geográfico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR <br>geographic routing</br> algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying <br>geographic routing</br> algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying <br>geographic routing</br> scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a <br>geographic routing</br> algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses <br>geographic routing</br>.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR <br>geographic routing</br> algorithm.",
                "DIMs then use an underlying <br>geographic routing</br> algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying <br>geographic routing</br> scheme.",
                "Having established the mapping, and the zone structure, DIMs use a <br>geographic routing</br> algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "In DIMs, event insertion essentially uses <br>geographic routing</br>."
            ],
            "translated_annotated_samples": [
                "Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de <br>enrutamiento geográfico</br> GPSR.",
                "Los DIMs luego utilizan un algoritmo de <br>enrutamiento geográfico</br> subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida.",
                "El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de <br>enrutamiento geográfico</br> subyacente.",
                "Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de <br>enrutamiento geográfico</br> previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas.",
                "En las DIMs, la inserción de eventos utiliza principalmente <br>enrutamiento geográfico</br>."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de <br>enrutamiento geográfico</br> GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de <br>enrutamiento geográfico</br> subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de <br>enrutamiento geográfico</br> subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de <br>enrutamiento geográfico</br> previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente <br>enrutamiento geográfico</br>. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "event insertion": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for <br>event insertion</br> and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the <br>event insertion</br> and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe <br>event insertion</br> in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an <br>event insertion</br> might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our <br>event insertion</br> procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the <br>event insertion</br> mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of <br>event insertion</br> to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and <br>event insertion</br>, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of <br>event insertion</br>.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and <br>event insertion</br> can be easily made resilient to packet loss.",
                "For <br>event insertion</br>, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, <br>event insertion</br> essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average <br>event insertion</br> cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "We discuss the design of a DIM, presenting algorithms for <br>event insertion</br> and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "In detailed simulations, we show that in practice, the <br>event insertion</br> and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "We describe <br>event insertion</br> in the next step.",
                "The first is that there are some cases where an <br>event insertion</br> might cause the entire outer perimeter of the network to be traversed3 .",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our <br>event insertion</br> procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism."
            ],
            "translated_annotated_samples": [
                "Discutimos el diseño de un DIM, presentando algoritmos para la <br>inserción y consulta de eventos</br>, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3).",
                "En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado.",
                "Describimos la <br>inserción de eventos</br> en el siguiente paso.",
                "La primera es que hay algunos casos en los que la <br>inserción de un evento</br> podría hacer que se recorra todo el perímetro exterior de la red.",
                "Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de <br>inserción de eventos</br> está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la <br>inserción y consulta de eventos</br>, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la <br>inserción de eventos</br> en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la <br>inserción de un evento</br> podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de <br>inserción de eventos</br> está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. ",
            "candidates": [],
            "error": [
                [
                    "inserción y consulta de eventos",
                    "inserción de eventos",
                    "inserción de un evento",
                    "inserción de eventos"
                ]
            ]
        },
        "querying cost": {
            "translated_key": "costos de inserción y consulta",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and <br>querying cost</br>s of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "In detailed simulations, we show that in practice, the event insertion and <br>querying cost</br>s of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network."
            ],
            "translated_annotated_samples": [
                "En simulaciones detalladas, demostramos que en la práctica, los <br>costos de inserción y consulta</br> de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los <br>costos de inserción y consulta</br> de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "indexing technique": {
            "translated_key": "técnicas de indexación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using <br>indexing technique</br>s.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using <br>indexing technique</br>s."
            ],
            "translated_annotated_samples": [
                "TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando <br>técnicas de indexación</br>."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando <br>técnicas de indexación</br>. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "query flooding": {
            "translated_key": "inundación de consultas",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids <br>query flooding</br> by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "Our work avoids <br>query flooding</br> by an appropriate choice of hashing."
            ],
            "translated_annotated_samples": [
                "Nuestro trabajo evita la <br>inundación de consultas</br> mediante una elección adecuada de hashing."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la <br>inundación de consultas</br> mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "efficient correlation": {
            "translated_key": "correlación eficiente",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable <br>efficient correlation</br> and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "As we have discussed in Section 1, range queries can enable <br>efficient correlation</br> and triggering within the network."
            ],
            "translated_annotated_samples": [
                "Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una <br>correlación eficiente</br> y activación dentro de la red."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una <br>correlación eficiente</br> y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "locality-preserving geographic hash": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel <br>locality-preserving geographic hash</br> (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a <br>locality-preserving geographic hash</br>, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a <br>locality-preserving geographic hash</br> function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel <br>locality-preserving geographic hash</br> (Section 3).",
                "The system we present in this paper, the DIM, relies upon two foundations: a <br>locality-preserving geographic hash</br>, and an underlying geographic routing scheme.",
                "The basic insight underlying DIM is that data locality can be obtained by a <br>locality-preserving geographic hash</br> function."
            ],
            "translated_annotated_samples": [
                "Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso <br>hash geográfico que preserva la localidad</br> (Sección 3).",
                "El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un <br>hash geográfico que preserva la localidad</br> y un esquema de enrutamiento geográfico subyacente.",
                "La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una <br>función hash geográfica que preserva la localidad</br>."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso <br>hash geográfico que preserva la localidad</br> (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un <br>hash geográfico que preserva la localidad</br> y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una <br>función hash geográfica que preserva la localidad</br>. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    "hash geográfico que preserva la localidad",
                    "hash geográfico que preserva la localidad",
                    "función hash geográfica que preserva la localidad"
                ]
            ]
        },
        "asymptotic behavior": {
            "translated_key": "comportamiento asintótico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the <br>asymptotic behavior</br> of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the <br>asymptotic behavior</br> of various approaches for multi-dimensional range queries."
            ],
            "translated_annotated_samples": [
                "DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el <br>comportamiento asintótico</br> de varios enfoques para consultas de rango multidimensionales."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el <br>comportamiento asintótico</br> de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "normal event distribution": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our <br>normal event distribution</br> generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The <br>normal event distribution</br> represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "Our <br>normal event distribution</br> generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The <br>normal event distribution</br> represents a skewed data set."
            ],
            "translated_annotated_samples": [
                "Nuestra <br>distribución de eventos normales</br> genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo.",
                "La <br>distribución normal de eventos</br> representa un conjunto de datos sesgado."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra <br>distribución de eventos normales</br> genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La <br>distribución normal de eventos</br> representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    "distribución de eventos normales",
                    "distribución normal de eventos"
                ]
            ]
        },
        "dim": {
            "translated_key": "dim",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or <br>dim</br>) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a multi-dimensional range query on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a <br>dim</br>, presenting algorithms for event insertion and querying, for maintaining a <br>dim</br> in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use <br>dim</br> to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while <br>dim</br> supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in <br>dim</br> queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the <br>dim</br>, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying <br>dim</br> is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a <br>dim</br> to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a <br>dim</br>.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a <br>dim</br>.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a <br>dim</br> that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 <br>dim</br> does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional <br>dim</br>, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "<br>dim</br> treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many <br>dim</br> instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "<br>dim</br> index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror <br>dim</br>.",
                "A querier would need, in parallel, to query both the original <br>dim</br> and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If <br>dim</br> cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a <br>dim</br> are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if <br>dim</br> limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our <br>dim</br> implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a <br>dim</br> to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the <br>dim</br> mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our <br>dim</br> implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of <br>dim</br> and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for <br>dim</br> and GHT-R (for flooding, of course, the insertion costs are zero).",
                "<br>dim</br> incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in <br>dim</br>, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a <br>dim</br> can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size <br>dim</br> GHT-R Figure 11: Average insertion cost for <br>dim</br> and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size <br>dim</br> flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size <br>dim</br> flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few <br>dim</br> nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size <br>dim</br> flooding GHT-R Figure 15: Hotspot usage <br>dim</br> Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our <br>dim</br> implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of <br>dim</br>/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The <br>dim</br> subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the <br>dim</br> subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called <br>dim</br> for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and <br>dim</br>, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "Our distributed index for multi-dimensional data (or <br>dim</br>) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "We discuss the design of a <br>dim</br>, presenting algorithms for event insertion and querying, for maintaining a <br>dim</br> in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "For instance, a fire tracking application would use <br>dim</br> to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "First, SRT is built on single attributes while <br>dim</br> supports mulitple attributes.",
                "Finally, in SRT queries are issued from a fixed node while in <br>dim</br> queries can be issued from any node."
            ],
            "translated_annotated_samples": [
                "Nuestro índice distribuido para datos multi<br>dim</br>ensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR.",
                "Discutimos el diseño de un <br>DIM</br>, presentando algoritmos para la inserción y consulta de eventos, para mantener un <br>DIM</br> en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3).",
                "Por ejemplo, una aplicación de seguimiento de incendios utilizaría <br>DIM</br> para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes.",
                "Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos.",
                "Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multi<br>dim</br>ensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una consulta de rango multidimensional en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un <br>DIM</br>, presentando algoritmos para la inserción y consulta de eventos, para mantener un <br>DIM</br> en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría <br>DIM</br> para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "multi-dimensional range query": {
            "translated_key": "consulta de rango multidimensional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Multi-dimensional Range Queries in Sensor Networks∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ ABSTRACT In many sensor networks, data or events are named by attributes.",
                "Many of these attributes have scalar values, so one natural way to query events of interest is to use a multidimensional range query.",
                "An example is: List all events whose temperature lies between 50◦ and 60◦ , and whose light levels lie between 10 and 15.",
                "Such queries are useful for correlating events occurring within the network.",
                "In this paper, we describe the design of a distributed index that scalably supports multi-dimensional range queries.",
                "Our distributed index for multi-dimensional data (or DIM) uses a novel geographic embedding of a classical index data structure, and is built upon the GPSR geographic routing algorithm.",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the insertion and query costs of other alternatives are sometimes an order of magnitude more than the costs of DIMs, even for moderately sized network.",
                "Finally, experiments on a small scale testbed validate the feasibility of DIMs.",
                "Categories and Subject Descriptors C.2.4 [Computer Communication Networks]: Distributed Systems; C.3 [Special-Purpose and Application-Based Systems]: Embedded Systems General Terms Embedded Systems, Sensor Networks, Storage 1.",
                "INTRODUCTION In wireless sensor networks, data or events will be named by attributes [15] or represented as virtual relations in a distributed database [18, 3].",
                "Many of these attributes will have scalar values: e.g., temperature and light levels, soil moisture conditions, etc.",
                "In these systems, we argue, one natural way to query for events of interest will be to use multi-dimensional range queries on these attributes.",
                "For example, scientists analyzing the growth of marine microorganisms might be interested in events that occurred within certain temperature and light conditions: List all events that have temperatures between 50◦ F and 60◦ F, and light levels between 10 and 20.",
                "Such range queries can be used in two distinct ways.",
                "They can help users efficiently drill-down their search for events of interest.",
                "The query described above illustrates this, where the scientist is presumably interested in discovering, and perhaps mapping the combined effect of temperature and light on the growth of marine micro-organisms.",
                "More importantly, they can be used by application software running within a sensor network for correlating events and triggering actions.",
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a <br>multi-dimensional range query</br> on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras.",
                "In traditional database systems, such range queries are supported using pre-computed indices.",
                "Indices trade-off some initial pre-computation cost to achieve a significantly more efficient querying capability.",
                "For sensor networks, we assert that a centralized index for multi-dimensional range queries may not be feasible for energy-efficiency reasons (as well as the fact that the access bandwidth to this central index will be limited, particularly for queries emanating from within the network).",
                "Rather, we believe, there will be situations when it is more appropriate to build an innetwork distributed data structure for efficiently answering multi-dimensional range queries.",
                "In this paper, we present just such a data structure, that we call a DIM1 .",
                "DIMs are inspired by classical database indices, and are essentially embeddings of such indices within the sensor network.",
                "DIMs leverage two key ideas: in-network 1 Distributed Index for Multi-dimensional data. 63 data centric storage, and a novel locality-preserving geographic hash (Section 3).",
                "DIMs trace their lineage to datacentric storage systems [23].",
                "The underlying mechanism in these systems allows nodes to consistently hash an event to some location within the network, which allows efficient retrieval of events.",
                "Building upon this, DIMs use a technique whereby events whose attribute values are close are likely to be stored at the same or nearby nodes.",
                "DIMs then use an underlying geographic routing algorithm (GPSR [16]) to route events and queries to their corresponding nodes in an entirely distributed fashion.",
                "We discuss the design of a DIM, presenting algorithms for event insertion and querying, for maintaining a DIM in the event of node failure, and for making DIMs robust to data or packet loss (Section 3).",
                "We then extensively evaluate DIMs using analysis (Section 4), simulation (Section 5), and actual implementation (Section 6).",
                "Our analysis reveals that, under reasonable assumptions about query distributions, DIMs scale quite well with network size (both insertion and query costs scale as O( √ N)).",
                "In detailed simulations, we show that in practice, the event insertion and querying costs of other alternatives are sometimes an order of magnitude the costs of DIMs, even for moderately sized network.",
                "Experiments on a small scale testbed validate the feasibility of DIMs (Section 6).",
                "Much work remains, including efficient support for skewed data distributions, existential queries, and node heterogeneity.",
                "We believe that DIMs will be an essential, but perhaps not necessarily the only, distributed data structure supporting efficient queries in sensor networks.",
                "DIMs will be part of a suite of such systems that enable feature extraction [7], simple range querying [10], exact-match queries [23], or continuous queries [15, 18].",
                "All such systems will likely be integrated to a sensor network database system such as TinyDB [17].",
                "Application designers could then choose the appropriate method of information access.",
                "For instance, a fire tracking application would use DIM to detect the hotspots, and would then use mechanisms that enable continuous queries [15, 18] to track the spatio-temporal progress of the hotspots.",
                "Finally, we note that DIMs are applicable not just to sensor networks, but to other deeply distributed systems (embedded networks for home and factory automation) as well. 2.",
                "RELATED WORK The basic problem that this paper addresses - multidimensional range queries - is typically solved in database systems using indexing techniques.",
                "The database community has focused mostly on centralized indices, but distributed indexing has received some attention in the literature.",
                "Indexing techniques essentially trade-off some data insertion cost to enable efficient querying.",
                "Indexing has, for long, been a classical research problem in the database community [5, 2].",
                "Our work draws its inspiration from the class of multi-key constant branching index structures, exemplified by k-d trees [2], where k represents the dimensionality of the data space.",
                "Our approach essentially represents a geographic embedding of such structures in a sensor field.",
                "There is one important difference.",
                "The classical indexing structures are data-dependent (as are some indexing schemes that use locality preserving hashes, and developed in the theory literature [14, 8, 13]).",
                "The index structure is decided not only by the data, but also by the order in which data is inserted.",
                "Our current design is not data dependent.",
                "Finally, tangentially related to our work is the class of spatial indexing systems [21, 6, 11].",
                "While there has been some work on distributed indexing, the problem has not been extensively explored.",
                "There exist distributed indices of a restricted kind-those that allow exact match or partial prefix match queries.",
                "Examples of such systems, of course, are the Internet Domain Name System, and the class of distributed hash table (DHT) systems exemplified by Freenet[4], Chord[24], and CAN[19].",
                "Our work is superficially similar to CAN in that both construct a zone-based overlay atop of the underlying physical network.",
                "The underlying details make the two systems very different: CANs overlay is purely logical while our overlay is consistent with the underlying physical topology.",
                "More recent work in the Internet context has addressed support for range queries in DHT systems [1, 12], but it is unclear if these directly translate to the sensor network context.",
                "Several research efforts have expressed the vision of a database interface to sensor networks [9, 3, 18], and there are examples of systems that contribute to this vision [18, 3, 17].",
                "Our work is similar in spirit to this body of literature.",
                "In fact, DIMs could become an important component of a sensor network database system such as TinyDB [17].",
                "Our work departs from prior work in this area in two significant respects.",
                "Unlike these approaches, in our work the data generated at a node are hashed (in general) to different locations.",
                "This hashing is the key to scaling multi-dimensional range searches.",
                "In all the other systems described above, queries are flooded throughout the network, and can dominate the total cost of the system.",
                "Our work avoids query flooding by an appropriate choice of hashing.",
                "Madden et al. [17] also describe a distributed index, called Semantic Routing Trees (SRT).",
                "This index is used to direct queries to nodes that have detected relevant data.",
                "Our work differs from SRT in three key aspects.",
                "First, SRT is built on single attributes while DIM supports mulitple attributes.",
                "Second, SRT constructs a routing tree based on historical sensor readings, and therefore works well only for slowlychanging sensor values.",
                "Finally, in SRT queries are issued from a fixed node while in DIM queries can be issued from any node.",
                "A similar differentiation applies with respect to work on data-centric routing in sensor networks [15, 25], where data generated at a node is assumed to be stored at the node, and queries are either flooded throughout the network [15], or each source sets up a network-wide overlay announcing its presence so that mobile sinks can rendezvous with sources at the nearest node on the overlay [25].",
                "These approaches work well for relatively long-lived queries.",
                "Finally, our work is most close related to data-centric storage [23] systems, which include geographic hash-tables (GHTs) [20], DIMENSIONS [7], and DIFS [10].In a GHT, data is hashed by name to a location within the network, enabling highly efficient rendezvous.",
                "GHTs are built upon the GPSR [16] protocol and leverage some interesting properties of that protocol, such as the ability to route to a node nearest to a given location.",
                "We also leverage properties in GPSR (as we describe later), but we use a locality-preserving hash to store data, enabling efficient multi-dimensional range queries.",
                "DIMENSIONS and DIFS can be thought of as using the same set of primitives as GHT (storage using consistent hashing), but for different ends: DIMENSIONS allows drill64 down search for features within a sensor network, while DIFS allows range queries on a single key in addition to other operations. 3.",
                "THE DESIGN OF DIMS Most sensor networks are deployed to collect data from the environment.",
                "In these networks, nodes (either individually or collaboratively) will generate events.",
                "An event can generally be described as a tuple of attribute values, A1, A2, · · · , Ak , where each attribute Ai represents a sensor reading, or some value corresponding to a detection (e.g., a confidence level).",
                "The focus of this paper is the design of systems to efficiently answer multi-dimensional range queries of the form: x1 − y1, x2 − y2, · · · , xk − yk .",
                "Such a query returns all events whose attribute values fall into the corresponding ranges.",
                "Notice that point queries, i.e., queries that ask for events with specified values for each attribute, are a special case of range queries.",
                "As we have discussed in Section 1, range queries can enable efficient correlation and triggering within the network.",
                "It is possible to implement range queries by flooding a query within the network.",
                "However, as we show in later sections, this alternative can be inefficient, particularly as the system scales, and if nodes within the network issue such queries relatively frequently.",
                "The other alternative, sending all events to an external storage node results in the access link being a bottleneck, especially if nodes within the network issue queries.",
                "Shenker et al. [23] also make similar arguments with respect to data-centric storage schemes in general; DIMs are an instance of such schemes.",
                "The system we present in this paper, the DIM, relies upon two foundations: a locality-preserving geographic hash, and an underlying geographic routing scheme.",
                "The key to resolving range queries efficiently is data locality: i.e., events with comparable attribute values are stored nearby.",
                "The basic insight underlying DIM is that data locality can be obtained by a locality-preserving geographic hash function.",
                "Our geographic hash function finds a localitypreserving mapping from the multi-dimensional space (described by the set of attributes) to a 2-d geographic space; this mapping is inspired by k-d trees [2] and is described later.",
                "Moreover, each node in the network self-organizes to claim part of the attribute space for itself (we say that each node owns a zone), so events falling into that space are routed to and stored at that node.",
                "Having established the mapping, and the zone structure, DIMs use a geographic routing algorithm previously developed in the literature to route events to their corresponding nodes, or to resolve queries.",
                "This algorithm, GPSR [16], essentially enables the delivery of a packet to a node at a specified location.",
                "The routing mechanism is simple: when a node receives a packet destined to a node at location X, it forwards the packet to the neighbor closest to X.",
                "In GPSR, this is called greedy-mode forwarding.",
                "When no such neighbor exists (as when there exists a void in the network), the node starts the packet on a perimeter mode traversal, using the well known right-hand rule to circumnavigate voids.",
                "GPSR includes efficient techniques for perimeter traversal that are based on graph planarization algorithms amenable to distributed implementation.",
                "For all of this to work, DIMs make two assumptions that are consistent with the literature [23].",
                "First, all nodes know the approximate geographic boundaries of the network.",
                "These boundaries may either be configured in nodes at the time of deployment, or may be discovered using a simple protocol.",
                "Second, each node knows its geographic location.",
                "Node locations can be automatically determined by a localization system or by other means.",
                "Although the basic idea of DIMs may seem straightforward, it is challenging to design a completely distributed data structure that must be robust to packet losses and node failures, yet must support efficient query distribution and deal with communication voids and obstacles.",
                "We now describe the complete design of DIMs. 3.1 Zones The key idea behind DIMs, as we have discussed, is a geographic locality-preserving hash that maps a multi-attribute event to a geographic zone.",
                "Intuitively, a zone is a subdivision of the geographic extent of a sensor field.",
                "A zone is defined by the following constructive procedure.",
                "Consider a rectangle R on the x-y plane.",
                "Intuitively, R is the bounding rectangle that contains all sensors withing the network.",
                "We call a sub-rectangle Z of R a zone, if Z is obtained by dividing R k times, k ≥ 0, using a procedure that satisfies the following property: After the i-th division, 0 ≤ i ≤ k, R is partitioned into 2i equal sized rectangles.",
                "If i is an odd (even) number, the i-th division is parallel to the y-axis (x-axis).",
                "That is, the bounding rectangle R is first sub-divided into two zones at level 0 by a vertical line that splits R into two equal pieces, each of these sub-zones can be split into two zones at level 1 by a horizontal line, and so on.",
                "We call the non-negative integer k the level of zone Z, i.e. level(Z) = k. A zone can be identified either by a zone code code(Z) or by an address addr(Z).",
                "The code code(Z) is a 0-1 bit string of length level(Z), and is defined as follows.",
                "If Z lies in the left half of R, the first (from the left) bit of code(Z) is 0, else 1.",
                "If Z lies in the bottom half of R, the second bit of code(Z) is 0, else 1.",
                "The remaining bits of code(Z) are then recursively defined on each of the four quadrants of R. This definition of the zone code matches the definition of zones given above, encoding divisions of the sensor field geography by bit strings.",
                "Thus, in Figure 2, the zone in the top-right corner of the rectangle R has a zone code of 1111.",
                "Note that the zone codes collectively define a zone tree such that individual zones are at the leaves of this tree.",
                "The address of a zone Z, addr(Z), is defined to be the centroid of the rectangle defined by Z.",
                "The two representations of a zone (its code and its address) can each be computed from the other, assuming the level of the zone is known.",
                "Two zones are called sibling zones if their zone codes are the same except for the last bit.",
                "For example, if code(Z1) = 01101 and code(Z2) = 01100, then Z1 and Z2 are sibling zones.",
                "The sibling subtree of a zone is the subtree rooted at the left or right sibling of the zone in the zone tree.",
                "We uniquely define a backup zone for each zone as follows: if the sibling subtree of the zone is on the left, the backup zone is the right-most zone in the sibling subtree; otherwise, the backup zone is the left-most zone in the sibling subtree.",
                "For a zone Z, let p be the first level(Z) − 1 digits of code(Z).",
                "Let backup(Z) be the backup zone of zone Z.",
                "If code(Z) = p1, code(backup(Z)) = p01∗ with the most number of trailing 1s (∗ means 0 or 1 occurrences).",
                "If 65 code(Z) = p0, code(backup(Z)) = p10∗ with the most number of trailing 0s. 3.2 Associating Zones with Nodes Our definition of a zone is independent of the actual distribution of nodes in the sensor field, and only depends upon the geographic extent (the bounding rectangle) of the sensor field.",
                "Now we describe how zones are mapped to nodes.",
                "Conceptually, the sensor field is logically divided into zones and each zone is assigned to a single node.",
                "If the sensor network were deployed in a grid-like (i.e., very regular) fashion, then it is easy to see that there exists a k such that each node maps into a distinct level-k zone.",
                "In general, however, the node placements within a sensor field are likely to be less regular than the grid.",
                "For some k, some zones may be empty and other zones might have more than one node situated within them.",
                "One alternative would have been to choose a fixed k for the overall system, and then associate nodes with the zones they are in (and if a zone is empty, associate the nearest node with it, for some definition of nearest).",
                "Because it makes our overall query routing system simpler, we allow nodes in a DIM to map to different-sized zones.",
                "To precisely understand the associations between zones and nodes, we define the notion of zone ownership.",
                "For any given placement of network nodes, consider a node A.",
                "Let ZA to be the largest zone that includes only node A and no other node.",
                "Then, we say that A owns ZA.",
                "Notice that this definition of ownership may leave some sections of the sensor field un-associated with a node.",
                "For example, in Figure 2, the zone 110 does not contain any nodes and would not have an owner.",
                "To remedy this, for any empty zone Z, we define the owner to be the owner of backup(Z).",
                "In our example, that empty zones owner would also be the node that owns 1110, its backup zone.",
                "Having defined the association between nodes and zones, the next problem we tackle is: given a node placement, does there exist a distributed algorithm that enables each node to determine which zones it owns, knowing only the overall boundary of the sensor network?",
                "In principle, this should be relatively straightforward, since each node can simply determine the location of its neighbors, and apply simple geometric methods to determine the largest zone around it such that no other node resides in that zone.",
                "In practice, however, communication voids and obstacles make the algorithm much more challenging.",
                "In particular, resolving the ownership of zones that do not contain any nodes is complicated.",
                "Equally complicated is the case where the zone of a node is larger than its communication radius and the node cannot determine the boundaries of its zone by local communication alone.",
                "Our distributed zone building algorithm defers the resolution of such zones until when either a query is initiated, or when an event is inserted.",
                "The basic idea behind our algorithm is that each node tentatively builds up an idea of the zone it resides in just by communicating with its neighbors (remembering which boundaries of the zone are undecided because there is no radio neighbor that can help resolve that boundary).",
                "These undecided boundaries are later resolved by a GPSR perimeter traversal when data messages are actually routed.",
                "We now describe the algorithm, and illustrate it using examples.",
                "In our algorithm, each node uses an array bound[0..3] to maintain the four boundaries of the zone it owns (rememFigure 1: A network, where circles represent sensor nodes and dashed lines mark the network boundary. 1111 011 00 110 100 101 1110 010 Figure 2: The zone code and boundaries. 0 1 0 1 10 10 1 1 10 00 Figure 3: The Corresponding Zone Tree ber that in this algorithm, the node only tries to determine the zone it resides in, not the other zones it might own because those zones are devoid of nodes).",
                "When a node starts up, each node initializes this array to be the network boundary, i.e., initially each node assumes its zone contains the whole network.",
                "The zone boundary algorithm now relies upon GPSRs beacon messages to learn the locations of neighbors within radio range.",
                "Upon hearing of such a neighbor, the node calls the algorithm in Figure 4 to update its zone boundaries and its code accordingly.",
                "In this algorithm, we assume that A is the node at which the algorithm is executed, ZA is its zone, and a is a newly discovered neighbor of A. (Procedure Contain(ZA, a) is used to decide if node a is located within the current zone boundaries of node A).",
                "Using this algorithm, then, each node can independently and asynchronously decide its own tentative zone based on the location of its neighbors.",
                "Figure 2 illustrates the results of applying this algorithm for the network in Figure 1.",
                "Figure 3 describes the corresponding zone tree.",
                "Each zone resides at a leaf node and the code of a zone is the path from the root to the zone if we represent the branch to the left 66 Build-Zone(a) 1 while Contain(ZA, a) 2 do if length(code(ZA)) mod 2 = 0 3 then new bound ← (bound[0] + bound[1])/2 4 if A.x < new bound 5 then bound[1] ← new bound 6 else bound[0] ← new bound 7 else new bound ← (bound[2] + bound[3])/2 8 if A.y < new bound 9 then bound[3] ← new bound 10 else bound[2] ← new bound 11 Update zone code code(ZA) Figure 4: Zone Boundary Determination, where A.x and A.y represent the geographic coordinate of node A. Insert-Event(e) 1 c ← Encode(e) 2 if Contain(ZA, c) = true and is Internal() = true 3 then Store e and exit 4 Send-Message(c, e) Send-Message(c, m) 1 if ∃ neighbor Y, Closer(Y, owner(m), m) = true 2 then addr(m) ← addr(Y ) 3 else if length(c) > length(code(m)) 4 then Update code(m) and addr(m) 5 source(m) ← caller 6 if is Owner(msg) = true 7 then owner(m) ← callers code 8 Send(m) Figure 5: Inserting an event in a DIM.",
                "Procedure Closer(A, B, m) returns true if code(A) is closer to code(m) than code(B). source(m) is used to set the source address of message m. child by 0 and the branch to the right child by 1.",
                "This binary tree forms the index that we will use in the following event and query processing procedures.",
                "We see that the zone sizes are different and depend on the local densities and so are the lengths of zone codes for different nodes.",
                "Notice that in Figure 2, there is an empty zone whose code should be 110.",
                "In this case, if the node in zone 1111 can only hear the node in zone 1110, it sets its boundary with the empty zone to undecided, because it did not hear from any neighboring nodes from that direction.",
                "As we have mentioned before, the undecided boundaries are resolved using GPSRs perimeter mode when an event is inserted, or a query sent.",
                "We describe event insertion in the next step.",
                "Finally, this description does not describe how a nodes zone codes are adjusted when neighboring nodes fail, or new nodes come up.",
                "We return to this in Section 3.5. 3.3 Inserting an Event In this section, we describe how events are inserted into a DIM.",
                "There are two algorithms of interest: a consistent hashing technique for mapping an event to a zone, and a routing algorithm for storing the event at the appropriate zone.",
                "As we shall see, these two algorithms are inter-related. 3.3.1 Hashing an Event to a Zone In Section 3.1, we described a recursive tessellation of the geographic extent of a sensor field.",
                "We now describe a consistent hashing scheme for a DIM that supports range queries on m distinct attributes2 Let us denote these attributes A1 . . .",
                "Am.",
                "For simplicity, assume for now that the depth of every zone in the network is k, k is a multiple of m, and that this value of k is known to every node.",
                "We will relax this assumption shortly.",
                "Furthermore, for ease of discussion, we assume that all attribute values have been normalized to be between 0 and 1.",
                "Our hashing scheme assigns a k bit zone code to an event as follows.",
                "For i between 1 and m, if Ai < 0.5, the i-th bit of the zone code is assigned 0, else 1.",
                "For i between m + 1 and 2m, if Ai−m < 0.25 or Ai−m ∈ [0.5, 0.75), the i-th bit of the zone is assigned 0, else 1, because the next level divisions are at 0.25 and 0.75 which divide the ranges to [0, 0.25), [0.25, 0.5), [0.5, 0.75), and [0.75, 1).",
                "We repeat this procedure until all k bits have been assigned.",
                "As an example, consider event E = 0.3, 0.8 .",
                "For this event, the 5-bit zone code is code(ZA) = 01110.",
                "Essentially, our hashing scheme uses the values of the attributes in round-robin fashion on the zone tree (such as the one in Figure 3), in order to map an m-attribute event to a zone code.",
                "This is reminiscent of k-d trees [2], but is quite different from that data structure: zone trees are spatial embeddings and do not incorporate the re-balancing algorithms in k-d trees.",
                "In our design of DIMs, we do not require nodes to have zone codes of the same length, nor do we expect a node to know the zone codes of other nodes.",
                "Rather, suppose the encoding node is A and its own zone code is of length kA.",
                "Then, given an event E, node A only hashes E to a zone code of length kA.",
                "We denote the zone code assigned to an event E by code(E).",
                "As we describe below, as the event is routed, code(E) is refined by intermediate nodes.",
                "This lazy evaluation of zone codes allows different nodes to use different length zone codes without any explicit coordination. 3.3.2 Routing an Event to its Owner The aim of hashing an event to a zone code is to store the event at the node within the network node that owns that zone.",
                "We call this node the owner of the event.",
                "Consider an event E that has just been generated at a node A.",
                "After encoding event E, node A compares code(E) with code(A).",
                "If the two are identical, node A store event E locally; otherwise, node A will attempt to route the event to its owner.",
                "To do this, note that code(E) corresponds to some zone Z , which is As current guess for the zone at which event E should be stored.",
                "A now invokes GPSR to send a message to addr(Z ) (the centroid of Z , Section 3.1).",
                "The message contains the event E, code(E), and the target geographic location for storing the event.",
                "In the message, A also marks itself as the owner of event E. As we will see later, the guessed zone Z , the address addr(Z ), and the owner of E, all of them contained in the message, will be refined by intermediate forwarding nodes.",
                "GPSR now delivers this message to the next hop towards addr(Z ) from A.",
                "This next hop node (call it B) does not immediately forward the message.",
                "Rather, it attempts to com2 DIM does not assume that all nodes are homogeneous in terms of the sensors they have.",
                "Thus, in an m dimensional DIM, a node that does not possess all m sensors can use NULL values for the corresponding readings.",
                "DIM treats NULL as an extreme value for range comparisons.",
                "As an aside, a network may have many DIM instances running concurrently. 67 pute a new zone code for E to get a new code codenew(E).",
                "B will update the code contained in the message (and also the geographic destination of the message) if codenew(E) is longer than the event code in the message.",
                "In this manner, as the event wends its way to its owner, its zone code gets refined.",
                "Now, B compares its own code code(B) against the owner code owner(E) contained in the incoming message.",
                "If code(B) has a longer match with code(E) than the current owner owner(E), then B sets itself to be the current owner of E, meaning that if nobody is eligible to store E, then B will store the event (we shall see how this happens next).",
                "If Bs zone code does not exactly match code(E), B will invoke GPSR to deliver E to the next hop. 3.3.3 Resolving undecided zone boundaries during insertion Suppose that some node, say C, finds itself to be the destination (or eventual owner) of an event E. It does so by noticing that code code(C) equals code(E) after locally recomputing a code for E. In that case, C stores E locally, but only if all four of Cs zone boundaries are decided.",
                "When this condition holds, C knows for sure that no other nodes have overlapped zones with it.",
                "In this case, we call C an internal node.",
                "Recall, though, that because the zone discovery algorithm Section 3.2 only uses information from immediate neighbors, one or more of Cs boundaries may be undecided.",
                "If so, C assumes that some other nodes have a zone that overlaps with its own, and sets out to resolve this overlap.",
                "To do this, C now sets itself to be the owner of E and continues forwarding the message.",
                "Here we rely on GPSRs perimeter mode routing to probe around the void that causes the undecided boundary.",
                "Since the message starts from C and is destined for a geographic location near C, GPSR guarantees that the message will be delivered back to C if no other nodes will update the information in the message.",
                "If the message comes back to C with itself to be the owner, C infers that it must be the true owner of the zone and stores E locally.",
                "If this does not happen, there are two possibilities.",
                "The first is that as the event traverses the perimeter, some intermediate node, say B whose zone overlaps with Cs marks itself to be the owner of the event, but otherwise does not change the events zone code.",
                "This node also recognizes that its own zone overlaps with Cs and initiates a message exchange which causes each of them to appropriately shrink their zone.",
                "Figures 6 through 8 show an example of this data-driven zone shrinking.",
                "Initially, both node A and node B have claimed the same zone 0 because they are out of radio range of each other.",
                "Suppose that A inserts an event E = 0.4, 0.8, 0.9 .",
                "A encodes E to 0 and claims itself to be the owner of E. Since A is not an internal node, it sends out E, looking for other owner candidates of E. Once E gets to node B, B will see in the messages owner field As code that is the same as its own.",
                "B then shrinks its zone from 0 to 01 according to As location which is also recorded in the message and send a shrink request to A.",
                "Upon receiving this request, A also shrinks its zone from 0 to 00.",
                "A second possibility is if some intermediate node changes the destination code of E to a more specific value (i.e., longer zone code).",
                "Let us label this node D. D now tries to initiate delivery to the centroid of the new zone.",
                "This A B 0 0 110 100 1111 1110 101 Figure 6: Nodes A and B have claimed the same zone.",
                "A B <0.4,0.8,0.9> Figure 7: An event/query message (filled arrows) triggers zone shrinking (hollow arrows).",
                "A B 01 00 110 100 1111 1110 101 Figure 8: The zone layout after shrinking.",
                "Now node A and B have been mapped to different zones. might result in a new perimeter walk that returns to D (if, for example, D happens to be geographically closest to the centroid of the zone).",
                "However, D would not be the owner of the event, which would still be C. In routing to the centroid of this zone, the message may traverse the perimeter and return to D. Now D notices that C was the original owner, so it encapsulates the event and directs it to C. In case that there indeed is another node, say X, that owns an overlapped zone with C, X will notice this fact by finding in the message the same prefix of the code of one of its zones, but with a different geographic location from its own.",
                "X will shrink its zone to resolve the overlap.",
                "If Xs zone is smaller than or equal to Cs zone, X will also send a shrink request to C. Once C receives a shrink request, it will reduce its zone appropriately and fix its undecided boundary.",
                "In this manner, the zone formation process is resolved on demand in a data-driven way. 68 There are several interesting effects with respect to perimeter walking that arise in our algorithm.",
                "The first is that there are some cases where an event insertion might cause the entire outer perimeter of the network to be traversed3 .",
                "Figure 6 also works as an example where the outer perimeter is traversed.",
                "Event E inserted by A will eventually be stored in node B.",
                "Before node B stores event E, if Bs nominal radio range does not intersect the network boundary, it needs to send out E again as A did, because B in this case is not an internal node.",
                "But if Bs nominal radio range intersects the network boundary, it then has two choices.",
                "It can assume that there will not be any nodes outside the network boundary and so B is an internal node.",
                "This is an aggressive approach.",
                "On the other hand, B can also make a conservative decision assuming that there might be some other nodes it have not heard of yet.",
                "B will then force the message walking another perimeter before storing it.",
                "In some situations, especially for large zones where the node that owns a zone is far away from the centroid of the owned zone, there might exist a small perimeter around the destination that does not include the owner of the zone.",
                "The event will end up being stored at a different node than the real owner.",
                "In order to deal with this problem, we add an extra operation in event forwarding, called efficient neighbor discovery.",
                "Before invoking GPSR, a node needs to check if there exists a neighbor who is eligible to be the real owner of the event.",
                "To do this, a node C, say, needs to know the zone codes of its neighboring nodes.",
                "We deploy GPSRs beaconing message to piggyback the zone codes for nodes.",
                "So by simply comparing the events code and neighbors code, a node can decide whether there exists a neighbor Y which is more likely to be the owner of event E. C delivers E to Y , which simply follows the decision making procedure discussed above. 3.3.4 Summary and Pseudo-code In summary, our event insertion procedure is designed to nicely interact with the zone discovery mechanism, and the event hashing mechanism.",
                "The latter two mechanisms are kept simple, while the event insertion mechanism uses lazy evaluation at each hop to refine the events zone code, and it leverages GPSRs perimeter walking mechanism to fix undecided zone boundaries.",
                "In Section 3.5, we address robustness of event insertion to packet loss or to node failures.",
                "Figure 5 shows the pseudo-code for inserting and forwarding an event e. In this pseudo code, we have omitted a description of the zone shrinking procedure.",
                "In the pseudo code, procedure is Internal() is used to determine if the caller is an internal node and procedure is Owner() is used to determine if the caller is more eligible to be the owner of the event than is currently claimed owner as recorded in the message.",
                "Procedure Send-Message is used to send either an event message or a query message.",
                "If the message destination address has been changed, the packet source address needs also to be changed in order to avoid being dropped by GPSR, since GPSR does not allow a node to see the same packet in greedy mode twice. 3 This happens less frequently than for GHTs, where inserting an event to a location outside the actual (but inside the nominal) boundary of the network will always invoke an external perimeter walk. 3.4 Resolving and Routing Queries DIMs support both point queries4 and range queries.",
                "Routing a point query is identical to routing an event.",
                "Thus, the rest of this section details how range queries are routed.",
                "The key challenge in routing zone queries is brought out by the following strawman design.",
                "If the entire network was divided evenly into zones of depth k (for some pre-defined constant k), then the querier (the node issuing the query) could subdivide a given range query into the relevant subzones and route individual requests to each of the zones.",
                "This can be inefficient for large range queries and also hard to implement in our design where zone sizes are not predefined.",
                "Accordingly, we use a slightly different technique where a range query is initially routed to a zone corresponding to the entire range, and is then progressively split into smaller subqueries.",
                "We describe this algorithm here.",
                "The first step of the algorithm is to map a range query to a zone code prefix.",
                "Conceptually, this is easy; in a zone tree (Figure 3), there exists some node which contains the entire range query in its sub-tree, and none of its children in the tree do.",
                "The initial zone code we choose for the query is the zone code corresponding to that tree node, and is a prefix of the zone codes of all zones (note that these zones may not be geographically contiguous) in the subtree.",
                "The querier computes the zone code of Q, denoted by code(Q) and then starts routing a query to addr(code(Q)).",
                "Upon receiving a range query Q, a node A (where A is any node on the query propagation path) divides it into multiple smaller sized subqueries if there is an overlap between the zone of A, zone(A) and the zone code associated with Q, code(Q).",
                "Our approach to split a query Q into subqueries is as follows.",
                "If the range of Qs first attribute contains the value 0.5, A divides Q into two sub-queries one of whose first attribute ranges from 0 to 0.5, and the other from 0.5 to 1.",
                "Then A decides the half that overlaps with its own zone.",
                "Lets call it QA.",
                "If QA does not exist, then A stops splitting; otherwise, it continues splitting (using the second attribute range) and recomputing QA until QA is small enough so that it completely falls into zone(A) and hence A can now resolve it.",
                "For example, suppose that node A, whose code is 0110, is to split a range query Q = 0.3 − 0.8, 0.6 − 0.9 .",
                "The splitting steps is shown in Figure 2.",
                "After splitting, we obtain three smaller queries q0 = 0.3 − 0.5, 0.6 − 0.75 , q1 = 0.3 − 0.5, 0.75 − 0.9 , and q2 = 0.5 − 0.8, 0.6 − 0.9 .",
                "This splitting procedure is illustrated in Figure 9 which also shows the codes of each subquery after splitting.",
                "A then replies to subquery q0 with data stored locally and sends subqueries q1 and q2 using the procedure outlined above.",
                "More generally, if node A finds itself to be inside the zone subtree that maximally covers Q, it will send the subqueries that resulted from the split.",
                "Otherwise, if there is no overlap between A and Q, then A forwards Q as is (in this case Q is either the original query, or a product of an earlier split).",
                "Figure 10 describes the pseudo-code for the zone splitting algorithm.",
                "As shown in the above algorithm, once a subquery has been recognized as belonging to the callers zone, procedure Resolve is invoked to resolve the subquery and send a reply to the querier.",
                "Every query message contains 4 By point queries, we mean the equality condition on all indexed keys.",
                "DIM index attributes are not necessarily primary keys. 69 the geographic location of its initiator, so the corresponding reply message can be delivered directly back to the initiator.",
                "Finally, in the process of query resolution, zones might shrink similar to shrinkage during inserting.",
                "We omit this in the pseudo code. 3.5 Robustness Until now, we have not discussed the impact of node failures and packet losses, or node arrivals and departures on our algorithms.",
                "Packet losses can affect query and event insertion, and node failures can result in lost data, while node arrivals and departures can impact the zone structure.",
                "We now discuss how DIMs can be made robust to these kinds of dynamics. 3.5.1 Maintaining Zones In previous sections, we described how the zone discovery algorithm could leave zone boundaries undecided.",
                "These undecided boundaries are resolved during insertion or querying, using the zone shrinking procedure describe above.",
                "When a new node joins the network, the zone discovery mechanism (Section 3.2) will cause neighboring zones to appropriately adjust their zone boundaries.",
                "At this time, those zones can also transfer to the new node those events they store but which should belong to the new node.",
                "Before a node turns itself off (if this is indeed possible), it knows that its backup node (Section 3.1) will take over its zone, and will simply send all its events to its backup node.",
                "Node deletion may also cause zone expansion.",
                "In order to keep the mapping between the binary zone trees leaf nodes and zones, we allow zone expansion to only occur among sibling zones (Section 3.1).",
                "The rule is: if zone(A)s sibling zone becomes empty, then A can expand its own zone to include its sibling zone.",
                "Now, we turn our attention to node failures.",
                "Node failures are just like node deletions except that a failed node does not have a chance to move its events to another node.",
                "But how does a node decide if its sibling has failed?",
                "If the sibling is within radio range, the absence of GPSR beaconing messages can detect this.",
                "Once it detects this, the node can expand its zone.",
                "A different approach is needed for detecting siblings who are not within radio range.",
                "These are the cases where two nodes own their zones after exchanging a shrink message; they do not periodically exchange messages thereafter to maintain this zone relationship.",
                "In this case, we detect the failure in a data-driven fashion, with obvious efficiency benefits compared to periodic keepalives.",
                "Once a node B has failed, an event or query message that previously should have been owned by the failed node will now be delivered to the node A that owns the empty zone left by node B.",
                "A can see this message because A stands right around the empty area left by B and is guaranteed to be visited in a GPSR perimeter traversal.",
                "A will set itself to be the owner of the message, and any node which would have dropped this message due to a perimeter loop will redirect the message to A instead.",
                "If As zone happens to be the sibling of Bs zone, A can safely expand its own zone and notify its expanded zone to its neighbors via GPSR beaconing messages. 3.5.2 Preventing Data Loss from Node Failure The algorithms described above are robust in terms of zone formation, but node failure can erase data.",
                "To avoid this, DIMs can employ two kinds of replication: local replication to be resilient to random node failures, and mirror replication for resilience to concurrent failure of geographically contiguous nodes.",
                "Mirror replication is conceptually easy.",
                "Suppose an event E has a zone code code(E).",
                "Then, the node that inserts E would store two copies of E; one at the zone denoted by code(E), and the other at the zone corresponding to the ones complement of code(E).",
                "This technique essentially creates a mirror DIM.",
                "A querier would need, in parallel, to query both the original DIM and its mirror since there is no way of knowing if a collection of nodes has failed.",
                "Clearly, the trade-off here is an approximate doubling of both insertion and query costs.",
                "There exists a far cheaper technique to ensure resilience to random node failures.",
                "Our local replication technique rests on the observation that, for each node A, there exists a unique node which will take over its zone when A fails.",
                "This node is defined as the node responsible for As zones backup zone (see Section 3.1).",
                "The basic idea is that A replicates each data item it has in this node.",
                "We call this node As local replica.",
                "Let As local replica be B.",
                "Often B will be a radio neighbor of A and can be detected from GPSR beacons.",
                "Sometimes, however, this is not the case, and B will have to be explicitly discovered.",
                "We use an explicit message for discovering the local replica.",
                "Discovering the local replica is data-driven, and uses a mechanism similar to that of event insertion.",
                "Node A sends a message whose geographic destination is a random nearby location chosen by A.",
                "The location is close enough to A such that GPSR will guarantee that the message will delivered back to A.",
                "In addition, the message has three fields, one for the zone code of A, code(A), one for the owner owner(A) of zone(A) which is set to be empty, and one for the geographic location of owner(A).",
                "Then the packet will be delivered in GPSR perimeter mode.",
                "Each node that receives this message will compare its zone code and code(A) in the message, and if it is more eligible to be the owner of zone(A) than the current owner(A) recorded in the message, it will update the field owner(A) and the corresponding geographic location.",
                "Once the packet comes back to A, it will know the location of its local replica and can start to send replicas.",
                "In a dense sensor network, the local replica of a node is usually very near to the node, either its direct neighbor or 1-2 hops away, so the cost of sending replicas to local replication will not dominate the network traffic.",
                "However, a nodes local replica itself may fail.",
                "There are two ways to deal with this situation; periodic refreshes, or repeated datadriven discovery of local replicas.",
                "The former has higher overhead, but more quickly discovers failed replicas. 3.5.3 Robustness to Packet Loss Finally, the mechanisms for querying and event insertion can be easily made resilient to packet loss.",
                "For event insertion, a simple ACK scheme suffices.",
                "Of course, queries and responses can be lost as well.",
                "In this case, there exists an efficient approach for error recovery.",
                "This rests on the observation that the querier knows which zones fall within its query and should have responded (we assume that a node that has no data matching a query, but whose zone falls within the query, responds with a negative acknowledgment).",
                "After a conservative timeout, the querier can re-issue the queries selectively to these zones.",
                "If DIM cannot get any answers (positive or negative) from 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figure 9: An example of range query splitting Resolve-Range-Query(Q) 1 Qsub ← nil 2 q0, Qsub ← Split-Query(Q) 3 if q0 = nil 4 then c ← Encode(Q) 5 if Contain(c, code(A)) = true 6 then go to step 12 7 else Send-Message(c, q0) 8 else Resolve(q0) 9 if is Internal() = true 10 then Absorb (q0) 11 else Append q0 to Qsub 12 if Qsub = nil 13 then for each subquery q ∈ Qsub 14 do c ← Encode(q) 15 Send-Message(c, q) Figure 10: Query resolving algorithm certain zones after repeated timeouts, it can at least return the partial query results to the application together with the information about the zones from which data is missing. 4.",
                "DIMS: AN ANALYSIS In this section, we present a simple analytic performance evaluation of DIMs, and compare their performance against other possible approaches for implementing multi-dimensional range queries in sensor networks.",
                "In the next section, we validate these analyses using detailed packet-level simulations.",
                "Our primary metrics for the performance of a DIM are: Average Insertion Cost measures the average number of messages required to insert an event into the network.",
                "Average Query Delivery Cost measures the average number of messages required to route a query message to all the relevant nodes in the network.",
                "It does not measure the number of messages required to transmit responses to the querier; this latter number depends upon the precise data distribution and is the same for many of the schemes we compare DIMs against.",
                "In DIMs, event insertion essentially uses geographic routing.",
                "In a dense N-node network where the likelihood of traversing perimeters is small, the average event insertion cost proportional to √ N [23].",
                "On the other hand, the query delivery cost depends upon the size of ranges specified in the query.",
                "Recall that our query delivery mechanism is careful about splitting a query into sub-queries, doing so only when the query nears the zone that covers the query range.",
                "Thus, when the querier is far from the queried zone, there are two components to the query delivery cost.",
                "The first, which is proportional to √ N, is the cost to deliver the query near the covering zone.",
                "If within this covering zone, there are M nodes, the message delivery cost of splitting the query is proportional to M. The average cost of query delivery depends upon the distribution of query range sizes.",
                "Now, suppose that query sizes follow some density function f(x), then the average cost of resolve a query can be approximated by Ê N 1 xf(x)dx.",
                "To give some intuition for the performance of DIMs, we consider four different forms for f(x): the uniform distribution where a query range encompassing the entire network is as likely as a point query; a bounded uniform distribution where all sizes up to a bound B are equally likely; an algebraic distribution in which most queries are small, but large queries are somewhat likely; and an exponential distribution where most queries are small and large queries are unlikely.",
                "In all our analyses, we make the simplifying assumption that the size of a query is proportional to the number of nodes that can answer that query.",
                "For the uniform distribution P(x) ∝ c for some constant c. If each query size from 1 . . .",
                "N is equally likely, the average query delivery cost of uniformly distributed queries is O(N).",
                "Thus, for uniformly distributed queries, the performance of DIMs is comparable to that of flooding.",
                "However, for the applications we envision, where nodes within the network are trying to correlate events, the uniform distribution is highly unrealistic.",
                "Somewhat more realistic is a situation where all query sizes are bounded by a constant B.",
                "In this case, the average cost for resolving such a query is approximately Ê B 1 xf(x)dx = O(B).",
                "Recall now that all queries have to pay an approximate cost of O( √ N) to deliver the query near the covering zone.",
                "Thus, if DIM limited queries to a size proportional to√ N, the average query cost would be O( √ N).",
                "The algebraic distribution, where f(x) ∝ x−k , for some constant k between 1 and 2, has an average query resolution cost given by Ê N 1 xf(x)dx = O(N2−k ).",
                "In this case, if k > 1.5, the average cost of query delivery is dominated by the cost to deliver the query to near the covering zone, given by O( √ N).",
                "Finally, for the exponential distribution, f(x) = ce−cx for some constant c, and the average cost is just the mean of the corresponding distribution, i.e., O(1) for large N. Asymptotically, then, the cost of the query for the exponential distribution is dominated by the cost to deliver the query near the covering zone (O( √ N)).",
                "Thus, we see that if queries follow either the bounded uniform distribution, the algebraic distribution, or the exponential distribution, the query cost scales as the insertion cost (for appropriate choice of constants for the bounded uniform and the algebraic distributions).",
                "How well does the performance of DIMs compare against alternative choices for implementing multi-dimensional queries?",
                "A simple alternative is called external storage [23], where all events are stored centrally in a node outside the sensor network.",
                "This scheme incurs an insertion cost of O( √ N), and a zero query cost.",
                "However, as [23] points out, such systems may be impractical in sensor networks since the access link to the external node becomes a hotspot.",
                "A second alternative implementation would store events at the node where they are generated.",
                "Queries are flooded 71 throughout the network, and nodes that have matching data respond.",
                "Examples of systems that can be used for this (although, to our knowledge, these systems do not implement multi-dimensional range queries) are Directed Diffusion [15] and TinyDB [17].",
                "The flooding scheme incurs a zero insertion cost, but an O(N) query cost.",
                "It is easy to show that DIMs outperform flooding as long as the ratio of the number of insertions to the number of queries is less than √ N. A final alternative would be to use a geographic hash table (GHT [20]).",
                "In this approach, attribute values are assumed to be integers (this is actually quite a reasonable assumption since attribute values are often quantized), and events are hashed on some (say, the first) attribute.",
                "A range query is sub-divided into several sub-queries, one for each integer in the range of the first attribute.",
                "Each sub-query is then hashed to the appropriate location.",
                "The nodes that receive a sub-query only return events that match all other attribute ranges.",
                "In this approach, which we call GHT-R (GHTs for range queries) the insertion cost is O( √ N).",
                "Suppose that the range of the first attribute contains r discrete values.",
                "Then the cost to deliver queries is O(r √ N).",
                "Thus, asymptotically, GHT-Rs perform similarly to DIMs.",
                "In practice, however, the proportionality constants are significantly different, and DIMs outperform GHT-Rs, as we shall show using detailed simulations. 5.",
                "DIMS: SIMULATION RESULTS Our analysis gives us some insight into the asymptotic behavior of various approaches for multi-dimensional range queries.",
                "In this section, we use simulation to compare DIMs against flooding and GHT-R; this comparison gives us a more detailed understanding of these approaches for moderate size networks, and gives us a nuanced view of the mechanistic differences between some of these approaches. 5.1 Simulation Methodology We use ns-2 for our simulations.",
                "Since DIMs are implemented on top of GPSR, we first ported an earlier GPSR implementation to the latest version of ns-2.",
                "We modified the GPSR module to call our DIM implementation when it receives any data message in transit or when it is about to drop a message because that message traversed the entire perimeter.",
                "This allows a DIM to modify message zone codes in flight (Section 3), and determine the actual owner of an event or query.",
                "In addition, to this, we implemented in ns-2 most of the DIM mechanisms described in Section 3.",
                "Of those mechanisms, the only one we did not implement is mirror replication.",
                "We have implemented selective query retransmission for resiliency to packet loss, but have left the evaluation of this mechanism to future work.",
                "Our DIM implementation in ns-2 is 2800 lines of code.",
                "Finally, we implemented GHT-R, our GHT-based multidimensional range query mechanism in ns-2.",
                "This implementation was relatively straightforward, given that we had ported GPSR, and modified GPSR to detect the completion of perimeter mode traversals.",
                "Using this implementation, we conducted a fairly extensive evaluation of DIM and two alternatives (flooding, and our GHT-R).",
                "For all our experiments, we use uniformly placed sensor nodes with network sizes ranging from 50 nodes to 300 nodes.",
                "Each node has a radio range of 40m.",
                "For the results presented here, each node has on average 20 nodes within its nominal radio range.",
                "We have conducted experiments at other node densities; they are in agreement with the results presented here.",
                "In all our experiments, each node first generates 3 events5 on average (more precisely, for a topology of size N, we have 3N events, and each node is equally likely to generate an event).",
                "We have conducted experiments for three different event value distributions.",
                "Our uniform event distribution generates 2-dimensional events and, for each dimension, every attribute value is equally likely.",
                "Our normal event distribution generates 2-dimensional events and, for each dimension, the attribute value is normally distributed with a mean corresponding to the mid-point of the attribute value range.",
                "The normal event distribution represents a skewed data set.",
                "Finally, our trace event distribution is a collection of 4-dimensional events obtained from a habitat monitoring network.",
                "As we shall see, this represents a fairly skewed data set.",
                "Having generated events, for each simulation we generate queries such that, on average, each node generates 2 queries.",
                "The query sizes are determined using the four size distributions we discussed in Section 4: uniform, boundeduniform, algebraic and exponential.",
                "Once a query size has been determined, the location of the query (i.e., the actual boundaries of the zone) are uniformly distributed.",
                "For our GHT-R experiments, the dynamic range of the attributes had 100 discrete values, but we restricted the query range for any one attribute to 50 discrete values to allow those simulations to complete in reasonable time.",
                "Finally, using one set of simulations we evaluate the efficacy of local replication by turning off random fractions of nodes and measuring the fidelity of the returned results.",
                "The primary metrics for our simulations are the average query and insertion costs, as defined in Section 4. 5.2 Results Although we have examined almost all the combinations of factors described above, we discuss only the most salient ones here, for lack of space.",
                "Figure 11 plots the average insertion costs for DIM and GHT-R (for flooding, of course, the insertion costs are zero).",
                "DIM incurs less per event overhead in inserting events (regardless of the actual event distribution; Figure 11 shows the cost for uniformly distributed events).",
                "The reason for this is interesting.",
                "In GHT-R, storing almost every event incurs a perimeter traversal, and storing some events require traversing the outer perimeter of the network [20].",
                "By contrast, in DIM, storing an event incurs a perimeter traversal only when a nodes boundaries are undecided.",
                "Furthermore, an insertion or a query in a DIM can traverse the outer perimeter (Section 3.3), but less frequently than in GHTs.",
                "Figure 13 plots the average query cost for a bounded uniform query size distribution.",
                "For this graph (and the next) we use a uniform event distribution, since the event distribution does not affect the query delivery cost.",
                "For this simulation, our bound was 1 4 th the size of the largest possible 5 Our metrics are chosen so that the exact number of events and queries is unimportant for our discussion.",
                "Of course, the overall performance of the system will depend on the relative frequency of events and queries, as we discuss in Section 4.",
                "Since we dont have realistic ratios for these, we focus on the microscopic costs, rather than on the overall system costs. 72 0 2 4 6 8 10 12 14 16 18 20 50 100 150 200 250 300 AverageCostperInsertion Network Size DIM GHT-R Figure 11: Average insertion cost for DIM and GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fractionofrepliescomparedwithnon-failurecase Fraction of failed nodes (%) No Replication Local Replication Figure 12: Local replication performance. query (e.g., a query of the form 0 − 0.5, 0 − 0.5 .",
                "Even for this generous query size, DIMs perform quite well (almost a third the cost of flooding).",
                "Notice, however, that GHTRs incur high query cost since almost any query requires as many subqueries as the width of the first attributes range.",
                "Figure 14 plots the average query cost for the exponential distribution (the average query size for this distribution was set to be 1 16 th the largest possible query).",
                "The superior scaling of DIMs is evident in these graphs.",
                "Clearly, this is the regime in which one might expect DIMs to perform best, when most of the queries are small and large queries are relatively rare.",
                "This is also the regime in which one would expect to use multi-dimensional range queries: to perform relatively tight correlations.",
                "As with the bounded uniform distribution, GHT query cost is dominated by the cost of sending sub-queries; for DIMs, the query splitting strategy works quite well in keep overall query delivery costs low.",
                "Figure 12 describes the efficacy of local replication.",
                "To obtain this figure, we conducted the following experiment.",
                "On a 100-node network, we inserted a number of events uniformly distributed throughout the network, then issued a query covering the entire network and recorded the answers.",
                "Knowing the expected answers for this query, we then successively removed a fraction f of nodes randomly, and re-issued the same query.",
                "The figure plots the fraction of expected responses actually received, with and without replication.",
                "As the graph shows, local replication performs well for random failures, returning almost 90% of the responses when up to 30% of the nodes have failed simultaneously 6 .In the absence of local replication, of course, when 6 In practice, the performance of local replication is likely to 0 100 200 300 400 500 600 700 50 100 150 200 250 300 AverageCostperQueryinBoundedUnifDistribution Network Size DIM flooding GHT-R Figure 13: Average query cost with a bounded uniform query distribution 0 50 100 150 200 250 300 350 400 450 50 100 150 200 250 300 AverageCostperQueryinExponentialDistribution Network Size DIM flooding GHT-R Figure 14: Average query cost with an exponential query distribution 30% of the nodes fail, the response rate is only 70% as one would expect.",
                "We note that DIMs (as currently designed) are not perfect.",
                "When the data is highly skewed-as it was for our trace data set from the habitat monitoring application where most of the event values fell into within 10% of the attributes range-a few DIM nodes will clearly become the bottleneck.",
                "This is depicted in Figure 15, which shows that for DIMs, and GHT-Rs, the maximum number of transmissions at any network node (the hotspots) is rather high. (For less skewed data distributions, and reasonable query size distributions, the hotspot curves for all three schemes are comparable.)",
                "This is a standard problem that the database indices have dealt with by tree re-balancing.",
                "In our case, simpler solutions might be possible (and we discuss this in Section 7).",
                "However, our use of the trace data demonstrates that DIMs work for events which have more than two dimensions.",
                "Increasing the number of dimensions does not noticeably degrade DIMs query cost (omitted for lack of space).",
                "Also omitted are experiments examining the impact of several other factors, as they do not affect our conclusions in any way.",
                "As we expected, DIMs are comparable in performance to flooding when all sizes of queries are equally likely.",
                "For an algebraic distribution of query sizes, the relative performance is close to that for the exponential distribution.",
                "For normally distributed events, the insertion costs be much better than this.",
                "Assuming a node and its replica dont simultaneously fail often, a node will almost always detect a replica failure and re-replicate, leading to near 100% response rates. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 MaximumHotspotonTraceDataSet Network Size DIM flooding GHT-R Figure 15: Hotspot usage DIM Zone Manager Query Router Query Processor Event Manager Event Router GPSR interface(Event driven/Thread based) update useuse update GPSR Upper interface(Event driven/Thread based) Lower interface(Event driven/Thread based) Greedy Forwarding Perimeter Forwarding Beaconing Neighbor List Manager update use MoteNIC (MicaRadio) IP Socket (802.11b/Ethernet) Figure 16: Software architecture of DIM over GPSR are comparable to that for the uniform distribution.",
                "Finally, we note that in all our evaluations we have only used list queries (those that request all events matching the specified range).",
                "We expect that for summary queries (those that expect an aggregate over matching events), the overall cost of DIMs could be lower because the matching data are likely to be found in one or a small number of zones.",
                "We leave an understanding of this to future work.",
                "Also left to future work is a detailed understanding of the impact of location error on DIMs mechanisms.",
                "Recent work [22] has examined the impact of imprecise location information on other data-centric storage mechanisms such as GHTs, and found that there exist relatively simple fixes to GPSR that ameliorate the effects of location error. 6.",
                "IMPLEMENTATION We have implemented DIMs on a Linux platform suitable for experimentation on PDAs and PC-104 class machines.",
                "To implement DIMs, we had to develop and test an independent implementation of GPSR.",
                "Our GPSR implementation is full-featured, while our DIM implementation has most of the algorithms discussed in Section 3; some of the robustness extensions have only simpler variants implemented.",
                "The software architecture of DIM/GPSR system is shown in Figure 16.",
                "The entire system (about 5000 lines of code) is event-driven and multi-threaded.",
                "The DIM subsystem consists of six logical components: zone management, event maintenance, event routing, query routing, query processing, and GPSR interactions.",
                "The GPSR system is implemented as user-level daemon process.",
                "Applications are executed as clients.",
                "For the DIM subsystem, the GPSR module 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query size Average#ofreceivedresponses perquery Figure 17: Number of events received for different query sizes 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Query sizeTotalnumberofmessages onlyforsendingthequery Figure 18: Query distribution cost provides several extensions: it exports information about neighbors, and provides callbacks during packet forwarding and perimeter-mode termination.",
                "We tested our implementation on a testbed consisting of 8 PC-104 class machines.",
                "Each of these boxes runs Linux and uses a Mica mote (attached through a serial cable) for communication.",
                "These boxes are laid out in an office building with a total spatial separation of over a hundred feet.",
                "We manually measured the locations of these nodes relative to some coordinate system and configured the nodes with their location.",
                "The network topology is approximately a chain.",
                "On this testbed, we inserted queries and events from a single designated node.",
                "Our events have two attributes which span all combinations of the four values [0, 0.25, 0.75, 1] (sixteen events in all).",
                "Our queries span four sizes, returning 1, 4, 9 and 16 events respectively.",
                "Figure 17 plots the number of events received for different sized queries.",
                "It might appear that we received fewer events than expected, but this graph doesnt count the events that were already stored at the querier.",
                "With that adjustment, the number of responses matches our expectation.",
                "Finally, Figure 18 shows the total number of messages required for different query sizes on our testbed.",
                "While these experiments do not reveal as much about the performance range of DIMs as our simulations do, they nevertheless serve as proof-of-concept for DIMs.",
                "Our next step in the implementation is to port DIMs to the Mica motes, and integrate them into the TinyDB [17] sensor database engine on motes. 74 7.",
                "CONCLUSIONS In this paper, we have discussed the design and evaluation of a distributed data structure called DIM for efficiently resolving multi-dimensional range queries in sensor networks.",
                "Our design of DIMs relies upon a novel locality-preserving hash inspired by early work in database indexing, and is built upon GPSR.",
                "We have a working prototype, both of GPSR and DIM, and plan to conduct larger scale experiments in the future.",
                "There are several interesting future directions that we intend to pursue.",
                "One is adaptation to skewed data distributions, since these can cause storage and transmission hotspots.",
                "Unlike traditional database indices that re-balance trees upon data insertion, in sensor networks it might be feasible to re-structure the zones on a much larger timescale after obtaining a rough global estimate of the data distribution.",
                "Another direction is support for node heterogeneity in the zone construction process; nodes with larger storage space assert larger-sized zones for themselves.",
                "A third is support for efficient resolution of existential queries-whether there exists an event matching a multi-dimensional range.",
                "Acknowledgments This work benefited greatly from discussions with Fang Bian, Hui Zhang and other ENL lab members, as well as from comments provided by the reviewers and our shepherd Feng Zhao. 8.",
                "REFERENCES [1] J. Aspnes and G. Shah.",
                "Skip Graphs.",
                "In Proceedings of 14th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), Baltimore, MD, January 2003. [2] J. L. Bentley.",
                "Multidimensional Binary Search Trees Used for Associative Searching.",
                "Communicaions of the ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke, and P. Seshadri.",
                "Towards Sensor Database Systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management, Hong Kong, January 2001. [4] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong.",
                "Freenet: A Distributed Anonymous Information Storage and Retrieval System.",
                "In Designing Privacy Enhancing Technologies: International Workshop on Design Issues in Anonymity and Unobservability.",
                "Springer, New York, 2001. [5] D. Comer.",
                "The Ubiquitous B-tree.",
                "ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel and J. L. Bentley.",
                "Quad Trees: A Data Structure for Retrieval on Composite Keys.",
                "Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin, and J. Heidemann.",
                "DIMENSIONS: Why do we need a new Data Handling architecture for Sensor Networks?",
                "In Proceedings of the First Workshop on Hot Topics In Networks (HotNets-I), Princeton, NJ, October 2002. [8] A. Gionis, P. Indyk, and R. Motwani.",
                "Similarity Search in High Dimensions via Hashing.",
                "In Proceedings of the 25th VLDB conference, Edinburgh, Scotland, September 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin, and S. Shenker.",
                "The Sensor Network as a Database.",
                "Technical Report 02-771, Computer Science Department, University of Southern California, September 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A Distributed Index for Features in Sensor Networks.",
                "In Proceedings of 1st IEEE International Workshop on Sensor Network Protocols and Applications, Anchorage, AK, May 2003. [11] A. Guttman.",
                "R-trees: A Dynamic Index Structure for Spatial Searching.",
                "In Proceedings of the ACM SIGMOD, Boston, MA, June 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker, and I. Stoica.",
                "Complex Queries in DHT-based Peer-to-Peer Networks.",
                "In P. Druschel, F. Kaashoek, and A. Rowstron, editors, Proceedings of 1st International Workshop on Peer-to-Peer Systems (IPTPS02), volume 2429 of LNCS, page 242, Cambridge, MA, March 2002.",
                "Springer-Verlag. [13] P. Indyk and R. Motwani.",
                "Approximate Nearest Neighbors: Towards Removing the Curse of Dimensionality.",
                "In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, Dallas, Texas, May 1998. [14] P. Indyk, R. Motwani, P. Raghavan, and S. Vempala.",
                "Locality-preserving Hashing in Multidimensional Spaces.",
                "In Proceedings of the 29th Annual ACM symposium on Theory of Computing, pages 618 - 625, El Paso, Texas, May 1997.",
                "ACM Press. [15] C. Intanagonwiwat, R. Govindan, and D. Estrin.",
                "Directed Diffusion: A Scalable and Robust Communication Paradigm for Sensor Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [16] B. Karp and H. T. Kung.",
                "GPSR: Greedy Perimeter Stateless Routing for Wireless Networks.",
                "In Proceedings of the Sixth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom 2000), Boston, MA, August 2000. [17] S. Madden, M. Franklin, J. Hellerstein, and W. Hong.",
                "The Design of an Acquisitional Query Processor for Sensor Networks.",
                "In Proceedings of ACM SIGCMOD, San Diego, CA, June 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong.",
                "TAG: a Tiny AGregation Service for ad-hoc Sensor Networks.",
                "In Proceedings of 5th Annual Symposium on Operating Systems Design and Implementation (OSDI), Boston, MA, December 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A Scalable Content-Addressable Network.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT: A Geographic Hash Table for Data-Centric Storage.",
                "In Proceedings of the First ACM International Workshop on Wireless Sensor Networks and Applications, Atlanta, GA, September 2002. [21] H. Samet.",
                "Spatial Data Structures.",
                "In W. Kim, editor, Modern Database Systems: The Object Model, Interoperability and Beyond, pages 361-385.",
                "Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, and R. Govindan.",
                "On the Effect of Localization Errors on Geographic Face Routing in Sensor Networks.",
                "In Under submission, 2003. [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan, and D. Estrin.",
                "Data-Centric Storage in Sensornets.",
                "In Proc.",
                "ACM SIGCOMM Workshop on Hot Topics In Networks, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan.",
                "Chord: A Scalable Peer-To-Peer Lookup Service for Internet Applications.",
                "In Proceedings of the ACM SIGCOMM, San Diego, CA, August 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu, and L. Zhang.",
                "A Two-Tier Data Dissemination Model for Large-scale Wireless Sensor Networks.",
                "In Proceedings of the Eighth Annual ACM/IEEE International Conference on Mobile Computing and Networking (Mobicom02), Atlanta, GA, September 2002. 75"
            ],
            "original_annotated_samples": [
                "For example, if in a habitat monitoring application, a bird alighting on its nest is indicated by a certain range of thermopile sensor readings, and a certain range of microphone readings, a <br>multi-dimensional range query</br> on those attributes enables higher confidence detection of the arrival of a flock of birds, and can trigger a system of cameras."
            ],
            "translated_annotated_samples": [
                "Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una <br>consulta de rango multidimensional</br> en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras."
            ],
            "translated_text": "Consultas de rango multidimensionales en redes de sensores∗ Xin Li † Young Jin Kim † Ramesh Govindan † Wei Hong ‡ RESUMEN En muchas redes de sensores, los datos o eventos se nombran por atributos. Muchos de estos atributos tienen valores escalares, por lo que una forma natural de consultar eventos de interés es utilizar una consulta de rango multidimensional. Un ejemplo es: Enumere todos los eventos cuya temperatura se encuentre entre 50° y 60°, y cuyos niveles de luz se encuentren entre 10 y 15. Tales consultas son útiles para correlacionar eventos que ocurren dentro de la red. En este artículo, describimos el diseño de un índice distribuido que admite de manera escalable consultas de rango multidimensionales. Nuestro índice distribuido para datos multidimensionales (o DIM) utiliza una incrustación geográfica novedosa de una estructura de datos de índice clásica, y se basa en el algoritmo de enrutamiento geográfico GPSR. Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de otras alternativas a veces son hasta un orden de magnitud mayores que los costos de las DIMs, incluso para redes de tamaño moderado. Finalmente, los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Comunicación de Computadoras]: Sistemas Distribuidos; C.3 [Sistemas Especiales y Basados en Aplicaciones]: Sistemas Embebidos Términos Generales Sistemas Embebidos, Redes de Sensores, Almacenamiento 1. En las redes de sensores inalámbricos, los datos o eventos serán nombrados por atributos [15] o representados como relaciones virtuales en una base de datos distribuida [18, 3]. Muchos de estos atributos tendrán valores escalares: por ejemplo, temperatura y niveles de luz, condiciones de humedad del suelo, etc. En estos sistemas, sostenemos que una forma natural de buscar eventos de interés será utilizar consultas de rango multidimensional en estos atributos. Por ejemplo, los científicos que analizan el crecimiento de microorganismos marinos podrían estar interesados en eventos que ocurrieron dentro de ciertas condiciones de temperatura y luz: Enumere todos los eventos que tengan temperaturas entre 50°F y 60°F, y niveles de luz entre 10 y 20. Tales consultas de rango se pueden utilizar de dos formas distintas. Pueden ayudar a los usuarios a refinar eficientemente su búsqueda de eventos de interés. La consulta descrita anteriormente ilustra esto, donde el científico presumiblemente está interesado en descubrir, y quizás mapear, el efecto combinado de la temperatura y la luz en el crecimiento de los microorganismos marinos. Más importante aún, pueden ser utilizados por software de aplicación que se ejecuta dentro de una red de sensores para correlacionar eventos y activar acciones. Por ejemplo, si en una aplicación de monitoreo de hábitats, el aterrizaje de un pájaro en su nido se indica por un cierto rango de lecturas de sensor de termopila, y un cierto rango de lecturas de micrófono, una <br>consulta de rango multidimensional</br> en esos atributos permite una detección de la llegada de una bandada de pájaros con mayor confianza, y puede activar un sistema de cámaras. En los sistemas de bases de datos tradicionales, estas consultas de rango se admiten utilizando índices precalculados. Los índices sacrifican un costo inicial de pre-cómputo para lograr una capacidad de consulta significativamente más eficiente. Para las redes de sensores, afirmamos que un índice centralizado para consultas de rango multidimensional puede no ser factible por razones de eficiencia energética (así como por el hecho de que el ancho de banda de acceso a este índice central estará limitado, especialmente para consultas que provienen desde dentro de la red). Más bien, creemos que habrá situaciones en las que sea más apropiado construir una estructura de datos distribuida en la red para responder eficientemente a consultas de rango multidimensionales. En este artículo, presentamos una estructura de datos que llamamos DIM1. Los DIMs están inspirados en los índices de bases de datos clásicas, y son básicamente incrustaciones de dichos índices dentro de la red de sensores. Las DIMs aprovechan dos ideas clave: un Índice Distribuido en la Red para datos multidimensionales y un almacenamiento centrado en datos, y un novedoso hash geográfico que preserva la localidad (Sección 3). Las DIMs rastrean su linaje hasta los sistemas de almacenamiento centrados en datos [23]. El mecanismo subyacente en estos sistemas permite a los nodos hashear de manera consistente un evento a alguna ubicación dentro de la red, lo que facilita la recuperación eficiente de eventos. Basándose en esto, las DIMs utilizan una técnica en la que los eventos cuyos valores de atributos son cercanos probablemente se almacenen en los mismos nodos o en nodos cercanos. Los DIMs luego utilizan un algoritmo de enrutamiento geográfico subyacente (GPSR [16]) para dirigir eventos y consultas a sus nodos correspondientes de manera completamente distribuida. Discutimos el diseño de un DIM, presentando algoritmos para la inserción y consulta de eventos, para mantener un DIM en caso de fallo de nodo, y para hacer que los DIM sean robustos ante la pérdida de datos o paquetes (Sección 3). Luego evaluamos exhaustivamente los DIMs utilizando análisis (Sección 4), simulación (Sección 5) e implementación real (Sección 6). Nuestro análisis revela que, bajo suposiciones razonables sobre las distribuciones de consultas, las DIMs escalan bastante bien con el tamaño de la red (tanto los costos de inserción como de consulta escalan como O( √ N)). En simulaciones detalladas, demostramos que en la práctica, los costos de inserción y consulta de eventos de otras alternativas a veces son de un orden de magnitud mayor que los costos de los DIMs, incluso para redes de tamaño moderado. Los experimentos en un banco de pruebas a pequeña escala validan la viabilidad de las DIMs (Sección 6). Queda mucho trabajo por hacer, incluyendo un soporte eficiente para distribuciones de datos sesgadas, consultas existenciales y heterogeneidad de nodos. Creemos que las DIMs serán una estructura de datos distribuida esencial, pero quizás no necesariamente la única, que respalde consultas eficientes en redes de sensores. Los DIMs formarán parte de un conjunto de sistemas que permiten la extracción de características [7], consultas de rango simples [10], consultas de coincidencia exacta [23] o consultas continuas [15, 18]. Todos esos sistemas probablemente se integrarán a un sistema de base de datos de red de sensores como TinyDB [17]. Los diseñadores de aplicaciones podrían entonces elegir el método apropiado de acceso a la información. Por ejemplo, una aplicación de seguimiento de incendios utilizaría DIM para detectar los puntos calientes, y luego utilizaría mecanismos que permiten consultas continuas para rastrear el progreso espacio-temporal de los puntos calientes. Finalmente, observamos que las DIMs no solo son aplicables a las redes de sensores, sino también a otros sistemas profundamente distribuidos (redes integradas para la automatización del hogar y la fábrica). TRABAJO RELACIONADO El problema básico que aborda este documento, las consultas de rango multidimensionales, se resuelve típicamente en sistemas de bases de datos utilizando técnicas de indexación. La comunidad de bases de datos se ha centrado principalmente en índices centralizados, pero la indexación distribuida ha recibido cierta atención en la literatura. Las técnicas de indexación básicamente sacrifican parte del costo de inserción de datos para permitir consultas eficientes. La indexación ha sido durante mucho tiempo un problema de investigación clásico en la comunidad de bases de datos [5, 2]. Nuestro trabajo se inspira en la clase de estructuras de índices de ramificación constante de múltiples claves, ejemplificadas por los árboles k-d [2], donde k representa la dimensionalidad del espacio de datos. Nuestro enfoque representa esencialmente una incrustación geográfica de tales estructuras en un campo sensorial. Hay una diferencia importante. Las estructuras de indexación clásicas son dependientes de los datos (al igual que algunos esquemas de indexación que utilizan funciones hash preservadoras de la localidad, desarrolladas en la literatura teórica [14, 8, 13]). La estructura del índice no solo está determinada por los datos, sino también por el orden en que se insertan los datos. Nuestro diseño actual no depende de datos. Finalmente, tangencialmente relacionada con nuestro trabajo está la clase de sistemas de indexación espacial [21, 6, 11]. Si bien ha habido algo de trabajo en indexación distribuida, el problema no ha sido explorado extensamente. Existen índices distribuidos de un tipo restringido: aquellos que permiten consultas de coincidencia exacta o de prefijo parcial. Ejemplos de tales sistemas, por supuesto, son el Sistema de Nombres de Dominio de Internet y la clase de sistemas de tabla hash distribuida (DHT) ejemplificados por Freenet[4], Chord[24] y CAN[19]. Nuestro trabajo es superficialmente similar a CAN en el sentido de que ambos construyen una superposición basada en zonas sobre la red física subyacente. Los detalles subyacentes hacen que los dos sistemas sean muy diferentes: la superposición de CAN es puramente lógica, mientras que nuestra superposición es coherente con la topología física subyacente. El trabajo más reciente en el contexto de Internet ha abordado el soporte para consultas de rango en sistemas DHT [1, 12], pero no está claro si esto se traduce directamente al contexto de redes de sensores. Varios esfuerzos de investigación han expresado la visión de una interfaz de base de datos para redes de sensores [9, 3, 18], y existen ejemplos de sistemas que contribuyen a esta visión [18, 3, 17]. Nuestro trabajo es similar en espíritu a este cuerpo de literatura. De hecho, los DIMs podrían convertirse en un componente importante de un sistema de base de datos de red de sensores como TinyDB [17]. Nuestro trabajo se aparta del trabajo previo en esta área en dos aspectos significativos. A diferencia de estos enfoques, en nuestro trabajo los datos generados en un nodo se hashean (en general) a diferentes ubicaciones. Este hash es la clave para escalar búsquedas de rango multidimensionales. En todos los otros sistemas descritos anteriormente, las consultas se propagan por toda la red y pueden dominar el costo total del sistema. Nuestro trabajo evita la inundación de consultas mediante una elección adecuada de hashing. Madden et al. [17] también describen un índice distribuido, llamado Árboles de Enrutamiento Semántico (SRT). Este índice se utiliza para dirigir consultas a nodos que han detectado datos relevantes. Nuestro trabajo difiere de SRT en tres aspectos clave. Primero, SRT se basa en atributos individuales mientras que DIM admite múltiples atributos. Segundo, SRT construye un árbol de enrutamiento basado en lecturas históricas de sensores, por lo tanto, funciona bien solo para valores de sensores que cambian lentamente. Finalmente, en las consultas de SRT se emiten desde un nodo fijo, mientras que en las consultas de DIM se pueden emitir desde cualquier nodo. Una diferenciación similar se aplica con respecto al trabajo en enrutamiento centrado en datos en redes de sensores [15, 25], donde se asume que los datos generados en un nodo se almacenan en el nodo, y las consultas se difunden por toda la red [15], o cada fuente establece una superposición en toda la red anunciando su presencia para que los sumideros móviles puedan encontrarse con las fuentes en el nodo más cercano en la superposición [25]. Estos enfoques funcionan bien para consultas relativamente duraderas. Finalmente, nuestro trabajo está más estrechamente relacionado con sistemas de almacenamiento centrados en datos [23], que incluyen tablas hash geográficas (GHTs) [20], DIMENSIONS [7] y DIFS [10]. En un GHT, los datos se hashean por nombre a una ubicación dentro de la red, lo que permite un encuentro altamente eficiente. Los GHTs se construyen sobre el protocolo GPSR [16] y aprovechan algunas propiedades interesantes de ese protocolo, como la capacidad de enrutar hacia un nodo más cercano a una ubicación dada. También aprovechamos las propiedades en GPSR (como describimos más adelante), pero utilizamos una función hash que preserva la localidad para almacenar datos, lo que permite consultas eficientes de rango multidimensional. DIMENSIONS y DIFS pueden considerarse como el uso del mismo conjunto de primitivas que GHT (almacenamiento utilizando hashing consistente), pero para diferentes propósitos: DIMENSIONS permite la búsqueda detallada de características dentro de una red de sensores, mientras que DIFS permite consultas de rango en una sola clave además de otras operaciones. El diseño de DIMS La mayoría de las redes de sensores se despliegan para recopilar datos del entorno. En estas redes, los nodos (ya sea individualmente o de manera colaborativa) generarán eventos. Un evento puede ser generalmente descrito como una tupla de valores de atributos, A1, A2, · · · , Ak , donde cada atributo Ai representa una lectura de sensor, o algún valor correspondiente a una detección (por ejemplo, un nivel de confianza). El enfoque de este documento es el diseño de sistemas para responder eficientemente a consultas de rango multidimensionales de la forma: x1 − y1, x2 − y2, · · · , xk − yk. Una consulta de este tipo devuelve todos los eventos cuyos valores de atributo caen dentro de los rangos correspondientes. Ten en cuenta que las consultas de punto, es decir, las consultas que solicitan eventos con valores específicos para cada atributo, son un caso especial de las consultas de rango. Como hemos discutido en la Sección 1, las consultas de rango pueden permitir una correlación eficiente y activación dentro de la red. Es posible implementar consultas de rango inundando una consulta dentro de la red. Sin embargo, como mostramos en secciones posteriores, esta alternativa puede ser ineficiente, especialmente a medida que el sistema se expande, y si los nodos dentro de la red emiten tales consultas con relativa frecuencia. La otra alternativa, enviar todos los eventos a un nodo de almacenamiento externo, resulta en que el enlace de acceso se convierte en un cuello de botella, especialmente si los nodos dentro de la red emiten consultas. Shenker et al. [23] también presentan argumentos similares con respecto a los esquemas de almacenamiento centrados en los datos en general; los DIMs son una instancia de tales esquemas. El sistema que presentamos en este artículo, el DIM, se basa en dos fundamentos: un hash geográfico que preserva la localidad y un esquema de enrutamiento geográfico subyacente. La clave para resolver consultas de rango de manera eficiente es la localidad de los datos: es decir, los eventos con valores de atributos comparables se almacenan cerca. La idea básica subyacente en DIM es que la localidad de los datos se puede obtener mediante una función hash geográfica que preserva la localidad. Nuestra función hash geográfica encuentra un mapeo que preserva la localidad desde el espacio multidimensional (descrito por el conjunto de atributos) a un espacio geográfico 2D; este mapeo está inspirado en los árboles k-d [2] y se describe más adelante. Además, cada nodo en la red se autoorganiza para reclamar una parte del espacio de atributos para sí mismo (decimos que cada nodo posee una zona), por lo que los eventos que caen en ese espacio son dirigidos y almacenados en ese nodo. Habiendo establecido el mapeo y la estructura de la zona, los DIMs utilizan un algoritmo de enrutamiento geográfico previamente desarrollado en la literatura para dirigir eventos a sus nodos correspondientes, o para resolver consultas. Este algoritmo, GPSR [16], básicamente permite la entrega de un paquete a un nodo en una ubicación especificada. El mecanismo de enrutamiento es simple: cuando un nodo recibe un paquete destinado a un nodo en la ubicación X, reenvía el paquete al vecino más cercano a X. En GPSR, esto se llama reenvío en modo voraz. Cuando no existe tal vecino (como cuando hay un vacío en la red), el nodo inicia el paquete en un recorrido en modo perímetro, utilizando la conocida regla de la mano derecha para circunnavegar los vacíos. GPSR incluye técnicas eficientes para el recorrido de perímetros que se basan en algoritmos de planarización de grafos adecuados para implementación distribuida. Para que todo esto funcione, los DIMs hacen dos suposiciones que son consistentes con la literatura [23]. Primero, todos los nodos conocen los límites geográficos aproximados de la red. Estos límites pueden configurarse en nodos en el momento de la implementación, o pueden descubrirse utilizando un protocolo simple. Segundo, cada nodo conoce su ubicación geográfica. Las ubicaciones de los nodos pueden ser determinadas automáticamente por un sistema de localización u otros medios. Aunque la idea básica de las DIMs puede parecer sencilla, resulta desafiante diseñar una estructura de datos completamente distribuida que debe ser robusta ante pérdidas de paquetes y fallos de nodos, pero que también debe admitir una distribución eficiente de consultas y lidiar con vacíos de comunicación y obstáculos. Ahora describimos el diseño completo de DIMs. 3.1 Zonas La idea clave detrás de DIMs, como hemos discutido, es un hash que preserva la localidad geográfica y que mapea un evento de múltiples atributos a una zona geográfica. De manera intuitiva, una zona es una subdivisión de la extensión geográfica de un campo de sensores. Una zona se define mediante el siguiente procedimiento constructivo. Considera un rectángulo R en el plano x-y. De manera intuitiva, R es el rectángulo delimitador que contiene todos los sensores dentro de la red. Llamamos a un subrectángulo Z de R una zona, si Z se obtiene dividiendo R k veces, k ≥ 0, utilizando un procedimiento que cumple la siguiente propiedad: Después de la i-ésima división, 0 ≤ i ≤ k, R se divide en 2i rectángulos de tamaño igual. Si i es un número impar (par), la i-ésima división es paralela al eje y (eje x). Es decir, el rectángulo delimitador R se divide primero en dos zonas en el nivel 0 mediante una línea vertical que divide R en dos partes iguales, cada una de estas subzonas puede dividirse en dos zonas en el nivel 1 mediante una línea horizontal, y así sucesivamente. Llamamos al entero no negativo k el nivel de la zona Z, es decir, nivel(Z) = k. Una zona puede ser identificada ya sea por un código de zona code(Z) o por una dirección addr(Z). El código code(Z) es una cadena de bits 0-1 de longitud level(Z), y se define de la siguiente manera. Si Z se encuentra en la mitad izquierda de R, el primer bit (desde la izquierda) de code(Z) es 0, de lo contrario es 1. Si Z se encuentra en la mitad inferior de R, el segundo bit del código(Z) es 0, de lo contrario, es 1. Los bits restantes del código (Z) se definen de forma recursiva en cada uno de los cuatro cuadrantes de R. Esta definición del código de zona coincide con la definición de zonas dada anteriormente, codificando divisiones de la geografía del campo del sensor mediante cadenas de bits. Por lo tanto, en la Figura 2, la zona en la esquina superior derecha del rectángulo R tiene un código de zona de 1111. Ten en cuenta que los códigos de zona definen colectivamente un árbol de zonas de tal manera que las zonas individuales se encuentran en las hojas de este árbol. La dirección de una zona Z, addr(Z), se define como el centroide del rectángulo definido por Z. Las dos representaciones de una zona (su código y su dirección) pueden ser calculadas una a partir de la otra, asumiendo que se conoce el nivel de la zona. Dos zonas se llaman zonas hermanas si sus códigos de zona son iguales excepto por el último bit. Por ejemplo, si el código(Z1) = 01101 y el código(Z2) = 01100, entonces Z1 y Z2 son zonas hermanas. El subárbol hermano de una zona es el subárbol enraizado en el hermano izquierdo o derecho de la zona en el árbol de la zona. Definimos de manera única una zona de respaldo para cada zona de la siguiente manera: si el subárbol hermano de la zona está a la izquierda, la zona de respaldo es la zona más a la derecha en el subárbol hermano; de lo contrario, la zona de respaldo es la zona más a la izquierda en el subárbol hermano. Para una zona Z, dejemos que p sean los primeros dígitos de nivel(Z) − 1 del código(Z). Que backup(Z) sea la zona de respaldo de la zona Z. Si code(Z) = p1, code(backup(Z)) = p01∗ con la mayor cantidad de 1s al final (∗ significa 0 o 1 ocurrencias). Si 65 código(Z) = p0, código(backup(Z)) = p10∗ con la mayor cantidad de ceros finales. 3.2 Asociación de Zonas con Nodos Nuestra definición de una zona es independiente de la distribución real de nodos en el campo del sensor, y solo depende de la extensión geográfica (el rectángulo delimitador) del campo del sensor. Ahora describimos cómo se asignan las zonas a los nodos. Conceptualmente, el campo de sensores se divide lógicamente en zonas y cada zona se asigna a un único nodo. Si la red de sensores se desplegara de manera regular en forma de cuadrícula, es fácil ver que existe un k tal que cada nodo se mapea en una zona de nivel-k distinta. En general, sin embargo, es probable que las ubicaciones de los nodos dentro de un campo de sensores sean menos regulares que en una cuadrícula. Para algunos valores de k, algunas zonas pueden estar vacías y otras zonas podrían tener más de un nodo situado dentro de ellas. Una alternativa habría sido elegir un k fijo para el sistema en general, y luego asociar los nodos con las zonas en las que se encuentran (y si una zona está vacía, asociar el nodo más cercano a ella, según alguna definición de cercanía). Debido a que simplifica nuestro sistema general de enrutamiento de consultas, permitimos que los nodos en un DIM se asignen a zonas de diferentes tamaños. Para comprender con precisión las asociaciones entre zonas y nodos, definimos la noción de propiedad de zona. Para cualquier ubicación dada de los nodos de la red, considera un nodo A. Sea ZA la zona más grande que incluye solo el nodo A y ningún otro nodo. Entonces, decimos que A posee ZA. Ten en cuenta que esta definición de propiedad puede dejar algunas secciones del campo de sensores sin asociar a un nodo. Por ejemplo, en la Figura 2, la zona 110 no contiene ningún nodo y no tendría propietario. Para remediar esto, para cualquier zona vacía Z, definimos al propietario como el propietario de la copia de seguridad de Z. En nuestro ejemplo, el propietario de las zonas vacías también sería el nodo que posee 1110, su zona de respaldo. Habiendo definido la asociación entre nodos y zonas, el siguiente problema que abordamos es: dado un emplazamiento de nodos, ¿existe un algoritmo distribuido que permita a cada nodo determinar qué zonas posee, sabiendo solo el límite general de la red de sensores? En principio, esto debería ser relativamente sencillo, ya que cada nodo puede simplemente determinar la ubicación de sus vecinos y aplicar métodos geométricos simples para determinar la zona más grande a su alrededor en la que ningún otro nodo resida. En la práctica, sin embargo, los vacíos y obstáculos de comunicación hacen que el algoritmo sea mucho más desafiante. En particular, resolver la propiedad de zonas que no contienen ningún nodo es complicado. Igualmente complicado es el caso en el que la zona de un nodo es más grande que su radio de comunicación y el nodo no puede determinar los límites de su zona solo con comunicación local. Nuestro algoritmo de construcción de zonas distribuidas pospone la resolución de dichas zonas hasta que se inicie una consulta o se inserte un evento. La idea básica detrás de nuestro algoritmo es que cada nodo construye tentativamente una idea de la zona en la que reside simplemente comunicándose con sus vecinos (recordando qué límites de la zona están indefinidos porque no hay vecinos de radio que puedan ayudar a resolver ese límite). Estos límites indecisos son posteriormente resueltos por un recorrido de perímetro GPSR cuando los mensajes de datos son enrutados realmente. Ahora describimos el algoritmo e ilustramos su funcionamiento con ejemplos. En nuestro algoritmo, cada nodo utiliza un arreglo bound[0..3] para mantener los cuatro límites de la zona que posee (recuerde que en este algoritmo, el nodo solo intenta determinar la zona en la que reside, no las otras zonas que podría poseer porque esas zonas están desprovistas de nodos). Cuando un nodo se inicia, cada nodo inicializa este arreglo para ser el límite de la red, es decir, inicialmente cada nodo asume que su zona contiene toda la red. El algoritmo de límite de zona ahora se basa en los mensajes de baliza de GPSR para aprender las ubicaciones de los vecinos dentro del alcance de radio. Al enterarse de tal vecino, el nodo llama al algoritmo en la Figura 4 para actualizar sus límites de zona y su código en consecuencia. En este algoritmo, asumimos que A es el nodo en el que se ejecuta el algoritmo, ZA es su zona, y a es un vecino recién descubierto de A. (El procedimiento Contain(ZA, a) se utiliza para decidir si el nodo a se encuentra dentro de los límites de la zona actual del nodo A). Usando este algoritmo, entonces, cada nodo puede decidir de forma independiente y asíncrona su propia zona tentativa basada en la ubicación de sus vecinos. La Figura 2 ilustra los resultados de aplicar este algoritmo a la red de la Figura 1. La Figura 3 describe el árbol de zonas correspondiente. Cada zona reside en un nodo hoja y el código de una zona es el camino desde la raíz hasta la zona si representamos la rama a la izquierda 66 Construir-Zona(a) 1 mientras Contiene(ZA, a) 2 hacer si longitud(código(ZA)) mod 2 = 0 3 entonces nuevo límite ← (límite[0] + límite[1])/2 4 si A.x < nuevo límite 5 entonces límite[1] ← nuevo límite 6 de lo contrario límite[0] ← nuevo límite 7 de lo contrario nuevo límite ← (límite[2] + límite[3])/2 8 si A.y < nuevo límite 9 entonces límite[3] ← nuevo límite 10 de lo contrario límite[2] ← nuevo límite 11 Actualizar código de zona código(ZA) Figura 4: Determinación de los Límites de la Zona, donde A.x y A.y representan las coordenadas geográficas del nodo A. Insertar-Evento(e) 1 c ← Codificar(e) 2 si Contiene(ZA, c) = verdadero y es Interno() = verdadero 3 entonces Almacenar e y salir 4 Enviar-Mensaje(c, e) Enviar-Mensaje(c, m) 1 si ∃ vecino Y, Más-Cercano(Y, propietario(m), m) = verdadero 2 entonces dir(m) ← dir(Y) 3 de lo contrario si longitud(c) > longitud(código(m)) 4 entonces Actualizar código(m) y dir(m) 5 fuente(m) ← llamante 6 si es Propietario(msg) = verdadero 7 entonces propietario(m) ← código del llamante 8 Enviar(m) Figura 5: Inserción de un evento en un DIM. El procedimiento Closer(A, B, m) devuelve verdadero si el código(A) está más cerca del código(m) que el código(B). source(m) se utiliza para establecer la dirección de origen del mensaje m. El hijo por 0 y la rama hacia el hijo derecho por 1. Este árbol binario forma el índice que utilizaremos en los siguientes procedimientos de procesamiento de eventos y consultas. Vemos que los tamaños de las zonas son diferentes y dependen de las densidades locales, al igual que las longitudes de los códigos de zona para diferentes nodos. Observa que en la Figura 2, hay una zona vacía cuyo código debería ser 110. En este caso, si el nodo en la zona 1111 solo puede escuchar al nodo en la zona 1110, establece su límite con la zona vacía como indefinido, porque no recibió señales de ningún nodo vecino en esa dirección. Como hemos mencionado anteriormente, los límites indefinidos se resuelven utilizando el modo de perímetro de los GPSRs cuando se inserta un evento o se envía una consulta. Describimos la inserción de eventos en el siguiente paso. Finalmente, esta descripción no explica cómo se ajustan los códigos de zona de los nodos cuando los nodos vecinos fallan o se añaden nuevos nodos. Regresamos a esto en la Sección 3.5. 3.3 Inserción de un Evento En esta sección, describimos cómo se insertan los eventos en un DIM. Hay dos algoritmos de interés: una técnica de hashing consistente para mapear un evento a una zona, y un algoritmo de enrutamiento para almacenar el evento en la zona apropiada. Como veremos, estos dos algoritmos están interrelacionados. 3.3.1 Hashing de un Evento a una Zona En la Sección 3.1, describimos una teselación recursiva de la extensión geográfica de un campo de sensores. Ahora describimos un esquema de hashing consistente para un DIM que admite consultas de rango en m atributos distintos. Denotemos estos atributos como A1... Lo siento, pero necesito una oración completa para poder traducirla. ¿Puedes proporcionar más contexto o una oración completa en inglés para que pueda traducirla al español? Para simplificar, asumamos por ahora que la profundidad de cada zona en la red es k, donde k es un múltiplo de m, y que este valor de k es conocido por cada nodo. Relajaremos esta suposición pronto. Además, para facilitar la discusión, asumimos que todos los valores de atributos han sido normalizados para estar entre 0 y 1. Nuestro esquema de hash asigna un código de zona de k bits a un evento de la siguiente manera. Para i entre 1 y m, si Ai < 0.5, se asigna un 0 al i-ésimo bit del código de zona, de lo contrario, se asigna un 1. Para i entre m + 1 y 2m, si Ai−m < 0.25 o Ai−m ∈ [0.5, 0.75), el i-ésimo bit de la zona se asigna como 0, de lo contrario, como 1, ya que las divisiones del siguiente nivel están en 0.25 y 0.75, las cuales dividen los rangos en [0, 0.25), [0.25, 0.5), [0.5, 0.75) y [0.75, 1). Repetimos este procedimiento hasta que se hayan asignado todos los k bits. Como ejemplo, considera el evento E = 0.3, 0.8. Para este evento, el código de zona de 5 bits es código(ZA) = 01110. Esencialmente, nuestro esquema de hash utiliza los valores de los atributos en forma de round-robin en el árbol de zonas (como el que se muestra en la Figura 3), con el fin de mapear un evento de m atributos a un código de zona. Esto recuerda a los árboles k-d [2], pero es bastante diferente de esa estructura de datos: los árboles de zona son incrustaciones espaciales y no incorporan los algoritmos de reequilibrio de los árboles k-d. En nuestro diseño de DIMs, no requerimos que los nodos tengan códigos de zona de la misma longitud, ni esperamos que un nodo conozca los códigos de zona de otros nodos. Más bien, supongamos que el nodo de codificación es A y su propio código de zona tiene una longitud de kA. Entonces, dado un evento E, el nodo A solo hashea E a un código de zona de longitud kA. Denotamos el código de zona asignado a un evento E como code(E). Como describimos a continuación, a medida que el evento se enruta, el código (E) se va refinando por nodos intermedios. Esta evaluación perezosa de códigos de zona permite que diferentes nodos utilicen códigos de zona de diferentes longitudes sin necesidad de coordinación explícita. 3.3.2 Enrutamiento de un Evento a su Propietario El objetivo de hashear un evento a un código de zona es almacenar el evento en el nodo dentro del nodo de red que posee esa zona. Llamamos a este nodo el propietario del evento. Consideremos un evento E que acaba de ser generado en un nodo A. Después de codificar el evento E, el nodo A compara el código(E) con el código(A). Si los dos son idénticos, el nodo A almacenará el evento E localmente; de lo contrario, el nodo A intentará enviar el evento a su propietario. Para hacer esto, tenga en cuenta que el código (E) corresponde a alguna zona Z, que es la suposición actual para la zona en la que el evento E debería ser almacenado. Ahora invoca GPSR para enviar un mensaje a addr(Z) (el centroide de Z, Sección 3.1). El mensaje contiene el evento E, el código(E), y la ubicación geográfica objetivo para almacenar el evento. En el mensaje, A también se marca a sí mismo como el propietario del evento E. Como veremos más adelante, la zona Z adivinada, la dirección addr(Z), y el propietario de E, todos ellos contenidos en el mensaje, serán refinados por nodos de reenvío intermedios. GPSR ahora envía este mensaje al siguiente salto hacia la dirección (Z) desde A. Este nodo de salto siguiente (llamémoslo B) no reenvía inmediatamente el mensaje. Por el contrario, intenta com2 DIM no asume que todos los nodos son homogéneos en cuanto a los sensores que poseen. Por lo tanto, en una DIM de m dimensiones, un nodo que no posea todos los m sensores puede utilizar valores NULL para las lecturas correspondientes. DIM trata a NULL como un valor extremo para comparaciones de rango. Por cierto, una red puede tener muchas instancias de DIM ejecutándose simultáneamente. 67 calcule un nuevo código de zona para E para obtener un nuevo código codenew(E). B actualizará el código contenido en el mensaje (y también el destino geográfico del mensaje) si el codenew(E) es más largo que el código del evento en el mensaje. De esta manera, a medida que el evento avanza hacia su propietario, su código de zona se va refinando. Ahora, B compara su propio código code(B) con el código del propietario owner(E) contenido en el mensaje entrante. Si el código (B) tiene una coincidencia más larga con el código (E) que el propietario actual de E, entonces B se establece a sí mismo como el propietario actual de E, lo que significa que si nadie es elegible para almacenar E, entonces B almacenará el evento (veremos cómo sucede esto a continuación). Si el código de zona de B no coincide exactamente con el código (E), B invocará GPSR para entregar E al siguiente salto. 3.3.3 Resolución de límites de zona no decididos durante la inserción. Supongamos que algún nodo, digamos C, se encuentra a sí mismo como destino (o propietario eventual) de un evento E. Lo hace al notar que el código de C es igual al código de E después de recalcular localmente un código para E. En ese caso, C almacena E localmente, pero solo si los cuatro límites de la zona de C están decididos. Cuando se cumple esta condición, C sabe con certeza que ningún otro nodo tiene zonas superpuestas con él. En este caso, llamamos a C un nodo interno. Recuerde, sin embargo, que debido a que el algoritmo de descubrimiento de zona de la Sección 3.2 solo utiliza información de vecinos inmediatos, uno o más de los límites de C pueden estar indefinidos. Si es así, C asume que algunos otros nodos tienen una zona que se superpone con la suya, y se dispone a resolver esta superposición. Para hacer esto, C ahora se establece como el propietario de E y continúa reenviando el mensaje. Aquí confiamos en el enrutamiento de modo de perímetro de los GPSRs para explorar alrededor del vacío que causa el límite no decidido. Dado que el mensaje parte desde C y está destinado a una ubicación geográfica cercana a C, GPSR garantiza que el mensaje será entregado de vuelta a C si ningún otro nodo actualiza la información en el mensaje. Si el mensaje regresa a C consigo mismo para ser el propietario, C infiere que debe ser el verdadero propietario de la zona y almacena E localmente. Si esto no sucede, hay dos posibilidades. El primero es que a medida que el evento atraviesa el perímetro, algún nodo intermedio, digamos B, cuya zona se superpone con la de C, se marca a sí mismo como el propietario del evento, pero de lo contrario no cambia el código de zona del evento. Este nodo también reconoce que su propia zona se superpone con Cs e inicia un intercambio de mensajes que hace que cada uno de ellos reduzca adecuadamente su zona. Las figuras 6 a 8 muestran un ejemplo de esta reducción de zona basada en datos. Inicialmente, tanto el nodo A como el nodo B han reclamado la misma zona 0 porque están fuera del alcance de radio entre sí. Supongamos que A inserta un evento E = 0.4, 0.8, 0.9. A codifica E como 0 y se autoproclama dueño de E. Dado que A no es un nodo interno, envía E en busca de otros posibles propietarios de E. Una vez que E llega al nodo B, B verá en los mensajes el campo de propietario con el código de A que es el mismo que el suyo propio. B luego reduce su zona de 0 a 01 de acuerdo a la ubicación de A que también está registrada en el mensaje y envía una solicitud de reducción a A. Al recibir esta solicitud, A también reduce su zona de 0 a 00. Una segunda posibilidad es si algún nodo intermedio cambia el código de destino de E a un valor más específico (es decir, un código de zona más largo). Etiquetemos este nodo como D. D ahora intenta iniciar la entrega en el centroide de la nueva zona. Esta Figura 6: Los nodos A y B han reclamado la misma zona. La figura 7: Un mensaje de evento/consulta (flechas llenas) desencadena la contracción de la zona (flechas huecas) cuando A B <0.4,0.8,0.9>. Figura 8: El diseño de la zona después de la contracción. Ahora los nodos A y B han sido asignados a diferentes zonas. Esto podría resultar en un nuevo recorrido de perímetro que regrese a D (si, por ejemplo, D resulta ser geográficamente el más cercano al centroide de la zona). Sin embargo, D no sería el propietario del evento, que seguiría siendo C. Al dirigirse hacia el centroide de esta zona, el mensaje puede atravesar el perímetro y regresar a D. Ahora D se da cuenta de que C era el propietario original, por lo que encapsula el evento y lo dirige a C. En caso de que efectivamente haya otro nodo, digamos X, que sea propietario de una zona superpuesta con C, X notará este hecho al encontrar en el mensaje el mismo prefijo del código de una de sus zonas, pero con una ubicación geográfica diferente a la suya. X reducirá su zona para resolver la superposición. Si la zona de X es menor o igual que la zona de C, X también enviará una solicitud de reducción a C. Una vez que C reciba la solicitud de reducción, reducirá su zona adecuadamente y fijará su límite no decidido. De esta manera, el proceso de formación de zonas se resuelve a pedido de manera basada en datos. Hay varios efectos interesantes con respecto al caminar por el perímetro que surgen en nuestro algoritmo. La primera es que hay algunos casos en los que la inserción de un evento podría hacer que se recorra todo el perímetro exterior de la red. La Figura 6 también funciona como un ejemplo donde se recorre el perímetro exterior. El evento E insertado por A eventualmente será almacenado en el nodo B. Antes de que el nodo B almacene el evento E, si el rango de radio nominal de B no se superpone con el límite de la red, necesita enviar E nuevamente como lo hizo A, porque en este caso B no es un nodo interno. Pero si el rango nominal de radio de Bs intersecta el límite de la red, entonces tiene dos opciones. Se puede asumir que no habrá nodos fuera del límite de la red y por lo tanto B es un nodo interno. Esta es un enfoque agresivo. Por otro lado, B también puede tomar una decisión conservadora asumiendo que podría haber otros nodos de los que aún no ha escuchado. B luego forzará el mensaje caminando otro perímetro antes de almacenarlo. En algunas situaciones, especialmente para zonas grandes donde el nodo que posee una zona está lejos del centroide de la zona poseída, podría existir un pequeño perímetro alrededor del destino que no incluye al propietario de la zona. El evento terminará siendo almacenado en un nodo diferente al del propietario real. Para hacer frente a este problema, agregamos una operación adicional en el reenvío de eventos, llamada descubrimiento eficiente de vecinos. Antes de invocar GPSR, un nodo necesita verificar si existe un vecino que sea elegible para ser el verdadero propietario del evento. Para hacer esto, un nodo C, por ejemplo, necesita conocer los códigos de zona de sus nodos vecinos. Desplegamos el mensaje de balizamiento GPSRs para transportar los códigos de zona de los nodos. Por lo tanto, simplemente comparando el código de eventos y el código de vecinos, un nodo puede decidir si existe un vecino Y que es más probable que sea el propietario del evento E. C entrega E a Y, que simplemente sigue el procedimiento de toma de decisiones discutido anteriormente. 3.3.4 Resumen y Pseudo-código En resumen, nuestro procedimiento de inserción de eventos está diseñado para interactuar de manera efectiva con el mecanismo de descubrimiento de zona y el mecanismo de hash de eventos. Los dos últimos mecanismos se mantienen simples, mientras que el mecanismo de inserción de eventos utiliza evaluación perezosa en cada salto para refinar el código de zona de eventos, y aprovecha el mecanismo de caminata perimetral de GPSRs para fijar los límites de zona no decididos. En la Sección 3.5, abordamos la robustez de la inserción de eventos ante la pérdida de paquetes o fallos de nodos. La Figura 5 muestra el pseudo-código para insertar y reenviar un evento e. En este pseudo-código, hemos omitido una descripción del procedimiento de reducción de zona. En el seudocódigo, el procedimiento Internal() se utiliza para determinar si el llamante es un nodo interno y el procedimiento Owner() se utiliza para determinar si el llamante es más elegible para ser el propietario del evento que el propietario actualmente reclamado según lo registrado en el mensaje. El procedimiento Send-Message se utiliza para enviar un mensaje de evento o un mensaje de consulta. Si la dirección de destino del mensaje ha sido cambiada, la dirección de origen del paquete también necesita ser cambiada para evitar ser descartado por GPSR, ya que GPSR no permite que un nodo vea el mismo paquete en modo codicioso dos veces. Esto ocurre con menos frecuencia que en los GHT, donde insertar un evento en una ubicación fuera del límite real (pero dentro del nominal) de la red siempre invocará una caminata de perímetro externa. Resolución y enrutamiento de consultas: Los DIMs admiten tanto consultas puntuales como consultas de rango. Enrutar una consulta de punto es idéntico a enrutar un evento. Por lo tanto, el resto de esta sección detalla cómo se enrutan las consultas de rango. El principal desafío en el enrutamiento de consultas de zona se pone de manifiesto mediante el siguiente diseño de hombre de paja. Si toda la red se dividiera de manera uniforme en zonas de profundidad k (para algún valor constante k predefinido), entonces el interrogador (el nodo que emite la consulta) podría subdividir una consulta de rango dada en las subzonas relevantes y dirigir solicitudes individuales a cada una de las zonas. Esto puede ser ineficiente para consultas de gran rango y también difícil de implementar en nuestro diseño donde los tamaños de zona no están predefinidos. En consecuencia, utilizamos una técnica ligeramente diferente donde una consulta de rango se dirige inicialmente a una zona correspondiente a todo el rango, y luego se divide progresivamente en subconsultas más pequeñas. Describimos este algoritmo aquí. El primer paso del algoritmo es mapear una consulta de rango a un prefijo de código de zona. Conceptualmente, esto es fácil; en un árbol de zonas (Figura 3), existe algún nodo que contiene la consulta de rango completa en su subárbol, y ninguno de sus hijos en el árbol lo hace. El código de zona inicial que elegimos para la consulta es el código de zona correspondiente a ese nodo del árbol, y es un prefijo de los códigos de zona de todas las zonas (ten en cuenta que estas zonas pueden no ser contiguas geográficamente) en el subárbol. El interrogador calcula el código de zona de Q, denotado por code(Q) y luego comienza a enrutar una consulta a addr(code(Q)). Al recibir una consulta de rango Q, un nodo A (donde A es cualquier nodo en la ruta de propagación de la consulta) la divide en múltiples subconsultas de tamaño más pequeño si hay una superposición entre la zona de A, zona(A) y el código de zona asociado con Q, código(Q). Nuestro enfoque para dividir una consulta Q en subconsultas es el siguiente. Si el rango del primer atributo de Q contiene el valor 0.5, A divide Q en dos subconsultas, una de las cuales tiene su primer atributo en el rango de 0 a 0.5, y la otra de 0.5 a 1. Entonces A decide la mitad que se superpone con su propia zona. Llamémoslo QA. Si QA no existe, entonces A deja de dividirse; de lo contrario, continúa dividiéndose (utilizando el rango del segundo atributo) y recalculando QA hasta que sea lo suficientemente pequeño como para caer completamente en la zona(A) y, por lo tanto, A pueda resolverlo ahora. Por ejemplo, supongamos que el nodo A, cuyo código es 0110, debe dividir una consulta de rango Q = 0.3 − 0.8, 0.6 − 0.9. Los pasos de división se muestran en la Figura 2. Después de dividir, obtenemos tres consultas más pequeñas q0 = 0.3 − 0.5, 0.6 − 0.75, q1 = 0.3 − 0.5, 0.75 − 0.9 y q2 = 0.5 − 0.8, 0.6 − 0.9. Este procedimiento de división se ilustra en la Figura 9, la cual también muestra los códigos de cada subconsulta después de la división. A continuación responde a la subconsulta q0 con los datos almacenados localmente y envía las subconsultas q1 y q2 utilizando el procedimiento descrito anteriormente. Más generalmente, si el nodo A se encuentra dentro del subárbol de zona que cubre de manera óptima Q, enviará las subconsultas que resultaron de la división. De lo contrario, si no hay superposición entre A y Q, entonces A reenvía Q tal cual (en este caso, Q es ya sea la consulta original o un producto de una división anterior). La Figura 10 describe el pseudo-código para el algoritmo de división de zonas. Como se muestra en el algoritmo anterior, una vez que se reconoce que una subconsulta pertenece a la zona de los llamantes, se invoca el procedimiento Resolve para resolver la subconsulta y enviar una respuesta al consultante. Cada mensaje de consulta contiene 4 consultas de punto Por consultas de punto nos referimos a la condición de igualdad en todas las claves indexadas. Los atributos del índice DIM no son necesariamente claves primarias. 69 la ubicación geográfica de su iniciador, para que el mensaje de respuesta correspondiente pueda ser entregado directamente de vuelta al iniciador. Finalmente, en el proceso de resolución de consultas, las zonas podrían reducirse de manera similar a la contracción durante la inserción. Hasta ahora, no hemos discutido el impacto de las fallas de nodos y pérdida de paquetes, o la llegada y salida de nodos en nuestros algoritmos. Las pérdidas de paquetes pueden afectar la inserción de consultas y eventos, y las fallas de nodos pueden resultar en la pérdida de datos, mientras que las llegadas y salidas de nodos pueden afectar la estructura de la zona. Ahora discutimos cómo los DIMs pueden hacerse robustos frente a este tipo de dinámicas. 3.5.1 Mantenimiento de Zonas En secciones anteriores, describimos cómo el algoritmo de descubrimiento de zonas podría dejar indefinidos los límites de las zonas. Estos límites no definidos se resuelven durante la inserción o consulta, utilizando el procedimiento de reducción de zona descrito anteriormente. Cuando un nuevo nodo se une a la red, el mecanismo de descubrimiento de zonas (Sección 3.2) hará que las zonas vecinas ajusten adecuadamente sus límites de zona. En este momento, esas zonas también pueden transferir al nuevo nodo aquellos eventos que almacenan pero que deberían pertenecer al nuevo nodo. Antes de que un nodo se apague (si es que esto es posible), sabe que su nodo de respaldo (Sección 3.1) tomará el control de su zona y simplemente enviará todos sus eventos a su nodo de respaldo. La eliminación de un nodo también puede causar la expansión de la zona. Para mantener la correspondencia entre los nodos hoja de los árboles de zona binaria y las zonas, permitimos que la expansión de la zona solo ocurra entre zonas hermanas (Sección 3.1). La regla es: si la zona hermana de la zona A se queda vacía, entonces A puede expandir su propia zona para incluir la zona hermana. Ahora dirigimos nuestra atención a las fallas de nodos. Las fallas de un nodo son similares a las eliminaciones de un nodo, excepto que un nodo fallido no tiene la oportunidad de mover sus eventos a otro nodo. Pero, ¿cómo decide un nodo si su hermano ha fallado? Si el hermano está dentro del alcance de la radio, la ausencia de mensajes de balizamiento GPSR puede detectarlo. Una vez que lo detecta, el nodo puede expandir su zona. Se necesita un enfoque diferente para detectar hermanos que no están dentro del alcance de la radio. Estos son los casos en los que dos nodos poseen sus zonas después de intercambiar un mensaje de reducción; no intercambian mensajes periódicamente después para mantener esta relación de zona. En este caso, detectamos la falla de manera basada en datos, con beneficios de eficiencia obvios en comparación con los mantenimientos periódicos. Una vez que un nodo B ha fallado, un evento o mensaje de consulta que anteriormente debería haber sido gestionado por el nodo fallido ahora será entregado al nodo A que posee la zona vacía dejada por el nodo B. A puede ver este mensaje porque A se encuentra justo alrededor del área vacía dejada por B y está garantizado que será visitada en un recorrido de perímetro de GPSR. Un nodo se establecerá como propietario del mensaje, y cualquier nodo que hubiera descartado este mensaje debido a un bucle de perímetro redirigirá el mensaje a A en su lugar. Si la zona de A resulta ser el hermano de la zona de B, A puede expandir de forma segura su propia zona y notificar su zona expandida a sus vecinos a través de mensajes de balizamiento GPSR. 3.5.2 Prevención de la pérdida de datos por fallo de nodo. Los algoritmos descritos anteriormente son robustos en términos de formación de zona, pero el fallo de un nodo puede borrar datos. Para evitar esto, los DIMs pueden emplear dos tipos de replicación: replicación local para ser resilientes a fallos aleatorios de nodos, y replicación en espejo para la resiliencia ante la falla concurrente de nodos geográficamente contiguos. La replicación de espejos es conceptualmente fácil. Supongamos que un evento E tiene un código de zona code(E). Entonces, el nodo que inserta E almacenaría dos copias de E; una en la zona indicada por el código de E, y la otra en la zona correspondiente al complemento de unos del código de E. Esta técnica crea esencialmente un DIM espejo. Un consultante necesitaría, en paralelo, consultar tanto el DIM original como su espejo, ya que no hay forma de saber si una colección de nodos ha fallado. Claramente, el compromiso aquí es un aumento aproximado del doble tanto en los costos de inserción como en los de consulta. Existe una técnica mucho más económica para garantizar la resistencia a fallos aleatorios de nodos. Nuestra técnica local de replicación se basa en la observación de que, para cada nodo A, existe un nodo único que se hará cargo de su zona cuando A falle. Este nodo se define como el nodo responsable de la zona de respaldo de las zonas de As (ver Sección 3.1). La idea básica es que A replica cada elemento de datos que tiene en este nodo. Llamamos a este nodo como réplica local. Que la réplica local de A sea B. A menudo B será un vecino de radio de A y puede ser detectado a través de balizas GPSR. A veces, sin embargo, este no es el caso y será necesario descubrir explícitamente B. Utilizamos un mensaje explícito para descubrir la réplica local. Descubrir la réplica local es impulsado por datos y utiliza un mecanismo similar al de la inserción de eventos. El nodo A envía un mensaje cuyo destino geográfico es una ubicación cercana aleatoria elegida por A. La ubicación está lo suficientemente cerca de A como para que GPSR garantice que el mensaje será entregado de vuelta a A. Además, el mensaje tiene tres campos, uno para el código de zona de A, código(A), uno para el propietario owner(A) de la zona(A) que se establece como vacío, y uno para la ubicación geográfica del propietario(A). Entonces el paquete será entregado en modo de perímetro GPSR. Cada nodo que reciba este mensaje comparará su código de zona y el código (A) en el mensaje, y si es más elegible para ser el propietario de la zona (A) que el propietario actual (A) registrado en el mensaje, actualizará el campo propietario (A) y la ubicación geográfica correspondiente. Una vez que el paquete regrese a A, conocerá la ubicación de su réplica local y podrá comenzar a enviar réplicas. En una red de sensores densa, la réplica local de un nodo suele estar muy cerca del nodo, ya sea su vecino directo o a 1-2 saltos de distancia, por lo que el costo de enviar réplicas a la replicación local no dominará el tráfico de la red. Sin embargo, la réplica local de un nodo en sí misma puede fallar. Hay dos formas de abordar esta situación: actualizaciones periódicas o descubrimiento repetido de réplicas locales basado en datos. El primero tiene costos operativos más altos, pero descubre más rápidamente las réplicas fallidas. 3.5.3 Robustez ante la pérdida de paquetes. Por último, los mecanismos de consulta e inserción de eventos pueden hacerse fácilmente resistentes a la pérdida de paquetes. Para la inserción de eventos, un esquema de ACK simple es suficiente. Por supuesto, las consultas y respuestas también pueden perderse. En este caso, existe un enfoque eficiente para la recuperación de errores. Esto se basa en la observación de que el solicitante sabe qué zonas caen dentro de su consulta y debería haber respondido (asumimos que un nodo que no tiene datos que coincidan con una consulta, pero cuya zona cae dentro de la consulta, responde con un acuse de recibo negativo). Después de un tiempo de espera conservador, el interrogador puede volver a emitir las consultas selectivamente a estas zonas. Si DIM no puede obtener respuestas (positivas o negativas) de 70 <0.3-0.8, 0.6-0.9> <0.5-0.8, 0.6-0.9><0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.9> <0.3-0.5, 0.6-0.75> <0.3-0.5, 0.75-0.9> 0 0 1 1 1 1 Figura 9: Un ejemplo de división de consulta de rango Resolver-Consulta-de-Rango(Q) 1 Qsub ← nil 2 q0, Qsub ← Dividir-Consulta(Q) 3 si q0 = nil 4 entonces c ← Codificar(Q) 5 si Contiene(c, código(A)) = true 6 entonces ir al paso 12 7 else Enviar-Mensaje(c, q0) 8 else Resolver(q0) 9 si es Interno() = true 10 entonces Absorber (q0) 11 else Adjuntar q0 a Qsub 12 si Qsub = nil 13 entonces para cada subconsulta q ∈ Qsub 14 hacer c ← Codificar(q) 15 Enviar-Mensaje(c, q) Figura 10: Algoritmo de resolución de consultas en ciertas zonas después de tiempos de espera repetidos, al menos puede devolver los resultados parciales de la consulta a la aplicación junto con la información sobre las zonas de las que faltan datos. 4. En esta sección, presentamos un análisis simple del rendimiento analítico de DIMs y comparamos su rendimiento con otros enfoques posibles para implementar consultas de rango multidimensionales en redes de sensores. En la siguiente sección, validamos estos análisis utilizando simulaciones detalladas a nivel de paquete. Nuestras métricas principales para el rendimiento de un DIM son: el Costo Promedio de Inserción mide el número promedio de mensajes necesarios para insertar un evento en la red. El Costo Promedio de Entrega de Consultas mide el número promedio de mensajes necesarios para dirigir un mensaje de consulta a todos los nodos relevantes en la red. No mide la cantidad de mensajes necesarios para transmitir respuestas al interrogador; este último número depende de la distribución precisa de los datos y es el mismo para muchos de los esquemas con los que comparamos los DIMs. En las DIMs, la inserción de eventos utiliza principalmente enrutamiento geográfico. En una red de N nodos densa donde la probabilidad de atravesar los perímetros es pequeña, el costo promedio de inserción de eventos es proporcional a √ N [23]. Por otro lado, el costo de entrega de la consulta depende del tamaño de los rangos especificados en la consulta. Recuerde que nuestro mecanismo de entrega de consultas es cuidadoso al dividir una consulta en subconsultas, haciéndolo solo cuando la consulta se acerca a la zona que cubre el rango de la consulta. Por lo tanto, cuando el solicitante está lejos de la zona consultada, hay dos componentes en el costo de entrega de la consulta. El primero, que es proporcional a √ N, es el costo de entregar la consulta cerca de la zona de cobertura. Si dentro de esta zona de cobertura hay M nodos, el costo de entrega del mensaje al dividir la consulta es proporcional a M. El costo promedio de entrega de la consulta depende de la distribución de los tamaños de rango de la consulta. Ahora, supongamos que los tamaños de las consultas siguen alguna función de densidad f(x), entonces el costo promedio de resolver una consulta puede aproximarse por Ê N 1 xf(x)dx. Para dar una intuición sobre el rendimiento de las DIMs, consideramos cuatro formas diferentes para f(x): la distribución uniforme donde un rango de consulta que abarca toda la red es tan probable como una consulta de punto; una distribución uniforme acotada donde todos los tamaños hasta un límite B son igualmente probables; una distribución algebraica en la que la mayoría de las consultas son pequeñas, pero las grandes consultas son algo probables; y una distribución exponencial donde la mayoría de las consultas son pequeñas y las grandes consultas son improbables. En todos nuestros análisis, hacemos la suposición simplificadora de que el tamaño de una consulta es proporcional al número de nodos que pueden responder a esa consulta. Para la distribución uniforme P(x) ∝ c para alguna constante c. Si cada tamaño de consulta es de 1... Si N es igualmente probable, el costo promedio de entrega de consultas uniformemente distribuidas es O(N). Por lo tanto, para consultas distribuidas uniformemente, el rendimiento de los DIMs es comparable al de la inundación. Sin embargo, para las aplicaciones que imaginamos, donde los nodos dentro de la red intentan correlacionar eventos, la distribución uniforme es altamente irrealista. Una situación algo más realista es aquella en la que todos los tamaños de consulta están limitados por una constante B. En este caso, el costo promedio para resolver una consulta de este tipo es aproximadamente Ê B 1 xf(x)dx = O(B). Recuerda ahora que todas las consultas deben pagar un costo aproximado de O( √ N) para llevar la consulta cerca de la zona de cobertura. Por lo tanto, si DIM limitara las consultas a un tamaño proporcional a √ N, el costo promedio de la consulta sería O( √ N). La distribución algebraica, donde f(x) ∝ x−k, para alguna constante k entre 1 y 2, tiene un costo promedio de resolución de consulta dado por Ê N 1 xf(x)dx = O(N2−k). En este caso, si k > 1.5, el costo promedio de entrega de la consulta está dominado por el costo de entregar la consulta cerca de la zona de cobertura, dado por O( √ N). Finalmente, para la distribución exponencial, f(x) = ce−cx para alguna constante c, y el costo promedio es simplemente la media de la distribución correspondiente, es decir, O(1) para N grande. Asintóticamente, entonces, el costo de la consulta para la distribución exponencial está dominado por el costo de entregar la consulta cerca de la zona de cobertura (O( √ N)). Por lo tanto, vemos que si las consultas siguen ya sea la distribución uniforme acotada, la distribución algebraica o la distribución exponencial, el costo de la consulta escala como el costo de inserción (para una elección adecuada de constantes para las distribuciones uniforme acotada y algebraica). ¿Qué tan bien se compara el rendimiento de las DIMs con las opciones alternativas para implementar consultas multidimensionales? Una alternativa simple se llama almacenamiento externo [23], donde todos los eventos se almacenan de forma centralizada en un nodo fuera de la red de sensores. Este esquema incurre en un costo de inserción de O( √ N) y un costo de consulta de cero. Sin embargo, como señala [23], dichos sistemas pueden resultar poco prácticos en redes de sensores, ya que el enlace de acceso al nodo externo se convierte en un punto crítico. Una segunda implementación alternativa almacenaría los eventos en el nodo donde son generados. Las consultas se inundan en toda la red, y los nodos que tienen datos coincidentes responden. Ejemplos de sistemas que se pueden utilizar para esto (aunque, según nuestro conocimiento, estos sistemas no implementan consultas de rango multidimensionales) son Directed Diffusion [15] y TinyDB [17]. El esquema de inundación incurre en un costo de inserción cero, pero en un costo de consulta O(N). Es fácil demostrar que las DIM superan al flooding siempre y cuando la proporción entre el número de inserciones y el número de consultas sea menor que √ N. Una alternativa final sería utilizar una tabla hash geográfica (GHT [20]). En este enfoque, se asume que los valores de los atributos son enteros (lo cual es en realidad una suposición bastante razonable ya que los valores de los atributos suelen estar cuantificados), y los eventos se hashean en algún atributo (digamos, el primero). Una consulta de rango se divide en varias subconsultas, una para cada entero en el rango del primer atributo. Cada subconsulta se hashea luego a la ubicación apropiada. Los nodos que reciben una subconsulta solo devuelven eventos que coincidan con todos los otros rangos de atributos. En este enfoque, al que llamamos GHT-R (GHTs para consultas de rango), el costo de inserción es O( √ N). Supongamos que el rango del primer atributo contiene r valores discretos. Entonces, el costo de entregar consultas es O(r √ N). Por lo tanto, asintóticamente, los GHT-Rs se desempeñan de manera similar a los DIMs. En la práctica, sin embargo, las constantes de proporcionalidad son significativamente diferentes, y los DIMs superan a los GHT-Rs, como demostraremos utilizando simulaciones detalladas. DIMS: RESULTADOS DE LA SIMULACIÓN Nuestro análisis nos brinda una idea sobre el comportamiento asintótico de varios enfoques para consultas de rango multidimensionales. En esta sección, utilizamos simulación para comparar DIMs con inundaciones y GHT-R; esta comparación nos brinda una comprensión más detallada de estos enfoques para redes de tamaño moderado, y nos ofrece una visión matizada de las diferencias mecanicistas entre algunos de estos enfoques. 5.1 Metodología de Simulación Utilizamos ns-2 para nuestras simulaciones. Dado que los DIMs se implementan sobre GPSR, primero portamos una implementación anterior de GPSR a la última versión de ns-2. Modificamos el módulo GPSR para llamar a nuestra implementación DIM cuando recibe cualquier mensaje de datos en tránsito o cuando está a punto de descartar un mensaje porque ha atravesado todo el perímetro. Esto permite a un DIM modificar códigos de zona de mensaje en vuelo (Sección 3) y determinar el propietario real de un evento o consulta. Además, implementamos en ns-2 la mayoría de los mecanismos DIM descritos en la Sección 3. De todos esos mecanismos, el único que no implementamos es la replicación de espejo. Hemos implementado la retransmisión selectiva de consultas para la resiliencia a la pérdida de paquetes, pero hemos dejado la evaluación de este mecanismo para trabajos futuros. Nuestra implementación de DIM en ns-2 consta de 2800 líneas de código. Finalmente, implementamos GHT-R, nuestro mecanismo de consulta de rango multidimensional basado en GHT en ns-2. Esta implementación fue relativamente sencilla, dado que habíamos adaptado GPSR y modificado GPSR para detectar la finalización de los recorridos en modo perímetro. Usando esta implementación, realizamos una evaluación bastante extensa de DIM y dos alternativas (inundación y nuestro GHT-R). Para todos nuestros experimentos, utilizamos nodos sensores colocados uniformemente con tamaños de red que van desde 50 nodos hasta 300 nodos. Cada nodo tiene un alcance de radio de 40m. Para los resultados presentados aquí, cada nodo tiene en promedio 20 nodos dentro de su rango de radio nominal. Hemos realizado experimentos en otras densidades de nodos; concuerdan con los resultados presentados aquí. En todos nuestros experimentos, cada nodo genera en promedio 3 eventos (más precisamente, para una topología de tamaño N, tenemos 3N eventos, y cada nodo tiene la misma probabilidad de generar un evento). Hemos realizado experimentos para tres distribuciones de valores de eventos diferentes. Nuestra distribución uniforme de eventos genera eventos bidimensionales y, para cada dimensión, cada valor de atributo tiene la misma probabilidad. Nuestra distribución de eventos normales genera eventos bidimensionales y, para cada dimensión, el valor del atributo se distribuye normalmente con una media correspondiente al punto medio del rango de valores del atributo. La distribución normal de eventos representa un conjunto de datos sesgado. Finalmente, nuestra distribución de eventos de trazas es una colección de eventos de 4 dimensiones obtenidos de una red de monitoreo de hábitats. Como veremos, esto representa un conjunto de datos bastante sesgado. Habiendo generado eventos, para cada simulación generamos consultas de manera que, en promedio, cada nodo genere 2 consultas. Los tamaños de las consultas se determinan utilizando las cuatro distribuciones de tamaño que discutimos en la Sección 4: uniforme, uniforme acotada, algebraica y exponencial. Una vez que se ha determinado el tamaño de la consulta, la ubicación de la consulta (es decir, los límites reales de la zona) se distribuyen de forma uniforme. Para nuestros experimentos GHT-R, el rango dinámico de los atributos tenía 100 valores discretos, pero restringimos el rango de consulta para cualquier atributo a 50 valores discretos para permitir que esas simulaciones se completaran en un tiempo razonable. Finalmente, utilizando un conjunto de simulaciones evaluamos la eficacia de la replicación local al apagar fracciones aleatorias de nodos y medir la fidelidad de los resultados obtenidos. Las métricas principales para nuestras simulaciones son los costos promedio de consulta e inserción, según se definen en la Sección 4. 5.2 Resultados. Aunque hemos examinado casi todas las combinaciones de factores descritas anteriormente, aquí discutimos solo las más relevantes, por falta de espacio. La Figura 11 muestra los costos promedio de inserción para DIM y GHT-R (para la inundación, por supuesto, los costos de inserción son cero). DIM incurre menos gastos generales por evento al insertar eventos (independientemente de la distribución real de eventos; la Figura 11 muestra el costo para eventos distribuidos uniformemente). La razón de esto es interesante. En GHT-R, almacenar casi cada evento implica un recorrido de perímetro, y almacenar algunos eventos requiere recorrer el perímetro exterior de la red [20]. Por el contrario, en DIM, almacenar un evento implica un recorrido de perímetro solo cuando los límites de un nodo están indefinidos. Además, una inserción o una consulta en un DIM puede recorrer el perímetro exterior (Sección 3.3), pero con menos frecuencia que en los GHT. La Figura 13 representa el costo promedio de consulta para una distribución de tamaño de consulta uniforme acotada. Para este gráfico (y el siguiente) utilizamos una distribución uniforme de eventos, ya que la distribución de eventos no afecta el costo de entrega de consultas. Para esta simulación, nuestro límite fue 1/4 del tamaño del mayor posible. Nuestras métricas están elegidas de manera que el número exacto de eventos y consultas no es importante para nuestra discusión. Por supuesto, el rendimiento general del sistema dependerá de la frecuencia relativa de eventos y consultas, como discutimos en la Sección 4. Dado que no tenemos ratios realistas para estos, nos enfocamos en los costos microscópicos en lugar de en los costos del sistema en general. Tamaño de la red DIM GHT-R Figura 11: Costo promedio de inserción para DIM y GHT. 0.4 0.5 0.6 0.7 0.8 0.9 1 5 10 15 20 25 30 Fracción de respuestas comparadas con el caso sin fallas Fracción de nodos fallidos (%) Sin Replicación Replicación Local Figura 12: Rendimiento de la replicación local. consulta (por ejemplo, una consulta de la forma 0 − 0.5, 0 − 0.5. Incluso para este tamaño de consulta generoso, las DIMs funcionan bastante bien (casi un tercio del costo de inundación). Sin embargo, hay que tener en cuenta que los GHTRs incurren en un alto costo de consulta, ya que casi cualquier consulta requiere tantas subconsultas como el ancho del rango de los primeros atributos. La Figura 14 traza el costo promedio de la consulta para la distribución exponencial (el tamaño promedio de la consulta para esta distribución se estableció en 1/16 del tamaño de consulta más grande posible). La superior escalabilidad de las DIMs es evidente en estos gráficos. Claramente, este es el régimen en el que se podría esperar que los DIMs funcionen mejor, cuando la mayoría de las consultas son pequeñas y las consultas grandes son relativamente raras. Este es también el régimen en el que se esperaría utilizar consultas de rango multidimensionales: para realizar correlaciones relativamente ajustadas. Al igual que con la distribución uniforme acotada, el costo de consulta de GHT está dominado por el costo de enviar subconsultas; para las DIMs, la estrategia de división de consultas funciona bastante bien para mantener bajos los costos generales de entrega de consultas. La Figura 12 describe la eficacia de la replicación local. Para obtener esta cifra, llevamos a cabo el siguiente experimento. En una red de 100 nodos, insertamos una serie de eventos distribuidos uniformemente en toda la red, luego emitimos una consulta que abarcaba toda la red y registramos las respuestas. Conociendo las respuestas esperadas para esta consulta, luego eliminamos sucesivamente una fracción f de nodos al azar y volvimos a emitir la misma consulta. La figura representa la fracción de respuestas esperadas realmente recibidas, con y sin replicación. Como muestra el gráfico, la replicación local funciona bien para fallos aleatorios, devolviendo casi el 90% de las respuestas cuando hasta el 30% de los nodos fallan simultáneamente. En ausencia de replicación local, por supuesto, cuando el 30% de los nodos fallan, la tasa de respuesta es solo del 70%, como cabría esperar. Observamos que los DIMs (tal como están diseñados actualmente) no son perfectos. Cuando los datos están altamente sesgados, como lo estaban en nuestro conjunto de datos de trazas del sistema de monitoreo de hábitats, donde la mayoría de los valores de eventos caían dentro del 10% del rango de atributos, algunos nodos DIM claramente se convertirán en el cuello de botella. Esto se muestra en la Figura 15, que indica que para DIMs y GHT-Rs, el número máximo de transmisiones en cualquier nodo de la red (los puntos calientes) es bastante alto. (Para distribuciones de datos menos sesgadas y distribuciones de tamaño de consulta razonables, las curvas de puntos calientes para los tres esquemas son comparables). Este es un problema estándar que los índices de la base de datos han resuelto mediante el reequilibrado de árboles. En nuestro caso, podrían ser posibles soluciones más simples (y discutimos esto en la Sección 7). Sin embargo, nuestro uso de los datos de traza demuestra que las DIMs funcionan para eventos que tienen más de dos dimensiones. Aumentar el número de dimensiones no degrada notablemente el costo de consulta de DIMs (omitido por falta de espacio). También se omiten experimentos que examinan el impacto de varios otros factores, ya que no afectan nuestras conclusiones de ninguna manera. Como esperábamos, los DIMs tienen un rendimiento comparable al inundar cuando todos los tamaños de consultas son igualmente probables. Para una distribución algebraica de tamaños de consulta, el rendimiento relativo es cercano al de la distribución exponencial. Para eventos distribuidos normalmente, los costos de inserción son mucho mejores que esto. Suponiendo que un nodo y su réplica no fallan simultáneamente con frecuencia, un nodo casi siempre detectará una falla en la réplica y la re-replicará, lo que lleva a tasas de respuesta cercanas al 100%. 73 0 2000 4000 6000 8000 10000 12000 50 100 150 200 250 300 Máximo punto caliente en el conjunto de datos de trazas Tamaño de red DIM inundación GHT-R Figura 15: Uso de puntos calientes DIM Gestor de zona Enrutador de consultas Procesador de consultas Gestor de eventos Enrutador de eventos Interfaz GPSR (basada en eventos/basada en hilos) actualización uso actualización Interfaz superior de GPSR (basada en eventos/basada en hilos) Interfaz inferior de GPSR (basada en eventos/basada en hilos) Reenvío codicioso Reenvío de perímetro Balizamiento Gestor de lista de vecinos actualización uso MoteNIC (MicaRadio) Socket IP (802.11b/Ethernet) Figura 16: Arquitectura de software de DIM sobre GPSR son comparables a las de la distribución uniforme. Finalmente, cabe destacar que en todas nuestras evaluaciones solo hemos utilizado consultas de lista (aquellas que solicitan todos los eventos que coinciden con el rango especificado). Esperamos que para consultas de resumen (aquellas que esperan un agregado sobre eventos coincidentes), el costo total de las DIMs podría ser menor porque es probable que los datos coincidentes se encuentren en una o un pequeño número de zonas. Dejamos la comprensión de esto para trabajos futuros. También queda pendiente para trabajos futuros una comprensión detallada del impacto del error de ubicación en los mecanismos de las DIMs. El trabajo reciente [22] ha examinado el impacto de la información de ubicación imprecisa en otros mecanismos de almacenamiento centrados en datos como GHTs, y encontró que existen soluciones relativamente simples para GPSR que mejoran los efectos del error de ubicación. 6. Hemos implementado DIMs en una plataforma Linux adecuada para experimentación en PDAs y máquinas de clase PC-104. Para implementar DIMs, tuvimos que desarrollar y probar una implementación independiente de GPSR. Nuestra implementación de GPSR es completa, mientras que nuestra implementación de DIM tiene la mayoría de los algoritmos discutidos en la Sección 3; algunas de las extensiones de robustez solo tienen variantes más simples implementadas. La arquitectura de software del sistema DIM/GPSR se muestra en la Figura 16. El sistema completo (alrededor de 5000 líneas de código) es impulsado por eventos y multihilo. El subsistema DIM consta de seis componentes lógicos: gestión de zonas, mantenimiento de eventos, enrutamiento de eventos, enrutamiento de consultas, procesamiento de consultas e interacciones con GPSR. El sistema GPSR se implementa como un proceso demonio a nivel de usuario. Las aplicaciones se ejecutan como clientes. Para el subsistema DIM, el módulo GPSR 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Promedio de respuestas recibidas por consulta Figura 17: Número de eventos recibidos para diferentes tamaños de consulta 0 2 4 6 8 10 12 14 16 0.25x0.25 0.50x0.50 0.75x0.75 1.0x1.0 Tamaño de consulta Número total de mensajes solo para enviar la consulta Figura 18: El costo de distribución de consultas proporciona varias extensiones: exporta información sobre vecinos y proporciona devoluciones de llamada durante el reenvío de paquetes y la terminación en modo perímetro. Probamos nuestra implementación en un banco de pruebas que consta de 8 máquinas de clase PC-104. Cada una de estas cajas ejecuta Linux y utiliza un mote Mica (conectado a través de un cable serie) para la comunicación. Estas cajas están dispuestas en un edificio de oficinas con una separación espacial total de más de cien pies. Medimos manualmente las ubicaciones de estos nodos en relación con algún sistema de coordenadas y configuramos los nodos con su ubicación. La topología de red es aproximadamente en forma de cadena. En este banco de pruebas, insertamos consultas y eventos desde un único nodo designado. Nuestros eventos tienen dos atributos que abarcan todas las combinaciones de los cuatro valores [0, 0.25, 0.75, 1] (dieciséis eventos en total). Nuestras consultas abarcan cuatro tamaños, devolviendo 1, 4, 9 y 16 eventos respectivamente. La Figura 17 representa el número de eventos recibidos para consultas de diferentes tamaños. Podría parecer que recibimos menos eventos de los esperados, pero este gráfico no cuenta los eventos que ya estaban almacenados en el consultante. Con ese ajuste, el número de respuestas coincide con nuestra expectativa. Finalmente, la Figura 18 muestra el número total de mensajes requeridos para diferentes tamaños de consulta en nuestro banco de pruebas. Si bien estos experimentos no revelan tanto sobre el rango de rendimiento de los DIMs como lo hacen nuestras simulaciones, sin embargo, sirven como prueba de concepto para los DIMs. Nuestro próximo paso en la implementación es trasladar los DIMs a los motes Mica e integrarlos en el motor de base de datos de sensores TinyDB [17] en los motes. 74 7. CONCLUSIONES En este artículo, hemos discutido el diseño y la evaluación de una estructura de datos distribuida llamada DIM para resolver eficientemente consultas de rango multidimensionales en redes de sensores. Nuestro diseño de DIMs se basa en un novedoso hash que preserva la localidad, inspirado en trabajos anteriores de indexación de bases de datos, y está construido sobre GPSR. Tenemos un prototipo funcional, tanto de GPSR como de DIM, y planeamos llevar a cabo experimentos a mayor escala en el futuro. Hay varias direcciones futuras interesantes que tenemos la intención de seguir. Una es la adaptación a distribuciones de datos sesgadas, ya que estas pueden causar puntos calientes en el almacenamiento y la transmisión. A diferencia de los índices de bases de datos tradicionales que reequilibran los árboles al insertar datos, en las redes de sensores podría ser factible reestructurar las zonas en una escala de tiempo mucho más grande después de obtener una estimación global aproximada de la distribución de los datos. Otra dirección es el soporte para la heterogeneidad de nodos en el proceso de construcción de zonas; los nodos con mayor espacio de almacenamiento reclaman zonas de mayor tamaño para sí mismos. Un tercio es el soporte para la resolución eficiente de consultas existenciales: si existe un evento que coincida con un rango multidimensional. Agradecimientos Este trabajo se benefició enormemente de las discusiones con Fang Bian, Hui Zhang y otros miembros del laboratorio ENL, así como de los comentarios proporcionados por los revisores y nuestro guía Feng Zhao. 8. REFERENCIAS [1] J. Aspnes y G. Shah. Gráficos de salto. En Actas del 14º Simposio Anual de Algoritmos Discretos ACM-SIAM (SODA), Baltimore, MD, enero de 2003. [2] J. L. Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicaciones de la ACM, 18(9):475-484, 1975. [3] P. Bonnet, J. E. Gerhke y P. Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, Hong Kong, enero de 2001. [4] I. Clarke, O. Sandberg, B. Wiley y T. W. Hong. Freenet: Un sistema distribuido de almacenamiento y recuperación de información anónimo. Diseñando Tecnologías de Mejora de la Privacidad: Taller Internacional sobre Problemas de Diseño en Anonimato e Inobservabilidad. Springer, Nueva York, 2001. [5] D. Comer. El árbol B ubicuo. ACM Computing Surveys, 11(2):121-137, 1979. [6] R. A. Finkel y J. L. Bentley. Árboles cuaternarios: Una estructura de datos para la recuperación en claves compuestas. Acta Informatica, 4:1-9, 1974. [7] D. Ganesan, D. Estrin y J. Heidemann. DIMENSIONES: ¿Por qué necesitamos una nueva arquitectura de manejo de datos para las redes de sensores? En Actas del Primer Taller sobre Temas Candentes en Redes (HotNets-I), Princeton, Nueva Jersey, octubre de 2002. [8] A. Gionis, P. Indyk y R. Motwani. Búsqueda de similitud en dimensiones altas a través de hash. En Actas de la 25ª conferencia VLDB, Edimburgo, Escocia, septiembre de 1999. [9] R. Govindan, J. Hellerstein, W. Hong, S. Madden, M. Franklin y S. Shenker. La red de sensores como una base de datos. Informe técnico 02-771, Departamento de Ciencias de la Computación, Universidad del Sur de California, septiembre de 2002. [10] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un Índice Distribuido para Características en Redes de Sensores. En Actas del 1er Taller Internacional de IEEE sobre Protocolos y Aplicaciones de Redes de Sensores, Anchorage, AK, mayo de 2003. [11] A. Guttman. R-trees: Una estructura de índice dinámica para búsquedas espaciales. En Actas de ACM SIGMOD, Boston, MA, junio de 1984. [12] M. Harren, J. M. Hellerstein, R. Huebsch, B. T. Loo, S. Shenker e I. Stoica. Consultas complejas en redes peer-to-peer basadas en DHT. En P. Druschel, F. Kaashoek y A. Rowstron, editores, Actas del 1er Taller Internacional sobre Sistemas Peer-to-Peer (IPTPS02), volumen 2429 de LNCS, página 242, Cambridge, MA, marzo de 2002. Springer-Verlag. [13] P. Indyk y R. Motwani. Vecinos más cercanos aproximados: Hacia la eliminación de la maldición de la dimensionalidad. En Actas del 30º Simposio Anual de la ACM sobre Teoría de la Computación, Dallas, Texas, mayo de 1998. [14] P. Indyk, R. Motwani, P. Raghavan y S. Vempala. Hashing preservador de la localidad en espacios multidimensionales. En Actas del 29º Simposio Anual de la ACM sobre Teoría de la Computación, páginas 618 - 625, El Paso, Texas, mayo de 1997. ACM Press. [15] C. Intanagonwiwat, R. Govindan, y D. Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [16] B. Karp y H. T. Kung. GPSR: Enrutamiento Perimetral Avaro sin Estado para Redes Inalámbricas. En Actas de la Sexta Conferencia Internacional Anual ACM/IEEE sobre Computación y Redes Móviles (Mobicom 2000), Boston, MA, agosto de 2000. [17] S. Madden, M. Franklin, J. Hellerstein y W. Hong. El diseño de un procesador de consultas adquisitivo para redes de sensores. En Actas de ACM SIGMOD, San Diego, CA, junio de 2003. [18] S. Madden, M. J. Franklin, J. M. Hellerstein y W. Hong. TAG: un Servicio de Agregación Pequeño para Redes de Sensores ad-hoc. En Actas del 5º Simposio Anual sobre Diseño e Implementación de Sistemas Operativos (OSDI), Boston, MA, diciembre de 2002. [19] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una Red Escalable de Dirección de Contenido. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [20] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT: Una Tabla de Hash Geográfica para Almacenamiento Centrado en Datos. En Actas del Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y Aplicaciones, Atlanta, GA, septiembre de 2002. [21] H. Samet. Estructuras de datos espaciales. En W. Kim, editor, Modern Database Systems: The Object Model, Interoperabilidad y Más Allá, páginas 361-385. Addison Wesley/ACM, 1995. [22] K. Sead, A. Helmy, y R. Govindan. Sobre el efecto de los errores de localización en el enrutamiento facial geográfico en redes de sensores. En \"Bajo revisión, 2003\". [23] S. Shenker, S. Ratnasamy, B. Karp, R. Govindan y D. Estrin. Almacenamiento centrado en datos en redes de sensores. En Proc. Taller ACM SIGCOMM sobre Temas Candentes en Redes, Princeton, NJ, 2002. [24] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek y H. Balakrishnan. Chord: Un servicio de búsqueda escalable de pares a pares para aplicaciones de Internet. En Actas de ACM SIGCOMM, San Diego, CA, agosto de 2001. [25] F. Ye, H. Luo, J. Cheng, S. Lu y L. Zhang. Un modelo de difusión de datos de dos niveles para redes de sensores inalámbricos a gran escala. En Actas de la Octava Conferencia Internacional Anual de Computación y Redes Móviles ACM/IEEE (Mobicom02), Atlanta, GA, septiembre de 2002. 75 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        }
    }
}