{
    "id": "C-83",
    "original_text": "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing. We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system. It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices. Each user is always served with upto-date documents and can organize his work based on document meta data. For this, we present our conceptual architecture for such a system and discuss it with an example. Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1. INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization. Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge. Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world. Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected. Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious. In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management. Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on. Such meta data can be gathered during the documents creation process and can be used versatilely. Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives. Meta data could be used to give the user the best possible view on the documents, dependent of his actual information. On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents. As far as we know, no system exists, that satisfies the aforementioned requirements. A very good overview about realtime communication and collaboration system is described in [7]. We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device. In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality. It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data. Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation. Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing. TeNDaX is a Text Native Database eXtension. It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions. Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users. With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently. Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2]. The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology. As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2. APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management. We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1. TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document. Additionally, meta data gathered during the whole document creation process enables sophisticated document management. With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device. The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1). The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice. The business logic layer represents the interface between the database and the word-processing application. It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment. The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors. The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1).. In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices. All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3]. Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way. Each character of a text document is stored as a single object in the database [3]. When storing text in such a native form, the performance of the employed database system is of crucial importance. The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7]. Figure 2 depicts the core database schema. By connecting a client to the database, a Session instance is created. One important attribute of the Session is the DocumentSession. This attribute refers to DocumentSession instances, which administrates all opened documents. For each opened document, a DocumentSession instance is created. The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2. TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document. The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document. Instances of the class FileNode either represent a folder node or a document node. The folder node corresponds to a folder of a file system and the document node to that of a file. Instances of the class Char represent the characters of a document. The value of a character is stored in the attribute CharacterValue. The sequence is defined by the attributes After and Before of the class Char. Particular instances of Char mark the beginning and the end of a document. The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database. Our editor does not have a replica of one part of the native text database in the sense of database replicas. Instead, it has a so-called image as its replica. Even if several authors edit the same text at the same time, they work on one unique document at all times. The system guarantees this unique view. Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document. When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection). The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager. Then, the editor as well connects to the real-time server component. The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate. Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document. Therefore, a special communication protocol is used: the update protocol. Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors. Messages are sent from the database to the real-time server component, which sends the messages to the affected editors. The update protocol consists of different message types. Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3. Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id. Class Model Figure 4 depicts the class model as well as the environment of the real-time server component. The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect. ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors. Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively. EditorWorker: This class manages the connections of type editor. The connection (a socket and its input and output stream) is stored in the SessionManager. SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure. DatabaseMessageWorker: This class is responsible for the connections of type database. At run-time, only one connection exists for each database. Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients. ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4. Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database. At the same time, more information about the current transaction is gathered. As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents. Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6]. All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents. This meta data can be used to create an alternative storage system for documents. In any case, it is not an easy task to change users familiarity to the well known hierarchical file system. This is also the main reason why we do not completely disregard the classical file system, but rather enhance it. Folders which correspond to the classical hierarchical file system will be called static folders. Folders where the documents are organized according to meta data, will be called dynamic folders. As all information is stored in the database, the file system, too, is based on the database. The dynamic folders build up sub-trees, which are guided by the meta data selected by the user. Thus, the first step in using a dynamic folder is the definition of how it should be built. For each level of a dynamic folder, exactly one meta data item is used to. The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used. As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder. Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed. The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for. The directory names indicate which meta data determines the content of the sub-folder in question. At each level, the documents, which have so far been found to match the meta data, can be inspected. Table 1. Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user. It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis. Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3. VALIDATION The proposed architecture is validated on the example of a character insertion. Insert operations are the mostly used operations in a (collaborative) editing system. The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following. The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage. Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed. AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2. The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it. For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network. Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC). Editors are connected to one or more real-time server components and to the corresponding databases. Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1. Editor B now inserts a character into this document. The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section. After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1). RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown. Occurring collaboration conflicts are solved and described in [3]. 4. SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database. With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management. Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents. Document editing and managing is consequently enabled anywhere, anytime and with any device. The above-descried system is implemented in a running prototype. The system will be tested soon in line with a student workshop next autumn. REFERENCES [1] Abiteboul, S., Agrawal, R., et al.: The Lowell Database Research Self Assessment. Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing. IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing. Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing. ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents. ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management. Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication. Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time. Application Strategies: In-Depth Research Report. Burton Group, 2005. 47",
    "original_translation": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47",
    "original_sentences": [
        "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
        "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
        "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
        "Each user is always served with upto-date documents and can organize his work based on document meta data.",
        "For this, we present our conceptual architecture for such a system and discuss it with an example.",
        "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
        "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
        "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
        "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
        "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
        "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
        "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
        "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
        "Such meta data can be gathered during the documents creation process and can be used versatilely.",
        "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
        "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
        "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
        "As far as we know, no system exists, that satisfies the aforementioned requirements.",
        "A very good overview about realtime communication and collaboration system is described in [7].",
        "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
        "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
        "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
        "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
        "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
        "TeNDaX is a Text Native Database eXtension.",
        "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
        "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
        "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
        "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
        "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
        "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
        "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
        "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
        "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
        "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
        "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
        "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
        "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
        "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
        "The business logic layer represents the interface between the database and the word-processing application.",
        "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
        "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
        "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
        "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
        "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
        "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
        "Each character of a text document is stored as a single object in the database [3].",
        "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
        "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
        "Figure 2 depicts the core database schema.",
        "By connecting a client to the database, a Session instance is created.",
        "One important attribute of the Session is the DocumentSession.",
        "This attribute refers to DocumentSession instances, which administrates all opened documents.",
        "For each opened document, a DocumentSession instance is created.",
        "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
        "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
        "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
        "Instances of the class FileNode either represent a folder node or a document node.",
        "The folder node corresponds to a folder of a file system and the document node to that of a file.",
        "Instances of the class Char represent the characters of a document.",
        "The value of a character is stored in the attribute CharacterValue.",
        "The sequence is defined by the attributes After and Before of the class Char.",
        "Particular instances of Char mark the beginning and the end of a document.",
        "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
        "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
        "Instead, it has a so-called image as its replica.",
        "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
        "The system guarantees this unique view.",
        "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
        "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
        "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
        "Then, the editor as well connects to the real-time server component.",
        "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
        "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
        "Therefore, a special communication protocol is used: the update protocol.",
        "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
        "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
        "The update protocol consists of different message types.",
        "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
        "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
        "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
        "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
        "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
        "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
        "EditorWorker: This class manages the connections of type editor.",
        "The connection (a socket and its input and output stream) is stored in the SessionManager.",
        "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
        "DatabaseMessageWorker: This class is responsible for the connections of type database.",
        "At run-time, only one connection exists for each database.",
        "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
        "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
        "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
        "At the same time, more information about the current transaction is gathered.",
        "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
        "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
        "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
        "This meta data can be used to create an alternative storage system for documents.",
        "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
        "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
        "Folders which correspond to the classical hierarchical file system will be called static folders.",
        "Folders where the documents are organized according to meta data, will be called dynamic folders.",
        "As all information is stored in the database, the file system, too, is based on the database.",
        "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
        "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
        "For each level of a dynamic folder, exactly one meta data item is used to.",
        "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
        "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
        "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
        "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
        "The directory names indicate which meta data determines the content of the sub-folder in question.",
        "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
        "Table 1.",
        "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
        "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
        "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
        "VALIDATION The proposed architecture is validated on the example of a character insertion.",
        "Insert operations are the mostly used operations in a (collaborative) editing system.",
        "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
        "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
        "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
        "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
        "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
        "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
        "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
        "Editors are connected to one or more real-time server components and to the corresponding databases.",
        "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
        "Editor B now inserts a character into this document.",
        "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
        "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
        "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
        "Occurring collaboration conflicts are solved and described in [3]. 4.",
        "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
        "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
        "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
        "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
        "The above-descried system is implemented in a running prototype.",
        "The system will be tested soon in line with a student workshop next autumn.",
        "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
        "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
        "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
        "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
        "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
        "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
        "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
        "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
        "Application Strategies: In-Depth Research Report.",
        "Burton Group, 2005. 47"
    ],
    "translated_text_sentences": [
        "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa.",
        "Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente.",
        "Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos.",
        "Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento.",
        "Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo.",
        "Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1.",
        "Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización.",
        "Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial).",
        "Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual.",
        "A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos.",
        "Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia.",
        "Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión.",
        "Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros.",
        "Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil.",
        "Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios.",
        "Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual.",
        "Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos.",
        "Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados.",
        "Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7].",
        "Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo.",
        "En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas.",
        "Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos.",
        "Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada.",
        "Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente.",
        "TeNDaX es una Extensión de Base de Datos Nativa de Texto.",
        "Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real.",
        "Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente.",
        "Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente.",
        "En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición.",
        "El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos.",
        "Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto.",
        "Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente.",
        "Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.).",
        "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1.",
        "En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento.",
        "Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento.",
        "Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo.",
        "El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1).",
        "El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice.",
        "La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto.",
        "Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario.",
        "El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados.",
        "El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1).",
        "En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles.",
        "Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3].",
        "Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa.",
        "Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3].",
        "Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia.",
        "Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7].",
        "La Figura 2 representa el esquema central de la base de datos.",
        "Al conectar un cliente a la base de datos, se crea una instancia de Sesión.",
        "Un atributo importante de la Sesión es la DocumentSession.",
        "Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos.",
        "Para cada documento abierto, se crea una instancia de DocumentSession.",
        "La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2.",
        "El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento.",
        "El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto.",
        "Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento.",
        "El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo.",
        "Las instancias de la clase Char representan los caracteres de un documento.",
        "El valor de un carácter se almacena en el atributo CharacterValue.",
        "La secuencia está definida por los atributos After y Before de la clase Char.",
        "Las instancias particulares de Char marcan el principio y el final de un documento.",
        "Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos.",
        "Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos.",
        "En cambio, tiene una imagen llamada réplica.",
        "Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento.",
        "El sistema garantiza esta vista única.",
        "La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento.",
        "Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida).",
        "El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager.",
        "Entonces, el editor también se conecta al componente del servidor en tiempo real.",
        "El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse.",
        "Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento.",
        "Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización.",
        "El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores.",
        "Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados.",
        "El protocolo de actualización consiste en diferentes tipos de mensajes.",
        "Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3.",
        "Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado.",
        "El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real.",
        "El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse.",
        "ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores.",
        "Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente.",
        "EditorWorker: Esta clase gestiona las conexiones de tipo editor.",
        "La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager.",
        "SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos.",
        "DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos.",
        "En tiempo de ejecución, solo existe una conexión para cada base de datos.",
        "Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes.",
        "ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4.",
        "Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos.",
        "Al mismo tiempo, se recopila más información sobre la transacción actual.",
        "Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos.",
        "Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6].",
        "Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto.",
        "Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos.",
        "En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico.",
        "Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos.",
        "Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas.",
        "Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas.",
        "Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos.",
        "Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario.",
        "Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida.",
        "Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos.",
        "El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse.",
        "Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta.",
        "Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles.",
        "Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando.",
        "Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión.",
        "En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados.",
        "Tabla 1.",
        "Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario.",
        "Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada.",
        "Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento.",
        "VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres.",
        "Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa).",
        "La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación.",
        "El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage.",
        "La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados.",
        "AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2.",
        "Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él.",
        "Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer.",
        "Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC).",
        "Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes.",
        "Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1.",
        "El editor B ahora inserta un carácter en este documento.",
        "La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior.",
        "Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1).",
        "RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato.",
        "Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4.",
        "RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos.",
        "Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada.",
        "La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados.",
        "La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo.",
        "El sistema descrito anteriormente está implementado en un prototipo en funcionamiento.",
        "El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño.",
        "REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell.",
        "Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos.",
        "Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos.",
        "Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa.",
        "Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos.",
        "Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos.",
        "Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc.",
        "Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real.",
        "Estrategias de Aplicación: Informe de Investigación en Profundidad.",
        "Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47"
    ],
    "error_count": 6,
    "keys": {
        "collaborative document processing": {
            "translated_key": "procesamiento colaborativo de documentos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT <br>collaborative document processing</br> has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT <br>collaborative document processing</br> has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing."
            ],
            "translated_annotated_samples": [
                "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El <br>procesamiento colaborativo de documentos</br> ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El <br>procesamiento colaborativo de documentos</br> ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "pervasive document editing and managing system": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a <br>pervasive document editing and managing system</br> Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a <br>pervasive document editing and managing system</br>.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "Concept and Architecture of a <br>pervasive document editing and managing system</br> Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a <br>pervasive document editing and managing system</br>."
            ],
            "translated_annotated_samples": [
                "Concepto y arquitectura de un <br>sistema pervasivo de edición y gestión de documentos</br> Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa.",
                "Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un <br>sistema de edición y gestión de documentos omnipresente</br>."
            ],
            "translated_text": "Concepto y arquitectura de un <br>sistema pervasivo de edición y gestión de documentos</br> Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un <br>sistema de edición y gestión de documentos omnipresente</br>. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    "sistema pervasivo de edición y gestión de documentos",
                    "sistema de edición y gestión de documentos omnipresente"
                ]
            ]
        },
        "text editing": {
            "translated_key": "edición de texto",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term <br>text editing</br> we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative <br>text editing</br> and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables <br>text editing</br> within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the <br>text editing</br> creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative <br>text editing</br>.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using <br>text editing</br> Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "Under the term <br>text editing</br> we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative <br>text editing</br> and document management.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables <br>text editing</br> within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the <br>text editing</br> creation time meta data model in [6] and the relation to XML databases in [7].",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative <br>text editing</br>."
            ],
            "translated_annotated_samples": [
                "Bajo el término <br>edición de texto</br> entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente.",
                "Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la <br>edición de texto</br> colaborativa y la gestión de documentos omnipresente.",
                "Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la <br>edición de texto</br> dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario.",
                "Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de <br>edición de texto</br> en [6] y la relación con bases de datos XML en [7].",
                "Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término <br>edición de texto</br> entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la <br>edición de texto</br> colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la <br>edición de texto</br> dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de <br>edición de texto</br> en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "real-time transaction": {
            "translated_key": "transacciones en tiempo real",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With <br>real-time transaction</br> we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "With <br>real-time transaction</br> we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently."
            ],
            "translated_annotated_samples": [
                "Con <br>transacciones en tiempo real</br> nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con <br>transacciones en tiempo real</br> nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "computer supported collaborative work": {
            "translated_key": "trabajo colaborativo con soporte informático",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "business logic layer": {
            "translated_key": "capa de lógica de negocio",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The <br>business logic layer</br> represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "The <br>business logic layer</br> represents the interface between the database and the word-processing application."
            ],
            "translated_annotated_samples": [
                "La <br>capa de lógica de negocio</br> representa la interfaz entre la base de datos y la aplicación de procesamiento de texto."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La <br>capa de lógica de negocio</br> representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "real-time server component": {
            "translated_key": "componente del servidor en tiempo real",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The <br>real-time server component</br> (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the <br>real-time server component</br> as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 <br>real-time server component</br> The <br>real-time server component</br> is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the <br>real-time server component</br> (if there isnt already a connection).",
                "The database system informs the <br>real-time server component</br> about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the <br>real-time server component</br>.",
                "The <br>real-time server component</br> adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the <br>real-time server component</br>, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The <br>real-time server component</br> uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the <br>real-time server component</br>, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the <br>real-time server component</br> whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and <br>real-time server component</br> Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the <br>real-time server component</br> sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the <br>real-time server component</br> sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the <br>real-time server component</br>.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the <br>real-time server component</br> can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "<br>real-time server component</br> Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the <br>real-time server component</br>. sendUpdate(UpdateMessage) The function Read is used in the <br>real-time server component</br> to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the <br>real-time server component</br> sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a <br>real-time server component</br> (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to <br>real-time server component</br> 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "The <br>real-time server component</br> (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "In the following, we will briefly present the database schema, the editor and the <br>real-time server component</br> as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 <br>real-time server component</br> The <br>real-time server component</br> is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the <br>real-time server component</br> (if there isnt already a connection).",
                "The database system informs the <br>real-time server component</br> about each new editor session (session), which the realtime server component administrates in his SessionManager."
            ],
            "translated_annotated_samples": [
                "El <br>componente del servidor en tiempo real</br> (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados.",
                "En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el <br>componente del servidor en tiempo real</br>, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles.",
                "La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El <br>componente del servidor en tiempo real</br> es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento.",
                "Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el <br>componente del servidor en tiempo real</br> (si no hay una conexión ya establecida).",
                "El sistema de base de datos informa al <br>componente del servidor en tiempo real</br> sobre cada nueva sesión de editor, la cual el <br>componente del servidor en tiempo real</br> administra en su SessionManager."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El <br>componente del servidor en tiempo real</br> (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el <br>componente del servidor en tiempo real</br>, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El <br>componente del servidor en tiempo real</br> es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el <br>componente del servidor en tiempo real</br> (si no hay una conexión ya establecida). El sistema de base de datos informa al <br>componente del servidor en tiempo real</br> sobre cada nueva sesión de editor, la cual el <br>componente del servidor en tiempo real</br> administra en su SessionManager. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "collaborative layouting": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], <br>collaborative layouting</br> in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting <br>collaborative layouting</br> in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "The concept and performance issues of such a text database are described in [3], <br>collaborative layouting</br> in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting <br>collaborative layouting</br> in Word Processing."
            ],
            "translated_annotated_samples": [
                "Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el <br>diseño colaborativo</br> en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7].",
                "Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la <br>maquetación colaborativa</br> en el procesamiento de textos."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el <br>diseño colaborativo</br> en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la <br>maquetación colaborativa</br> en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    "diseño colaborativo",
                    "maquetación colaborativa"
                ]
            ]
        },
        "hierarchical file system": {
            "translated_key": "sistema de archivos jerárquico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known <br>hierarchical file system</br>.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical <br>hierarchical file system</br> will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "In any case, it is not an easy task to change users familiarity to the well known <br>hierarchical file system</br>.",
                "Folders which correspond to the classical <br>hierarchical file system</br> will be called static folders."
            ],
            "translated_annotated_samples": [
                "En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido <br>sistema de archivos jerárquico</br>.",
                "Las carpetas que corresponden al <br>sistema de archivos jerárquico</br> clásico se llamarán carpetas estáticas."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido <br>sistema de archivos jerárquico</br>. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al <br>sistema de archivos jerárquico</br> clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "restriction": {
            "translated_key": "restricciones",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, <br>restriction</br>s and granularity must be defined by the user; if no <br>restriction</br>s are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and <br>restriction</br>s are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "Furthermore, for each meta data used, <br>restriction</br>s and granularity must be defined by the user; if no <br>restriction</br>s are defined, all accessible documents are listed.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and <br>restriction</br>s are possible in order to maximize search comfort for the user."
            ],
            "translated_annotated_samples": [
                "Además, para cada metadato utilizado, el usuario debe definir las <br>restricciones</br> y la granularidad; si no se definen <br>restricciones</br>, se enumeran todos los documentos accesibles.",
                "Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y <br>restricciones</br> son posibles para maximizar la comodidad de búsqueda para el usuario."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las <br>restricciones</br> y la granularidad; si no se definen <br>restricciones</br>, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y <br>restricciones</br> son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "granularity": {
            "translated_key": "granularidad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and <br>granularity</br> must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The <br>granularity</br> therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions <br>granularity</br> 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of <br>granularity</br> and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "Furthermore, for each meta data used, restrictions and <br>granularity</br> must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The <br>granularity</br> therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "Defining dynamic folders (example) Level Meta data Restrictions <br>granularity</br> 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of <br>granularity</br> and restrictions are possible in order to maximize search comfort for the user."
            ],
            "translated_annotated_samples": [
                "Además, para cada metadato utilizado, el usuario debe definir las restricciones y la <br>granularidad</br>; si no se definen restricciones, se enumeran todos los documentos accesibles.",
                "Por lo tanto, la <br>granularidad</br> influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando.",
                "Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de <br>granularidad</br> y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la <br>granularidad</br>; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la <br>granularidad</br> influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de <br>granularidad</br> y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "character insertion": {
            "translated_key": "inserción de caracteres",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a <br>character insertion</br>.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The <br>character insertion</br> is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "VALIDATION The proposed architecture is validated on the example of a <br>character insertion</br>.",
                "The <br>character insertion</br> is based on the TeNDaX Insert Algorithm which is formally described in the following."
            ],
            "translated_annotated_samples": [
                "VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una <br>inserción de caracteres</br>.",
                "La <br>inserción de caracteres</br> se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la edición y gestión colaborativa de documentos. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una <br>inserción de caracteres</br>. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La <br>inserción de caracteres</br> se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "pervasive document edit and management system": {
            "translated_key": "sistema de edición y gestión de documentos omnipresente",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "computer support collaborative work": {
            "translated_key": "Soporte informático para trabajo colaborativo.",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "cscw": {
            "translated_key": "CSCW",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT Collaborative document processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive collaborative document editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. collaborative document editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "collaborative document": {
            "translated_key": "edición y gestión colaborativa de documentos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT <br>collaborative document</br> processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "We address this issue from a different angle and describe the concept and architecture of a pervasive document editing and managing system.",
                "It exploits database techniques and real-time updating for sophisticated collaboration scenarios on multiple devices.",
                "Each user is always served with upto-date documents and can organize his work based on document meta data.",
                "For this, we present our conceptual architecture for such a system and discuss it with an example.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems [Computer-Communication Networks]: Computer System Organization, Distributed Systems, Distributed Applications General Terms Management, Measurement, Documentation, Economics, Human Factors 1.",
                "INTRODUCTION Text documents are a valuable resource for virtually any enterprise and organization.",
                "Documents like papers, reports and general business documentations contain a large part of todays (business) knowledge.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive <br>collaborative document</br> editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. <br>collaborative document</br> editing and management is totally neglected.",
                "Documents could therefore be seen as a vulnerable source in todays world, which demands for an appropriate solution: The need to store, retrieve and edit these documents collaboratively anytime, everywhere and with almost every suitable device and with guaranteed mechanisms for security, consistency, availability and access control, is obvious.",
                "In addition, word processing systems ignore the fact that the history of a text document contains crucial information for its management.",
                "Such meta data includes creation date, creator, authors, version, location-based information such as time and place when/where a user reads/edits a document and so on.",
                "Such meta data can be gathered during the documents creation process and can be used versatilely.",
                "Especially in the field of pervasive document management, meta data is of crucial importance since it offers totally new ways of organizing and classifying documents: On the one hand, the users actual situation influences the users objectives.",
                "Meta data could be used to give the user the best possible view on the documents, dependent of his actual information.",
                "On the other hand, as soon as the user starts to work, i.e. reads or edits a document, new meta data can be gathered in order to make the system more adaptable and in a sense to the users situation and, to offer future users a better view on the documents.",
                "As far as we know, no system exists, that satisfies the aforementioned requirements.",
                "A very good overview about realtime communication and collaboration system is described in [7].",
                "We therefore strive for a pervasive document editing and management system, which enables pervasive (and collaborative) document editing and management: users should be able to read and edit documents whenever, wherever, with whomever and with whatever device.",
                "In this paper, we present collaborative database-based real-time word processing, which provides pervasive document editing and management functionality.",
                "It enables the user to work on documents collaboratively and offers sophisticated document management facility: the user is always served with up-to-date documents and can organize and manage documents on the base of meta data.",
                "Additionally document data is treated as first class citizen of the database as demanded in [1]. 1.2 Underlying Concepts The concept of our pervasive document editing and management system requires an appropriate architectural foundation.",
                "Our concept and implementation are based on the TeNDaX [3] collaborative database-based document editing and management system, which enables pervasive document editing and managing.",
                "TeNDaX is a Text Native Database eXtension.",
                "It enables the storage of text in databases in a native form so that editing text is finally represented as real-time transactions.",
                "Under the term text editing we understand the following: writing and deleting text (characters), copying & pasting text, defining text layout & structure, inserting notes, setting access rights, defining business processes, inserting tables, pictures, and so on i.e. all the actions regularly carried out by word processing users.",
                "With real-time transaction we mean that editing text (e.g. writing a character/word) invokes one or several database transactions so that everything, which is typed appears within the editor as soon as these objects are stored persistently.",
                "Instead of creating files and storing them in a file system, the content and all of the meta data belonging to the documents is stored in a special way in the database, which enables very fast real-time transactions for all editing tasks [2].",
                "The database schema and the above-mentioned transactions are created in such a way that everything can be done within a multiuser environment, as is usual done by database technology.",
                "As a consequence, many of the achievements (with respect to data organization and querying, recovery, integrity and security enforcement, multi-user operation, distribution management, uniform tool access, etc.) are now, by means of this approach, also available for word processing. 2.",
                "APPROACH Our pervasive editing and management system is based on the above-mentioned database-based TeNDaX approach, where document data is stored natively in the database and supports pervasive collaborative text editing and document management.",
                "We define the pervasive document editing and management system, as a system, where documents can easily be accessed and manipulated everywhere (within the network), anytime (independently of the number of users working on the same document) and with any device (desktop, notebook, PDA, mobile phone etc.).",
                "DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figure 1.",
                "TeNDaX Application Architecture In contrast to documents stored locally on the hard drive or on a file server, our system automatically serves the user with the up-to-date version of a document and changes done on the document are stored persistently in the database and immediately propagated to all clients who are working on the same document.",
                "Additionally, meta data gathered during the whole document creation process enables sophisticated document management.",
                "With the TeXt SQL API as abstract interface, this approach can be used by any tool and for any device.",
                "The system is built on the following components (see Figure 1): An editor in Java implements the presentation layer (A-G in Figure 1).",
                "The aim of this layer is the integration in a well-known wordprocessing application such as OpenOffice.",
                "The business logic layer represents the interface between the database and the word-processing application.",
                "It consists of the following three components: The application server (marked as AS 1-4 in Figure 1) enables text editing within the database environment and takes care of awareness, security, document management etc., all within a collaborative, real-time and multi-user environment.",
                "The real-time server component (marked as RTSC 14 in Figure 1) is responsible for the propagation of information, i.e. updates between all of the connected editors.",
                "The storage engine (data layer) primarily stores the content of documents as well as all related meta data within the database Databases can be distributed in a peer-to-peer network (DB 1-4 in Figure 1)..",
                "In the following, we will briefly present the database schema, the editor and the real-time server component as well as the concept of dynamic folders, which enables sophisticated document management on the basis of meta data. 2.1 Application Architecture A database-based real-time collaborative editor allows the same document to be opened and edited simultaneously on the same computer or over a network of several computers and mobile devices.",
                "All concurrency issues, as well as message propagation, are solved within this approach, while multiple instances of the same document are being opened [3].",
                "Each insert or delete action is a database transaction and as such, is immediately stored persistently in the database and propagated to all clients working on the same document. 2.1.1 Database Schema As it was mentioned earlier that text is stored in a native way.",
                "Each character of a text document is stored as a single object in the database [3].",
                "When storing text in such a native form, the performance of the employed database system is of crucial importance.",
                "The concept and performance issues of such a text database are described in [3], collaborative layouting in [2], dynamic collaborative business processes within documents in [5], the text editing creation time meta data model in [6] and the relation to XML databases in [7].",
                "Figure 2 depicts the core database schema.",
                "By connecting a client to the database, a Session instance is created.",
                "One important attribute of the Session is the DocumentSession.",
                "This attribute refers to DocumentSession instances, which administrates all opened documents.",
                "For each opened document, a DocumentSession instance is created.",
                "The DocumentSession is important for the realtime server component, which, in case of a 42 is beforeis after Char (ID) has TextElement (ID) starts with is used by InternalFile (ID) is in includes created at has inserted by inserted is active ir ir CharacterValue (Unicode) has List (ID) starts starts with ends ends with FileSize has User (ID) last read by last written by created at created by Style DTD (ID) is used by uses uses is used by Authors arehas Description Password Picture UserColors UserListSecurity has has has has has has FileNode (ID) references/isreferencedby is dynamic DynStructure NodeDetails has has is NodeType is parent of has parent has Role (ID) created at created created by Name has Description is user Name has has main role FileNodeAccessMatrix (ID) has is AccessMatrix read option grand option write option contains has access Times opened … times with … by contains/ispartof ir ir is...andincludes Lineage (ID) references is after is before CopyPaste (ID) references is in is copy of is a copy from hasCopyPaste (ID) is activeLength has Str (Stream) has inserted by / inserted RegularChar StartChar EndChar File ExternalFile is from URL Type (extension) is of Title has DocumentSession (ID) is opened by has opened has opened Session (ID) isconnectedwith launched by VersionNumber uses has read option grand option write option ends with is used by is in has is unique DTD (Stream) has has Name Column (ID) has set on On/off isvisible…for false LanguageProfile (ID) has contains Name Profile Marking (ID) has parent internal is copy from hasRank is onPosition starts with ends with is logical style is itemized is italic is enumerated is underline is is part of Alignment Size has Font has hasColor is bold has uses ElementName StylesheetName isused by Process (ID) is running by OS is web session MainRoles Roles has has Timestamp (Date, Time) created at Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time)created at Type has Port IP has has MessagePropagator (ID) Picture (Stream) Name Picture (ID) has contains LayoutBlock WorkflowBlockLogicalBlock contains BlockDataType has property BlockData is of WorkflowInstance (ID) isin TaskInstance (ID) has parent Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) last modified at completed at started at created at is on has Name created by has attached Comment Typeis of Timestamp (Date, Time) Timestamp (Date, Time) Timestamp (Date, Time) created at started at << last modified at is Category Editors has Status has Timestamp (Date, Time) << status last modified Timestamp (Date, Time) is due at DueType has Timezone has Notes has SecurityLevel hasset Timestamp (Date, Time) << is completed at isfollowedby Task (Code) Description has Indent references hasbeenopenedat...by Timestamp RedoHistory is before is after references hasCharCounter is inhas has Offset ActionID (Code) Timestamp (Date, Time) invoked at invoked by Version (ID) isbuild from has created byarchived has Comment Timestamp (Date, Time) <<createdat UndoHistory (ID) starts ends has Name created by Name has is before is after << references CharCounter has is in created at Timestamp is active created by is used by Offset has created at Timestamp Index (ID) lastmodifiedby Lexicon (ID) isof Frequency is occurring is stop word Term is is in ends with starts with << original starts with WordNumber SentenceNumber ParagraphNumber Citatons has is in is is in istemporary is in has Structure has ElementPath createdat Timestamp << describes SpiderBuild (ID) is updated is deleted Timestamp (Date, Time) <<lastupdatedat has validated structure <<neededtoindex Time (ms) IndexUpdate nextupdatein hasindexed isrunningbyOS lastupdate enabled Timestamp Time (s) Documents StopCharacter Description Character Value (ASCII) is sentence stop is paragraph stop Name has is is OptionsSettings show information show warningsshow exceptions do lineage recording do internal lineage recording ask for unknown source show intra document lineage information are set for X X X VirtualBorder (ID) isonhas {1, 2} {1, 2} ir ir UserMode (Code) UserMode (Code) Figure 2.",
                "TeNDaX Database Schema (Object Role Modeling Diagram) change on a document done by a client, is responsible for sending update information to all the clients working on the same document.",
                "The DocumentId in the class DocumentSession points to a FileNode instance, and corresponds to the ID of the opened document.",
                "Instances of the class FileNode either represent a folder node or a document node.",
                "The folder node corresponds to a folder of a file system and the document node to that of a file.",
                "Instances of the class Char represent the characters of a document.",
                "The value of a character is stored in the attribute CharacterValue.",
                "The sequence is defined by the attributes After and Before of the class Char.",
                "Particular instances of Char mark the beginning and the end of a document.",
                "The methods InsertChars and RemoveChars are used to add and delete characters. 2.1.2 Editor As seen above, each document is natively stored in the database.",
                "Our editor does not have a replica of one part of the native text database in the sense of database replicas.",
                "Instead, it has a so-called image as its replica.",
                "Even if several authors edit the same text at the same time, they work on one unique document at all times.",
                "The system guarantees this unique view.",
                "Editing a document involves a number of steps: first, getting the required information out of the image, secondly, invoking the corresponding methods within the database, thirdly, changing the image, and fourthly, informing all other clients about the changes. 2.1.3 Real-Time Server Component The real-time server component is responsible for the real-time propagation of any changes on a document done within an editor to all the editors who are working or have opened the same document.",
                "When an editor connects to the application server, which in turn connects to the database, the database also establishes a connection to the real-time server component (if there isnt already a connection).",
                "The database system informs the real-time server component about each new editor session (session), which the realtime server component administrates in his SessionManager.",
                "Then, the editor as well connects to the real-time server component.",
                "The real-time server component adds the editor socket to the clients data structure in the SessionManager and is then ready to communicate.",
                "Each time a change on a document from an editor is persistently stored in the database, the database sends a message to the real-time server component, which in turns, sends the changes to all the 43 editors working on the same document.",
                "Therefore, a special communication protocol is used: the update protocol.",
                "Update Protocol The real-time server component uses the update protocol to communicate with the database and the editors.",
                "Messages are sent from the database to the real-time server component, which sends the messages to the affected editors.",
                "The update protocol consists of different message types.",
                "Messages consist of two packages: package one contains information for the real-time server component whereas package two is passed to the editors and contains the update information, as depicted in Figure 3. || RTSC || Parameter | … | Parameter|| || Editor Data || Protocol between database system and real-time server component Protocol between real -time server component and editors Figure 3.",
                "Update Protocol In the following, two message types are presented: ||u|sessionId,...,sessionId||||editor data|| u: update message, sessionId: Id of the client session With this message type the real-time server component sends the editor data package to all editors specified in the sessionId list. ||ud|fileId||||editor data|| ud: update document message, fileId: Id of the file With this message type, the real-time server component sends the editor data to all editors who have opened the document with the indicated file-Id.",
                "Class Model Figure 4 depicts the class model as well as the environment of the real-time server component.",
                "The environment consists mainly of the editor and the database, but any other client application that could make use of the real-time server component can connect.",
                "ConnectionListener: This class is responsible for the connection to the clients, i.e. to the database and the editors.",
                "Depending on the connection type (database or editor) the connection is passed to an EditorWorker instance or DatabaseMessageWorker instance respectively.",
                "EditorWorker: This class manages the connections of type editor.",
                "The connection (a socket and its input and output stream) is stored in the SessionManager.",
                "SessionManager: This class is similar to an in-memory database: all editor session information, e.g. the editor sockets, which editor has opened which document etc. are stored within this data structure.",
                "DatabaseMessageWorker: This class is responsible for the connections of type database.",
                "At run-time, only one connection exists for each database.",
                "Update messages from the database are sent to the DatabaseMessageWorker and, with the help of additional information from the SessionManager, sent to the corresponding clients.",
                "ServiceClass: This class offers a set of methods for reading, writing and logging messages. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figure 4.",
                "Real-Time Server Component Class Diagram 2.1.4 Dynamic Folders As mentioned above, every editing action invoked by a user is immediately transferred to the database.",
                "At the same time, more information about the current transaction is gathered.",
                "As all information is stored in the database, one character can hold a multitude of information, which can later be used for the retrieval of documents.",
                "Meta data is collected at character level, from document structure (layout, workflow, template, semantics, security, workflow and notes), on the level of a document section and on the level of the whole document [6].",
                "All of the above-mentioned meta data is crucial information for creating content and knowledge out of word processing documents.",
                "This meta data can be used to create an alternative storage system for documents.",
                "In any case, it is not an easy task to change users familiarity to the well known hierarchical file system.",
                "This is also the main reason why we do not completely disregard the classical file system, but rather enhance it.",
                "Folders which correspond to the classical hierarchical file system will be called static folders.",
                "Folders where the documents are organized according to meta data, will be called dynamic folders.",
                "As all information is stored in the database, the file system, too, is based on the database.",
                "The dynamic folders build up sub-trees, which are guided by the meta data selected by the user.",
                "Thus, the first step in using a dynamic folder is the definition of how it should be built.",
                "For each level of a dynamic folder, exactly one meta data item is used to.",
                "The following example illustrates the steps which have to be taken in order to define a dynamic folder, and the meta data which should be used.",
                "As a first step, the meta data which will be used for the dynamic folder must be chosen (see Table 1): The sequence of the meta data influences the structure of the folder.",
                "Furthermore, for each meta data used, restrictions and granularity must be defined by the user; if no restrictions are defined, all accessible documents are listed.",
                "The granularity therefore influences the number of sub-folders which will be created for the partitioning of the documents. 44 As the user enters the tree structure of the dynamic folder, he can navigate through the branches to arrive at the document(s) he is looking for.",
                "The directory names indicate which meta data determines the content of the sub-folder in question.",
                "At each level, the documents, which have so far been found to match the meta data, can be inspected.",
                "Table 1.",
                "Defining dynamic folders (example) Level Meta data Restrictions Granularity 1 Creator Only show documents which have been created by the users Leone or Hodel or Gall One folder per creator 2 Current location Only show documents which where read at my current location One folder per task status 3 Authors Only show documents where at least 40% was written by user Leone Each 20% one folder ad-hoc changes of granularity and restrictions are possible in order to maximize search comfort for the user.",
                "It is possible to predefine dynamic folders for frequent use, e.g. a location-based folder, as well as to create and modify dynamic folders on an ad-hoc basis.",
                "Furthermore, the content of such dynamic folders can change from one second to another, depending on the changes made by other users at that moment. 3.",
                "VALIDATION The proposed architecture is validated on the example of a character insertion.",
                "Insert operations are the mostly used operations in a (collaborative) editing system.",
                "The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.",
                "The algorithm is simplified for this purpose. 3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects. c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document. β=beginning of document ε=end of document The function startTA starts a transaction. startTA = start transaction The function commitTA commits a transaction that was started. commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted. checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success. lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far. releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous characters CharacterValue of a character c and if the previous characters status is active. checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next characters CharacterValue of a character c and if the next characters status is active. 45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component. sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.",
                "Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.",
                "AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.",
                "The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction. startTA Select the character that is situated before the character that follows the string to be inserted. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted. lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted. characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.",
                "For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted. updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction. releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e. of its architecture: four databases are distributed over a peer-to-peer network.",
                "Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).",
                "Editors are connected to one or more real-time server components and to the corresponding databases.",
                "Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.",
                "Editor B now inserts a character into this document.",
                "The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.",
                "After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).",
                "RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.",
                "Occurring collaboration conflicts are solved and described in [3]. 4.",
                "SUMMARY With the approach presented in this paper and the implemented prototype, we offer real-time collaborative editing and management of documents stored in a special way in a database.",
                "With this approach we provide security, consistency and availability of documents and consequently offer pervasive document editing and management.",
                "Pervasive document editing and management is enabled due to the proposed architecture with the embedded real46 time server component, which propagates changes to a document immediately and consequently offers up-to-date documents.",
                "Document editing and managing is consequently enabled anywhere, anytime and with any device.",
                "The above-descried system is implemented in a running prototype.",
                "The system will be tested soon in line with a student workshop next autumn.",
                "REFERENCES [1] Abiteboul, S., Agrawal, R., et al. : The Lowell Database Research Self Assessment.",
                "Massachusetts, USA, 2003. [2] Hodel, T. B., Businger, D., and Dittrich, K. R.: Supporting Collaborative Layouting in Word Processing.",
                "IEEE International Conference on Cooperative Information Systems (CoopIS), Larnaca, Cyprus, IEEE, 2004. [3] Hodel, T. B. and Dittrich, K. R.: Concept and prototype of a collaborative business process environment for document processing.",
                "Data & Knowledge Engineering 52, Special Issue: Collaborative Business Process Technologies(1): 61120, 2005. [4] Hodel, T. B., Dubacher, M., and Dittrich, K. R.: Using Database Management Systems for Collaborative Text Editing.",
                "ACM European Conference of Computersupported Cooperative Work (ECSCW CEW 2003), Helsinki, Finland, 2003. [5] Hodel, T. B., Gall, H., and Dittrich, K. R.: Dynamic Collaborative Business Processes within Documents.",
                "ACM Special Interest Group on Design of Communication (SIGDOC) , Memphis, USA, 2004. [6] Hodel, T. B., R. Hacmac, and Dittrich, K. R.: Using Text Editing Creation Time Meta Data for Document Management.",
                "Conference on Advanced Information Systems Engineering (CAiSE05), Porto, Portugal, Springer Lecture Notes, 2005. [7] Hodel, T. B., Specker, F. and Dittrich, K. R.: Embedded SOAP Server on the Operating System Level for ad-hoc Automatic Real-Time Bidirectional Communication.",
                "Information Resources Management Association (IRMA), San Diego, USA, 2005. [8] OKelly, P.: Revolution in Real-Time Communication and Collaboration: For Real This Time.",
                "Application Strategies: In-Depth Research Report.",
                "Burton Group, 2005. 47"
            ],
            "original_annotated_samples": [
                "Concept and Architecture of a Pervasive Document Editing and Managing System Stefania Leone Thomas B. Hodel Harald Gall University of Zurich, Switzerland University of Zurich, Switzerland University of Zurich, Switzerland Department of Informatics Department of Informatics Department of Informatics leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch ABSTRACT <br>collaborative document</br> processing has been addressed by many approaches so far, most of which focus on document versioning and collaborative editing.",
                "Documents are mostly stored in a hierarchical folder structure on file servers and it is difficult to organize them in regard to classification, versioning etc., although it is of utmost importance that users can find, retrieve and edit up-to-date versions of documents whenever they want and, in a user-friendly way. 1.1 Problem Description With most of the commonly used word-processing applications documents can be manipulated by only one user at a time: tools for pervasive <br>collaborative document</br> editing and management, are rarely deployed in todays world.",
                "Despite the fact, that people strive for location- and time- independence, the importance of pervasive collaborative work, i.e. <br>collaborative document</br> editing and management is totally neglected."
            ],
            "translated_annotated_samples": [
                "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa.",
                "Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual.",
                "A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la <br>edición y gestión colaborativa de documentos</br>."
            ],
            "translated_text": "Concepto y arquitectura de un sistema pervasivo de edición y gestión de documentos Stefania Leone Thomas B. Hodel Harald Gall Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Universidad de Zúrich, Suiza Departamento de Informática Departamento de Informática Departamento de Informática leone@ifi.unizh.ch hodel@ifi.unizh.ch gall@ifi.unizh.ch RESUMEN El procesamiento colaborativo de documentos ha sido abordado por muchos enfoques hasta ahora, la mayoría de los cuales se centran en la versión de documentos y la edición colaborativa. Abordamos este problema desde un ángulo diferente y describimos el concepto y la arquitectura de un sistema de edición y gestión de documentos omnipresente. Utiliza técnicas de bases de datos y actualización en tiempo real para escenarios de colaboración sofisticados en múltiples dispositivos. Cada usuario siempre recibe documentos actualizados y puede organizar su trabajo en función de los metadatos del documento. Para esto, presentamos nuestra arquitectura conceptual para dicho sistema y la discutimos con un ejemplo. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos [Redes de Computadoras]: Organización de Sistemas Informáticos, Sistemas Distribuidos, Aplicaciones Distribuidas Términos Generales Gestión, Medición, Documentación, Economía, Factores Humanos 1. Los documentos de texto son un recurso valioso para prácticamente cualquier empresa u organización. Documentos como papers, informes y documentación empresarial general contienen una gran parte del conocimiento actual (empresarial). Los documentos se almacenan principalmente en una estructura de carpetas jerárquica en servidores de archivos y es difícil organizarlos en cuanto a clasificación, versiones, etc., aunque es de suma importancia que los usuarios puedan encontrar, recuperar y editar versiones actualizadas de los documentos cuando lo deseen y de manera amigable. Descripción del Problema 1.1 Con la mayoría de las aplicaciones de procesamiento de texto comúnmente utilizadas, los documentos solo pueden ser manipulados por un usuario a la vez: las herramientas para la edición y gestión colaborativa de documentos, rara vez se implementan en el mundo actual. A pesar de que las personas buscan la independencia de ubicación y tiempo, se descuida por completo la importancia del trabajo colaborativo generalizado, es decir, la <br>edición y gestión colaborativa de documentos</br>. Los documentos podrían ser considerados como una fuente vulnerable en el mundo de hoy, lo que demanda una solución adecuada: La necesidad de almacenar, recuperar y editar estos documentos de forma colaborativa en cualquier momento, en cualquier lugar y con casi cualquier dispositivo adecuado y con mecanismos garantizados de seguridad, consistencia, disponibilidad y control de acceso, es obvia. Además, los sistemas de procesamiento de texto ignoran el hecho de que la historia de un documento de texto contiene información crucial para su gestión. Metadatos como la fecha de creación, el creador, los autores, la versión, la información basada en la ubicación como la hora y el lugar en que un usuario lee/edita un documento, entre otros. Metadatos como estos pueden recopilarse durante el proceso de creación de documentos y pueden ser utilizados de manera versátil. Especialmente en el campo de la gestión de documentos omnipresente, los metadatos son de crucial importancia ya que ofrecen formas totalmente nuevas de organizar y clasificar documentos: Por un lado, la situación actual de los usuarios influye en los objetivos de los usuarios. Los metadatos podrían utilizarse para ofrecer al usuario la mejor vista posible de los documentos, dependiendo de su información actual. Por otro lado, tan pronto como el usuario comienza a trabajar, es decir, lee o edita un documento, se pueden recopilar nuevos metadatos para hacer que el sistema sea más adaptable y, en cierto sentido, a la situación de los usuarios y ofrecer a los futuros usuarios una mejor visión de los documentos. Hasta donde sabemos, no existe ningún sistema que cumpla con los requisitos mencionados. Una muy buena descripción sobre el sistema de comunicación y colaboración en tiempo real se encuentra en [7]. Por lo tanto, nos esforzamos por un sistema de edición y gestión de documentos omnipresente, que permita la edición y gestión omnipresente (y colaborativa) de documentos: los usuarios deberían poder leer y editar documentos en cualquier momento, en cualquier lugar, con quien sea y con cualquier dispositivo. En este documento, presentamos un procesamiento de palabras en tiempo real basado en una base de datos colaborativa, que proporciona funcionalidades de edición y gestión de documentos ubicuas. Permite al usuario trabajar en documentos de forma colaborativa y ofrece una sofisticada facilidad de gestión de documentos: el usuario siempre recibe documentos actualizados y puede organizar y gestionar documentos en base a metadatos. Además, los datos de los documentos son tratados como ciudadanos de primera clase de la base de datos, tal como se demanda en [1]. 1.2 Conceptos Subyacentes El concepto de nuestro sistema de edición y gestión de documentos omnipresente requiere una base arquitectónica adecuada. Nuestro concepto e implementación se basan en el sistema colaborativo de edición y gestión de documentos basado en la base de datos TeNDaX [3], que permite una edición y gestión de documentos omnipresente. TeNDaX es una Extensión de Base de Datos Nativa de Texto. Permite el almacenamiento de texto en bases de datos en su forma nativa para que la edición de texto se represente finalmente como transacciones en tiempo real. Bajo el término edición de texto entendemos lo siguiente: escribir y borrar texto (caracteres), copiar y pegar texto, definir el diseño y la estructura del texto, insertar notas, establecer derechos de acceso, definir procesos comerciales, insertar tablas, imágenes, y demás, es decir, todas las acciones que los usuarios de procesadores de texto realizan regularmente. Con transacciones en tiempo real nos referimos a que al editar texto (por ejemplo, escribir un carácter/palabra) se invoca una o varias transacciones de base de datos para que todo lo que se escriba aparezca en el editor tan pronto como estos objetos se almacenen de forma persistente. En lugar de crear archivos y almacenarlos en un sistema de archivos, el contenido y todos los metadatos pertenecientes a los documentos se almacenan de una manera especial en la base de datos, lo que permite transacciones en tiempo real muy rápidas para todas las tareas de edición. El esquema de la base de datos y las transacciones mencionadas anteriormente están creadas de tal manera que todo se puede hacer dentro de un entorno multiusuario, como suele hacerse con la tecnología de bases de datos. Como consecuencia, muchos de los logros (en cuanto a organización y consulta de datos, recuperación, integridad y aplicación de seguridad, operación multiusuario, gestión de distribución, acceso uniforme a herramientas, etc.) ahora también están disponibles para el procesamiento de texto. Nuestro sistema de edición y gestión omnipresente se basa en el enfoque TeNDaX basado en la base de datos mencionada anteriormente, donde los datos del documento se almacenan nativamente en la base de datos y admiten la edición de texto colaborativa y la gestión de documentos omnipresente. Definimos el sistema de edición y gestión de documentos ubicuo como un sistema en el que los documentos pueden ser fácilmente accedidos y manipulados en cualquier lugar (dentro de la red), en cualquier momento (independientemente del número de usuarios trabajando en el mismo documento) y con cualquier dispositivo (computadora de escritorio, portátil, PDA, teléfono móvil, etc.). DB 3 RTSC 4 RTSC 1 RTSC 2 RTSC 3 AS 1 AS 3 DB 1 DB 2 AS 2 AS 4 DB 4 A B C D E F G Figura 1. En contraste con los documentos almacenados localmente en el disco duro o en un servidor de archivos, nuestro sistema sirve automáticamente al usuario la versión más actualizada de un documento y los cambios realizados en el documento se almacenan de forma persistente en la base de datos y se propagan inmediatamente a todos los clientes que estén trabajando en el mismo documento. Además, los metadatos recopilados durante todo el proceso de creación del documento permiten una gestión sofisticada del documento. Con la API SQL de TeXt como interfaz abstracta, este enfoque puede ser utilizado por cualquier herramienta y para cualquier dispositivo. El sistema está construido sobre los siguientes componentes (ver Figura 1): Un editor en Java implementa la capa de presentación (A-G en la Figura 1). El objetivo de esta capa es la integración en una aplicación de procesamiento de texto conocida como OpenOffice. La capa de lógica de negocio representa la interfaz entre la base de datos y la aplicación de procesamiento de texto. Está compuesto por los siguientes tres componentes: El servidor de aplicaciones (marcado como AS 1-4 en la Figura 1) permite la edición de texto dentro del entorno de la base de datos y se encarga de la conciencia, seguridad, gestión de documentos, etc., todo dentro de un entorno colaborativo, en tiempo real y multiusuario. El componente del servidor en tiempo real (marcado como RTSC 14 en la Figura 1) es responsable de la propagación de información, es decir, actualizaciones entre todos los editores conectados. El motor de almacenamiento (capa de datos) almacena principalmente el contenido de los documentos, así como todos los metadatos relacionados dentro de la base de datos. Las bases de datos pueden distribuirse en una red de pares a pares (DB 1-4 en la Figura 1). En lo siguiente, presentaremos brevemente el esquema de la base de datos, el editor y el componente del servidor en tiempo real, así como el concepto de carpetas dinámicas, que permite una gestión de documentos sofisticada basada en metadatos. Arquitectura de la Aplicación Un editor colaborativo en tiempo real basado en una base de datos permite que el mismo documento se abra y edite simultáneamente en la misma computadora o en una red de varias computadoras y dispositivos móviles. Todos los problemas de concurrencia, así como la propagación de mensajes, se resuelven dentro de este enfoque, mientras se abren múltiples instancias del mismo documento [3]. Cada acción de inserción o eliminación es una transacción de base de datos y, como tal, se almacena inmediatamente de forma persistente en la base de datos y se propaga a todos los clientes que trabajan en el mismo documento. 2.1.1 Esquema de la base de datos Como se mencionó anteriormente, el texto se almacena de forma nativa. Cada carácter de un documento de texto se almacena como un objeto único en la base de datos [3]. Al almacenar texto en una forma nativa, el rendimiento del sistema de base de datos utilizado es de crucial importancia. Los problemas de concepto y rendimiento de una base de datos de texto se describen en [3], el diseño colaborativo en [2], los procesos comerciales colaborativos dinámicos dentro de documentos en [5], el modelo de metadatos de tiempo de creación de edición de texto en [6] y la relación con bases de datos XML en [7]. La Figura 2 representa el esquema central de la base de datos. Al conectar un cliente a la base de datos, se crea una instancia de Sesión. Un atributo importante de la Sesión es la DocumentSession. Este atributo se refiere a las instancias de DocumentSession, que administran todos los documentos abiertos. Para cada documento abierto, se crea una instancia de DocumentSession. La DocumentSession es importante para el componente del servidor en tiempo real, que, en caso de un 42, está antes de es después de Char (ID) tiene TextElement (ID) comienza con es usado por InternalFile (ID) está en incluye creado en tiene insertado por insertado es activo ir ir CharacterValue (Unicode) tiene List (ID) comienza comienza con termina termina con FileSize tiene User (ID) último leído por último escrito por creado en creado por Style DTD (ID) es usado por usa usa es usado por Los autores son tiene Descripción Contraseña Imagen Colores de usuario Seguridad de lista de usuario tiene tiene tiene tiene tiene tiene FileNode (ID) referencias/esreferenciadopor es dinámico DynStructure NodeDetails tiene tiene es NodeType es padre de tiene padre tiene Rol (ID) creado en creado creado por Nombre tiene Descripción es usuario Nombre tiene tiene rol principal FileNodeAccessMatrix (ID) tiene es AccessMatrix opción de lectura opción de concesión opción de escritura contiene tiene acceso Veces abiertas ... veces con ... por contiene/es parte de ir ir es...e incluye Lineage (ID) referencias es después de es antes de CopyPaste (ID) referencias está en es copia de es una copia de tieneCopyPaste (ID) es Longitud activa tiene Str (Stream) tiene insertado por / insertado RegularChar StartChar EndChar Archivo ExternalFile es de URL Tipo (extensión) es de Título tiene DocumentSession (ID) es abierto por ha abierto tiene abierto Sesión (ID) está conectado con lanzado por Número de versión usa tiene opción de lectura opción de concesión opción de escritura termina con es usado por está en tiene es único DTD (Stream) tiene tiene Nombre Columna (ID) tiene establecido en Encendido/apagado es visible...para falso LanguageProfile (ID) tiene contiene Nombre Perfil Marcaje (ID) tiene padre interno es copia de tieneRango está en posición comienza con termina con es estilo lógico es enumerado es cursiva es subrayado es es parte de Alineación Tamaño tiene Fuente tiene tieneColor es negrita tiene usa Nombre de elemento Nombre de hoja de estilos es usado por Proceso (ID) está en ejecución por OS es sesión web MainRoles Roles tiene tiene Marca de tiempo (Fecha, Hora) creado en Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en Tipo tiene Puerto IP tiene tiene Propagador de mensajes (ID) Imagen (Stream) Nombre Imagen (ID) tiene contiene Bloque de diseño Bloque lógico de flujo de trabajo contiene Tipo de bloque de datos tiene propiedad BlockData es de Instancia de flujo de trabajo (ID) está en Instancia de tarea (ID) tiene padre Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) último modificado en completado en iniciado en creado en está en tiene Nombre creado por tiene adjunto Comentario Tipo es de Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) Marca de tiempo (Fecha, Hora) creado en iniciado en << último modificado en es Categoría Editores tiene Estado tiene Marca de tiempo (Fecha, Hora) << estado último modificado Marca de tiempo (Fecha, Hora) es debido a DueType tiene Zona horaria tiene Notas tiene Nivel de seguridad ha establecido Marca de tiempo (Fecha, Hora) << está completado en es seguido por Tarea (Código) Descripción tiene Sangría referencias ha sido abierto en...por Marca de tiempo Historial de rehacer es antes de es después de referencias tiene Contador de caracteres está en tiene tiene Desplazamiento ID de acción (Código) Marca de tiempo (Fecha, Hora) invocado en invocado por Versión (ID) está construido a partir de ha creado por archivado tiene Comentario Marca de tiempo (Fecha, Hora) << creado en Historial de deshacer (ID) comienza termina tiene Nombre creado por Nombre tiene es antes de es después de << referencias Contador de caracteres tiene está en creado en Marca de tiempo es activo creado por es usado por Desplazamiento tiene creado en Marca de tiempo Índice (ID) último modificado por Lexicon (ID) es de Frecuencia está ocurriendo es palabra de parada Término es está en termina con comienza con << original comienza con Número de palabra Número de oración Número de párrafo Citas tiene está en es está en es temporal está en tiene Estructura tiene Ruta de elemento creado en Marca de tiempo << describe SpiderBuild (ID) está actualizado está eliminado Marca de tiempo (Fecha, Hora) << último actualizado tiene estructura validada <<necesarioparaindexar Tiempo (ms) Actualización de índice próxima actualización en ha indexado está en ejecución por OS última actualización habilitado Marca de tiempo Tiempo (s) Documentos Carácter de parada Descripción Valor de carácter (ASCII) es parada de oración es parada de párrafo Nombre tiene es OpcionesConfiguración mostrar información mostrar advertencias mostrar excepciones hacer grabación de linaje hacer grabación de linaje interno pedir fuente desconocida mostrar información de linaje intra documento están configurados para X X X VirtualBorder (ID) está en tiene {1, 2} {1, 2} ir ir Modo de usuario (Código) Modo de usuario (Código) Figura 2. El esquema de la base de datos de TeNDaX (Diagrama de Modelado de Roles de Objetos) modificado en un documento por un cliente, es responsable de enviar información de actualización a todos los clientes que trabajan en el mismo documento. El DocumentId en la clase DocumentSession apunta a una instancia de FileNode, y corresponde al ID del documento abierto. Las instancias de la clase FileNode representan un nodo de carpeta o un nodo de documento. El nodo de carpeta corresponde a una carpeta de un sistema de archivos y el nodo de documento a un archivo. Las instancias de la clase Char representan los caracteres de un documento. El valor de un carácter se almacena en el atributo CharacterValue. La secuencia está definida por los atributos After y Before de la clase Char. Las instancias particulares de Char marcan el principio y el final de un documento. Los métodos InsertChars y RemoveChars se utilizan para agregar y eliminar caracteres. 2.1.2 Editor Como se ve arriba, cada documento se almacena nativamente en la base de datos. Nuestro editor no tiene una réplica de una parte de la base de datos de texto nativo en el sentido de réplicas de bases de datos. En cambio, tiene una imagen llamada réplica. Aunque varios autores editen el mismo texto al mismo tiempo, trabajan en un único documento en todo momento. El sistema garantiza esta vista única. La edición de un documento implica una serie de pasos: primero, extraer la información requerida de la imagen, en segundo lugar, invocar los métodos correspondientes dentro de la base de datos, en tercer lugar, cambiar la imagen y, finalmente, informar a todos los demás clientes sobre los cambios. 2.1.3 Componente del Servidor en Tiempo Real El componente del servidor en tiempo real es responsable de la propagación en tiempo real de cualquier cambio en un documento realizado dentro de un editor a todos los editores que estén trabajando o hayan abierto el mismo documento. Cuando un editor se conecta al servidor de la aplicación, que a su vez se conecta a la base de datos, la base de datos también establece una conexión con el componente del servidor en tiempo real (si no hay una conexión ya establecida). El sistema de base de datos informa al componente del servidor en tiempo real sobre cada nueva sesión de editor, la cual el componente del servidor en tiempo real administra en su SessionManager. Entonces, el editor también se conecta al componente del servidor en tiempo real. El componente del servidor en tiempo real agrega el socket del editor a la estructura de datos de los clientes en el SessionManager y luego está listo para comunicarse. Cada vez que un cambio en un documento de un editor se almacena de forma persistente en la base de datos, la base de datos envía un mensaje al componente del servidor en tiempo real, que a su vez envía los cambios a los 43 editores que trabajan en el mismo documento. Por lo tanto, se utiliza un protocolo de comunicación especial: el protocolo de actualización. El componente del servidor en tiempo real utiliza el protocolo de actualización para comunicarse con la base de datos y los editores. Los mensajes se envían desde la base de datos al componente del servidor en tiempo real, el cual envía los mensajes a los editores afectados. El protocolo de actualización consiste en diferentes tipos de mensajes. Los mensajes consisten en dos paquetes: el paquete uno contiene información para el componente del servidor en tiempo real, mientras que el paquete dos se envía a los editores y contiene la información de actualización, como se muestra en la Figura 3. || RTSC || Parámetro | … | Parámetro || || Datos del Editor || Protocolo entre el sistema de base de datos y el componente del servidor en tiempo real Protocolo entre el componente del servidor en tiempo real y los editores Figura 3. Protocolo de Actualización En lo siguiente, se presentan dos tipos de mensajes: ||u|sessionId,...,sessionId||||datos del editor|| u: mensaje de actualización, sessionId: Id de la sesión del cliente Con este tipo de mensaje, el componente del servidor en tiempo real envía el paquete de datos del editor a todos los editores especificados en la lista de sessionId. ||ud|fileId||||datos del editor|| ud: mensaje de actualización de documento, fileId: Id del archivo Con este tipo de mensaje, el componente del servidor en tiempo real envía los datos del editor a todos los editores que hayan abierto el documento con el fileId indicado. El Modelo de Clase de la Figura 4 representa el modelo de clase, así como el entorno del componente del servidor en tiempo real. El entorno consiste principalmente del editor y la base de datos, pero cualquier otra aplicación cliente que pueda hacer uso del componente de servidor en tiempo real puede conectarse. ConnectionListener: Esta clase es responsable de la conexión con los clientes, es decir, con la base de datos y los editores. Dependiendo del tipo de conexión (base de datos o editor), la conexión se pasa a una instancia de EditorWorker o a una instancia de DatabaseMessageWorker respectivamente. EditorWorker: Esta clase gestiona las conexiones de tipo editor. La conexión (un socket y sus flujos de entrada y salida) se almacena en el SessionManager. SessionManager: Esta clase es similar a una base de datos en memoria: toda la información de la sesión del editor, por ejemplo, los sockets del editor, qué editor ha abierto qué documento, etc., se almacenan dentro de esta estructura de datos. DatabaseMessageWorker: Esta clase es responsable de las conexiones de tipo base de datos. En tiempo de ejecución, solo existe una conexión para cada base de datos. Los mensajes de actualización de la base de datos se envían al DatabaseMessageWorker y, con la ayuda de información adicional del SessionManager, se envían a los clientes correspondientes. ServiceClass: Esta clase ofrece un conjunto de métodos para leer, escribir y registrar mensajes. tdb.mp.editor tdb.mp.database tdb.mp.mgmt EditorWorker DatabaseMessageWorker SessionManager MessageHandler ConnectionListener ServiceClass MessageQueue tdb.mp.listener tdb.mp.service junit.tests 1 * 1 * 1 * 1 * 1* 1 * Editors Datenbanksystem 1 2 1 * 1 * 1 * TCP/IP Figura 4. Diagrama de clases del componente del servidor en tiempo real 2.1.4 Carpetas Dinámicas Como se mencionó anteriormente, cada acción de edición invocada por un usuario se transfiere inmediatamente a la base de datos. Al mismo tiempo, se recopila más información sobre la transacción actual. Dado que toda la información se almacena en la base de datos, un carácter puede contener una multitud de información, la cual puede ser utilizada más tarde para la recuperación de documentos. Los metadatos se recopilan a nivel de carácter, a partir de la estructura del documento (diseño, flujo de trabajo, plantilla, semántica, seguridad, flujo de trabajo y notas), a nivel de una sección del documento y a nivel de todo el documento [6]. Todos los metadatos mencionados anteriormente son información crucial para crear contenido y conocimiento a partir de documentos de procesamiento de texto. Estos metadatos se pueden utilizar para crear un sistema de almacenamiento alternativo para documentos. En cualquier caso, no es una tarea fácil cambiar la familiaridad de los usuarios con el conocido sistema de archivos jerárquico. Esta es también la razón principal por la que no desechamos por completo el sistema de archivos clásico, sino que lo mejoramos. Las carpetas que corresponden al sistema de archivos jerárquico clásico se llamarán carpetas estáticas. Las carpetas donde los documentos están organizados según los metadatos se llamarán carpetas dinámicas. Como toda la información se almacena en la base de datos, el sistema de archivos también se basa en la base de datos. Las carpetas dinámicas crean subárboles, los cuales son guiados por los metadatos seleccionados por el usuario. Por lo tanto, el primer paso en el uso de una carpeta dinámica es la definición de cómo debe ser construida. Para cada nivel de una carpeta dinámica, se utiliza exactamente un elemento de metadatos. El siguiente ejemplo ilustra los pasos que deben seguirse para definir una carpeta dinámica y los metadatos que deben utilizarse. Como primer paso, se debe elegir los metadatos que se utilizarán para la carpeta dinámica (ver Tabla 1): La secuencia de los metadatos influye en la estructura de la carpeta. Además, para cada metadato utilizado, el usuario debe definir las restricciones y la granularidad; si no se definen restricciones, se enumeran todos los documentos accesibles. Por lo tanto, la granularidad influye en la cantidad de subcarpetas que se crearán para la partición de los documentos. A medida que el usuario ingresa en la estructura de árbol de la carpeta dinámica, puede navegar a través de las ramas para llegar al documento o documentos que está buscando. Los nombres de los directorios indican qué metadatos determinan el contenido de la subcarpeta en cuestión. En cada nivel, los documentos que hasta ahora se han encontrado que coinciden con los metadatos pueden ser inspeccionados. Tabla 1. Definir carpetas dinámicas (ejemplo) Metadatos de nivel Restricciones Granularidad 1 Creador Mostrar solo documentos creados por los usuarios Leone, Hodel o Gall Una carpeta por creador 2 Ubicación actual Mostrar solo documentos leídos en mi ubicación actual Una carpeta por estado de tarea 3 Autores Mostrar solo documentos donde al menos el 40% fue escrito por el usuario Leone Cada 20%, una carpeta cambios ad-hoc de granularidad y restricciones son posibles para maximizar la comodidad de búsqueda para el usuario. Es posible predefinir carpetas dinámicas para uso frecuente, por ejemplo, una carpeta basada en la ubicación, así como crear y modificar carpetas dinámicas de forma improvisada. Además, el contenido de estas carpetas dinámicas puede cambiar de un segundo a otro, dependiendo de los cambios realizados por otros usuarios en ese momento. VALIDACIÓN La arquitectura propuesta se valida en el ejemplo de una inserción de caracteres. Las operaciones de inserción son las operaciones más utilizadas en un sistema de edición (colaborativa). La inserción de caracteres se basa en el Algoritmo de Inserción TeNDaX que está descrito formalmente a continuación. El algoritmo se simplifica para este propósito. 3.1 Algoritmo de Inserción de Caracteres El símbolo c representa el carácter del objeto, p representa el carácter anterior, n representa el siguiente carácter de un objeto de carácter c y el símbolo l representa una lista de objetos de carácter. c = carácter p = carácter anterior n = carácter siguiente l = lista de caracteres El símbolo c1 representa el primer carácter en la lista l, ci representa un carácter en la lista l en la posición i, donde i es un valor entre 1 y la longitud de la lista l, y cn representa el último carácter en la lista l. c1 = primer carácter en la lista l ci = carácter en la posición i en la lista l cn = último carácter en la lista l El símbolo β representa el carácter especial que marca el inicio de un documento y ε representa el carácter especial que marca el final de un documento. β = inicio del documento ε = fin del documento La función startTA inicia una transacción. startTA = iniciar transacción La función commitTA confirma una transacción que fue iniciada. commitTA = confirmar transacción La función checkWriteAccess verifica si se ha concedido el acceso de escritura para una sesión de documento s. checkWriteAccess(s) = verificar si se ha concedido el acceso de escritura para la sesión de documento s La función lock adquiere un bloqueo exclusivo para un carácter c y devuelve 1 si tiene éxito y 0 si no tiene éxito. lock(c) = adquirir el bloqueo para el carácter c éxito: devolver 1, no éxito: devolver 0 La función releaseLocks libera todos los bloqueos que una transacción ha adquirido hasta el momento. releaseLocks = liberar todos los bloqueos La función getPrevious devuelve el carácter anterior y getNext devuelve el carácter siguiente de un carácter c. getPrevious(c) = devolver el carácter anterior de carácter c getNext(c) = devolver el carácter siguiente de carácter c La función linkBefore enlaza un carácter precedente p con un carácter sucesivo x y la función linkAfter enlaza un carácter sucesivo n con un carácter precedente y. linkBefore(p,x) = enlazar carácter p con carácter x linkAfter(n,y) = enlazar carácter n con carácter y La función updateString enlaza un carácter p con el primer carácter c1 de una lista de caracteres l y un carácter n con el último carácter cn de una lista de caracteres l. updateString(l, p, n) = linkBefore(p, c1) ∧ linkAfter(n, cn) La función insertChar inserta un carácter c en la tabla Char con los campos After establecidos en un carácter p y Before establecidos en un carácter n. insertChar(c, p, n) = linkAfter(c, p) ∧ linkBefore(c, n) ∧ linkBefore(p, c) ∧ linkAfter(n, c) La función checkPreceding determina el Valor de Carácter de los caracteres anteriores de un carácter c y si el estado de los caracteres anteriores es activo. checkPreceding(c) = devolver estado y Valor de Carácter del carácter anterior La función checkSucceeding determina el Valor de Carácter de los caracteres siguientes de un carácter c y si el estado de los caracteres siguientes es activo. checkSucceeding(c) = devolver estado y Valor de Carácter del carácter siguiente La función checkCharValue determina el Valor de Carácter de un carácter c. checkCharValue(c) = devolver Valor de Carácter del carácter c La función sendUpdate envía un mensaje de actualización (UpdateMessage) desde la base de datos al componente del servidor en tiempo real. sendUpdate(UpdateMessage) La función Read se utiliza en el componente del servidor en tiempo real para leer el UpdateMessage. La función AllocatEditors verifica en base al UpdateMessage y al SessionManager qué editores deben ser informados. AllocateEditors(UpdateInformationMessage, SessionManager) = devuelve los editores afectados La función SendMessage(EditorData) envía la parte del editor del mensaje de actualización a los editores SendMessage(EditorData) En TeNDaX, el Algoritmo de Inserción se implementa en el método de clase InsertChars de la clase Char que se muestra en la Figura 2. Los parámetros relevantes para las definiciones que siguen, se introducen en la siguiente lista: - nextCharacterOID: OID del carácter situado junto a la cadena que se va a insertar - previousCharacterOID: OID del carácter situado antes de la cadena que se va a insertar - characterOIDs (Lista): Lista de caracteres que deben ser insertados Por lo tanto, la inserción de caracteres puede definirse paso a paso de la siguiente manera: Iniciar una transacción. startTA Seleccionar el carácter que está situado antes del carácter que sigue a la cadena que se va a insertar. getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π Después ϑOID = nextCharacterOID(Char)) Adquirir el bloqueo para el carácter que está situado en el documento antes del carácter que sigue a la cadena que se va a insertar. lock(prevCharId) En este momento, la lista characterOIDs contiene los caracteres c1 a cn que se insertarán. characterOIDs={ c1, …, cn } Cada carácter de la cadena se inserta en la posición adecuada vinculando el carácter precedente y el sucesivo a él. Para cada carácter ci de characterOIDs: insertarChar(ci, p, n) Donde ci ∈ { c1,…, cn } Verificar si los caracteres precedentes y sucesivos están activos o si es el principio o el final del documento. checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Actualizar los caracteres antes y después de la cadena a insertar. updateString(characterOIDs, prevCharOID, nextCharacterOID) Liberar todos los bloqueos y confirmar la transacción. releaseLocks commitTA Enviar información de actualización al componente del servidor en tiempo real. sendUpdate(UpdatenMessage) Leer el mensaje de actualización e informar a los editores afectados del cambio. Read(UpdateMessage) Asignar Editores(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Ejemplo de Inserción de Caracteres La Figura 1 muestra una instantánea del sistema, es decir, de su arquitectura: cuatro bases de datos distribuidas en una red peer-to-peer. Cada base de datos está conectada a un servidor de aplicaciones (AS) y cada servidor de aplicaciones está conectado a un componente de servidor en tiempo real (RTSC). Los editores están conectados a uno o más componentes de servidor en tiempo real y a las bases de datos correspondientes. Teniendo en cuenta que el editor A (conectado a la base de datos 1 y 4) y el editor B (conectado a la base de datos 1 y 2) están trabajando en el mismo documento almacenado en la base de datos 1. El editor B ahora inserta un carácter en este documento. La operación de inserción se pasa al servidor de aplicaciones 1, que a su vez la pasa a la base de datos 1, donde se invoca una operación de inserción; los caracteres se insertan de acuerdo con el algoritmo discutido en la sección anterior. Después de la inserción, la base de datos 1 envía un mensaje de actualización (según el protocolo de actualización discutido anteriormente) al componente del servidor en tiempo real 1 (a través de AS 1). RTCS 1 combina la información de actualización recibida con la información en su SessionManager y envía los datos del editor a los editores afectados, en este caso al editor A y B, donde los cambios se muestran de inmediato. Los conflictos de colaboración que ocurren son resueltos y descritos en [3]. 4. RESUMEN Con el enfoque presentado en este artículo y el prototipo implementado, ofrecemos edición y gestión colaborativa en tiempo real de documentos almacenados de manera especial en una base de datos. Con este enfoque proporcionamos seguridad, consistencia y disponibilidad de documentos y, en consecuencia, ofrecemos una edición y gestión de documentos generalizada. La edición y gestión de documentos generalizada se habilita debido a la arquitectura propuesta con el componente de servidor en tiempo real integrado, que propaga los cambios a un documento de inmediato y, en consecuencia, ofrece documentos actualizados. La edición y gestión de documentos se habilita consecuentemente en cualquier lugar, en cualquier momento y con cualquier dispositivo. El sistema descrito anteriormente está implementado en un prototipo en funcionamiento. El sistema será probado pronto en línea con un taller para estudiantes el próximo otoño. REFERENCIAS [1] Abiteboul, S., Agrawal, R., et al. : La Autoevaluación de Investigación en Bases de Datos de Lowell. Massachusetts, EE. UU., 2003. [2] Hodel, T. B., Businger, D. y Dittrich, K. R.: Apoyo a la maquetación colaborativa en el procesamiento de textos. Conferencia Internacional de la IEEE sobre Sistemas de Información Cooperativos (CoopIS), Larnaca, Chipre, IEEE, 2004. [3] Hodel, T. B. y Dittrich, K. R.: Concepto y prototipo de un entorno colaborativo de procesos de negocio para el procesamiento de documentos. Data & Knowledge Engineering 52, Número Especial: Tecnologías de Procesos de Negocio Colaborativos (1): 61120, 2005. [4] Hodel, T. B., Dubacher, M. y Dittrich, K. R.: Uso de Sistemas de Gestión de Bases de Datos para Edición de Texto Colaborativa. Conferencia Europea de ACM sobre Trabajo Cooperativo con Soporte Informático (ECSCW CEW 2003), Helsinki, Finlandia, 2003. [5] Hodel, T. B., Gall, H., y Dittrich, K. R.: Procesos de Negocio Colaborativos Dinámicos dentro de Documentos. Grupo de Interés Especial de ACM sobre Diseño de Comunicación (SIGDOC), Memphis, EE. UU., 2004. [6] Hodel, T. B., R. Hacmac y Dittrich, K. R.: Uso de metadatos de tiempo de creación de edición de texto para la gestión de documentos. Conferencia sobre Ingeniería Avanzada de Sistemas de Información (CAiSE05), Porto, Portugal, Notas de Conferencia de Springer, 2005. [7] Hodel, T. B., Specker, F. y Dittrich, K. R.: Servidor SOAP Integrado en el Nivel del Sistema Operativo para Comunicación Bidireccional en Tiempo Real Automática Ad-hoc. Asociación de Gestión de Recursos de Información (IRMA), San Diego, EE. UU., 2005. [8] OKelly, P.: Revolución en la Comunicación y Colaboración en Tiempo Real: Esta vez es real. Estrategias de Aplicación: Informe de Investigación en Profundidad. Burton Group, 2005. 47\n\nGrupo Burton, 2005. 47 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        }
    }
}