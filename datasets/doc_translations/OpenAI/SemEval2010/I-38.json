{
    "id": "I-38",
    "original_text": "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions. However, most of the existing winner determination algorithms for combinatorial auctions are centralized. The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer). It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation. It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary. PAUSE establishes the rules the bidders must obey. However, it does not tell us how the bidders should calculate their bids. We have developed a couple of bidding algorithms for the bidders in a PAUSE auction. Our algorithms always return the set of bids that maximizes the bidders utility. Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search. In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm. Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems. General Terms Algorithms, Performance. 1. INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years. In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items. Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue. This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10]. Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed. The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2]. Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem. Thus, several approaches and algorithms have been proposed to address the winner determination problem. However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners. Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12]. We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer. The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders. PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them. However, it is not concerned with how the bidders determine what they should bid. In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility. Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. THE PAUSE AUCTION A PAUSE auction for m items has m stages. Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items. At the end of this state we will know what the highest bid for each individual item is and who placed that bid. Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less. The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions. Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset. At the end of each stage k all agents know the best bid for every subset of size k or less. Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted. Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset. Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items. That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation. However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution. Our test results provide an answer to this question. The PAUSE auction makes the job of the auctioneer very easy. All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid. The computational problem shifts from one of winner determination to one of bid generation. Each agent must search over the space of all bidsets which contain at least one of its bids. The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset. Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose). Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2]. We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer. That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid. The agents would have an incentive to perform their computation as it will increase their expected utility. Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids). Namely, the only one that can increase an agents bid value is the agent itself. Anyone claiming a higher value for some other agent is lying. The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3. PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid). The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage. At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids. This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items. Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items. If the agent is not winning any items then its utility is zero. The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction. Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero). That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4. BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items. In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item. Our algorithms focus on the subsequent stages: k > 1. When k > 1, agents have to find g∗ i . This can be done by performing a complete search on B. However, this approach is computationally expensive since it produces a large search tree. Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree. Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B. We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later). Similarly, we set their-bids to be the rest of the bids from B. Finally, the agents search list is simply the concatenation of my-bids and their-bids. Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9). The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids. This branch and bound search is implemented by pbsearch (Figure 2). Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree. The bound we use is the maximum utility that the agent can expect to receive from a given set of bids. We call it u∗ . Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility. If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21). Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase. For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W). The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch. Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item. This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid. To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent. Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic. A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7). The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility. However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price. Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ . If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation. However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids. There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution. We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search. However it repeats the whole search at every stage. We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction. It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time. The problem is the same; the agent i has to find g∗ i . We note that g∗ i is a bidset that contains at least one bid of the agent i. Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i). That is, gS i is is best bidset for all items which includes a bid from i for all S items. In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility. That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0. We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details. Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B. Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage. Initially C-Table has one row or entry for each set S for which vi(S) > 0. We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3). Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider. We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8). But how do we know that the gS in C-Table[S] is still the best solution for S? There are only two cases when we are not sure about that and we need to do a search to update C-Table[S]. These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S]. We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid. In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S. Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it. We build the list bids that contains only those bids. However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed. Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19). The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch. The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1). Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23). We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS . Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii). We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26). When we reach line 27 in cachedpausebid, we are sure that we have the right gS . However, agent is bids in gS are still set to his own valuation and not to the lowest possible price. If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS . As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items. In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38). The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one. It assumes that W and B remains constant during its execution. 698 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5. TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other. In order to do our tests we had to generate value functions for the agents1 . The algorithm we used is shown in Figure 5. The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks. For example, imagine a set of robots which must pick up and deliver items to different locations. Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle. Their costs for the item bundles are subadditive, which means that their preferences are superadditive. The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents. It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms. We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation. That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid. This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue. Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations. Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items. We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10. We ran both algorithms 100 times for each combination. When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6). The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items. If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed. For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item. If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed. We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases. For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items. In a few instances our algorithms find different solutions this is due to the different The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order. We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower? To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS. We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7. However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage. Again, this difference is produced by the order of the search. In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%. The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree. For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms. As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8). However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes. For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes. Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items. For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 . Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations. As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items. We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows. We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations. We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm. As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6. RELATED WORK A lot of research has been done on various aspects of combinatorial auctions. We recommend [2] for a good review. However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new. One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution. The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation. This algorithm also fails to converge to a solution for most cases. In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem. Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered. This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts. Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier. Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best. As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7. CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders. The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions. With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer. However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids. We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction. Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids. Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution. The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items. As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster. As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid. We also found that the revenue generated by our algorithms increases as function of the number of items in the auction. Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm. Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation. Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8. REFERENCES [1] P. J. Brewer. Decentralized computation procurement and computational robustness in a smart market. Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors. Combinatorial Auctions. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham. Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches. In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg. A combinatorial auction with multiple winners for universal service. Management Science, 46(4):586-596, 2000. [5] A. Land, S. Powell, and R. Steinberg. PAUSE: A computationally tractable combinatorial auction. In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham. Towards a universal test suite for combinatorial auction algorithms. In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal. Algorithms for distributed winner determination in combinatorial auctions. In LNAI volume of AMEC/TADA. Springer, 2006. [8] S. Park and M. H. Rothkopf. Auctions with endogenously determined allowable combinations. Technical report, Rutgets Center for Operations Research, January 2001. RRR 3-2001. [9] D. C. Parkes and J. Shneidman. Distributed implementations of vickrey-clarke-groves auctions. In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad. Computationally manageable combinational auctions. Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm. An algorithm for winner determination in combinatorial auctions. Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine. CABOB: a fast optimal algorithm for winner determination in combinatorial auctions. Management Science, 51(3):374-391, 2005. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701",
    "original_translation": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes. Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta. Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos. Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la solución que maximiza los ingresos cuando los agentes ofrecen sus verdaderas valoraciones. Dado que PAUSE utiliza subastas inglesas, los precios finales (aproximadamente) representan la segunda valoración más alta, más , para ese conjunto de artículos. Fijamos el número de agentes en 5 y experimentamos con diferentes cantidades de artículos, concretamente de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución que maximiza los ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de artículos que la solución que maximiza los ingresos (como se muestra en la Figura 6). Los casos en los que nuestros algoritmos no lograron llegar a la distribución de la solución que maximiza los ingresos son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución que maximiza los ingresos contiene la oferta (o ofertas) utilizando estas valoraciones más altas, entonces es imposible que la subasta PAUSE encuentre esta solución porque esa oferta (esas ofertas) nunca se realiza. Por ejemplo, si el agente i tiene vi(1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces i solo necesita hacer una oferta de 11 para ganar ese artículo. Si la solución que maximiza los ingresos requiere que 1 se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se realizará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen hacia la solución que maximiza los ingresos disminuye a medida que aumenta el número de elementos. Para 2 elementos es casi del 100%, pero disminuye un poco menos del 1 por ciento a medida que los elementos aumentan, por lo que este porcentaje promedio de convergencia es alrededor del 90% para 10 elementos. En algunas ocasiones, nuestros algoritmos encuentran soluciones diferentes debido a The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de elementos en cachéPausaOferta 3 3 3 3 3 3 3 3 3 PausaOferta + + + + + + + + + + Figura 8: Promedio de nodos expandidos (eje y) en función de los elementos en la subasta. orden de las ofertas en la lista de ofertas que hace que se busquen en diferente orden. Sabemos que los ingresos generados por la subasta de PAUSE suelen ser inferiores a los ingresos de la solución que maximiza los ingresos, pero ¿cuánto más bajos son? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos proporcionados por nuestros algoritmos en relación con los ingresos proporcionados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio un 2.7% a medida que aumenta el número de artículos, como se muestra en la Figura 7. Sin embargo, descubrimos que cachedpausebid genera un mayor ingreso que pausebid (un 4.3% más en promedio) excepto en subastas con 2 artículos donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 artículos, ambos algoritmos generan en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 artículos), cachedpausebid generó en promedio una proporción de ingresos del 91.5%, mientras que pausebid generó en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el árbol de búsqueda. Para esto contamos el número de veces que se invoca pbsearch cada vez que se llama a pausebid y el número de veces que se invoca fastpausebidsearch cada vez que se llama a cachedpausebid, respectivamente para cada uno de nuestros algoritmos. Como era de esperar, dado que este es un problema NP-Difícil, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que cachedpausebid supera a pausebid, ya que en promedio expande menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos expandidos cuando hay 2 elementos es cero para cachedpausebid, mientras que para pausebid es 2; y en el otro extremo (10 elementos) cachedpausebid se expande en promedio solo 633 nodos, mientras que pausebid se expande en promedio en 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta en función del número de elementos, el número real de nodos es mucho menor que el peor escenario de nn donde n es el número de elementos. Por ejemplo, para 10 artículos expandimos ligeramente más de 103 nodos para el caso de pausebid y menos que eso para el caso de cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de Artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 9: Tiempo promedio en segundos que tarda en finalizar una subasta (eje y) en función del número de artículos en la subasta, que son números mucho menores que 1010. También hay que tener en cuenta que nuestro algoritmo de generación de valor (Figura 5) genera una cantidad de ofertas que es exponencial en el número de artículos, como podría esperarse en muchas situaciones. Por lo tanto, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan de forma exponencial en función del número de ofertas, pero se mantengan aproximadamente constantes a medida que crece el número de artículos. Queríamos asegurarnos de que menos nodos expandidos realmente se corresponde con una ejecución más rápida, especialmente dado que nuestros algoritmos ejecutan diferentes operaciones. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, un PC portátil Intel Centrino de 2.0 GHz con 1 GB de RAM y un disco duro de 60 GB a 7200 RPM, y calculamos el tiempo promedio que tarda en finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, cachedpausebid es más rápido que pausebid, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos. TRABAJO RELACIONADO Se ha realizado mucha investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena reseña. Sin embargo, el estudio de algoritmos distribuidos para la determinación de ganadores en subastas combinatorias todavía es relativamente nuevo. Un enfoque está dado por los algoritmos para distribuir el problema de determinación del ganador en subastas combinatorias presentados en [7], pero estos algoritmos asumen que las entidades computacionales son los artículos que se están vendiendo y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación distribuida del ganador en una subasta combinatoria, pero asume que las propias ofertas realizan el cálculo. Este algoritmo también falla en converger hacia una solución en la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos VCG en un problema de diseño de mecanismos. Su mecanismo se resume aproximadamente en hacer que cada agente calcule los pagos para otros dos agentes y se los entregue a un 700 seguro de The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) tiene un servidor central que luego verifica que los resultados de todos los pares estén de acuerdo; de lo contrario, se ordena una nueva recalcuación. Esta idea general, a la que llaman principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se presenta en [8] donde los agentes de oferta priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo centralizado de determinación de ganadores debe considerar, facilitando así ese problema. Finalmente, en el proceso de cálculo de la subasta de reloj [1], a los agentes se les otorga un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Por lo tanto, asume que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores como asume la subasta PAUSE. 7. CONCLUSIONES Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entre los postores. La subasta PAUSE es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en subastas combinatorias. Con esta subasta, incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Sin embargo, mientras que PAUSE establece las reglas que los licitadores deben obedecer, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos presentado dos algoritmos, pausebid y cachedpausebid, que los agentes ofertantes pueden utilizar para participar en una subasta de PAUSE. Ambos algoritmos implementan una estrategia de maximización de utilidad miope que garantiza encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dado el conjunto de mejores ofertas pendientes en cualquier momento, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayor parte del tiempo, la misma distribución de elementos que la solución que maximiza los ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de artículos. Dado que es un problema NP-Difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se invoca. cachedpausebid almacena en caché soluciones parciales y realiza una búsqueda de ramificación y acotación solo en las pocas partes afectadas por los cambios en las ofertas entre tiempos consecutivos. cachedpausebid tiene un mejor rendimiento ya que explora menos nodos (menos de la mitad) y es más rápido. Como era de esperar, los ingresos generados por una subasta de PAUSE son inferiores a los ingresos de una solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores, sin embargo, descubrimos que cachedpausebid genera en promedio un 4.7% más de ingresos que pausebid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan en función del número de artículos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas restricciones de coordinación respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores. Además, debido al diseño de la subasta PAUSE, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros algoritmos de oferta pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la coordinación, pero que prefiera no implementar un subastador centralizado. 8. REFERENCIAS [1] P. J. Cervecero. Adquisición descentralizada de computación y robustez computacional en un mercado inteligente. Teoría Económica, 13(1):41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. Subastas combinatorias. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Ciencias de la Gestión, 46(4):586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. PAUSA: Una subasta combinatoria computacionalmente viable. En Cramton et al. [2], capítulo 6, páginas 139-157. [6] K. Leyton-Brown, M. Pearson y Y. Shoham. Hacia un conjunto de pruebas universal para algoritmos de subasta combinatoria. En Actas de la 2ª conferencia de la ACM sobre comercio electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación distribuida de ganadores en subastas combinatorias. En el volumen de LNAI de AMEC/TADA. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas determinadas endógenamente. Informe técnico, Centro de Investigación de Operaciones Rutgets, enero de 2001. RRR 3-2001. [9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo y rápido para la determinación del ganador en subastas combinatorias. Ciencia de la Gestión, 51(3):374-391, 2005. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 701",
    "original_sentences": [
        "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
        "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
        "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
        "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
        "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
        "PAUSE establishes the rules the bidders must obey.",
        "However, it does not tell us how the bidders should calculate their bids.",
        "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
        "Our algorithms always return the set of bids that maximizes the bidders utility.",
        "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
        "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
        "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
        "General Terms Algorithms, Performance. 1.",
        "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
        "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
        "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
        "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
        "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
        "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
        "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
        "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
        "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
        "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
        "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
        "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
        "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
        "However, it is not concerned with how the bidders determine what they should bid.",
        "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
        "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
        "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
        "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
        "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
        "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
        "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
        "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
        "At the end of each stage k all agents know the best bid for every subset of size k or less.",
        "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
        "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
        "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
        "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
        "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
        "Our test results provide an answer to this question.",
        "The PAUSE auction makes the job of the auctioneer very easy.",
        "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
        "The computational problem shifts from one of winner determination to one of bid generation.",
        "Each agent must search over the space of all bidsets which contain at least one of its bids.",
        "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
        "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
        "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
        "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
        "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
        "The agents would have an incentive to perform their computation as it will increase their expected utility.",
        "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
        "Namely, the only one that can increase an agents bid value is the agent itself.",
        "Anyone claiming a higher value for some other agent is lying.",
        "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
        "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
        "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
        "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
        "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
        "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
        "If the agent is not winning any items then its utility is zero.",
        "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
        "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
        "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
        "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
        "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
        "Our algorithms focus on the subsequent stages: k > 1.",
        "When k > 1, agents have to find g∗ i .",
        "This can be done by performing a complete search on B.",
        "However, this approach is computationally expensive since it produces a large search tree.",
        "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
        "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
        "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
        "Similarly, we set their-bids to be the rest of the bids from B.",
        "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
        "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
        "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
        "This branch and bound search is implemented by pbsearch (Figure 2).",
        "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
        "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
        "We call it u∗ .",
        "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
        "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
        "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
        "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
        "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
        "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
        "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
        "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
        "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
        "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
        "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
        "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
        "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
        "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
        "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
        "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
        "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
        "However it repeats the whole search at every stage.",
        "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
        "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
        "The problem is the same; the agent i has to find g∗ i .",
        "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
        "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
        "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
        "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
        "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
        "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
        "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
        "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
        "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
        "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
        "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
        "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
        "But how do we know that the gS in C-Table[S] is still the best solution for S?",
        "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
        "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
        "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
        "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
        "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
        "We build the list bids that contains only those bids.",
        "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
        "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
        "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
        "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
        "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
        "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
        "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
        "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
        "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
        "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
        "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
        "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
        "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
        "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
        "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
        "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
        "In order to do our tests we had to generate value functions for the agents1 .",
        "The algorithm we used is shown in Figure 5.",
        "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
        "For example, imagine a set of robots which must pick up and deliver items to different locations.",
        "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
        "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
        "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
        "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
        "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
        "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
        "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
        "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
        "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
        "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
        "We ran both algorithms 100 times for each combination.",
        "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
        "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
        "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
        "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
        "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
        "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
        "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
        "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
        "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
        "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
        "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
        "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
        "Again, this difference is produced by the order of the search.",
        "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
        "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
        "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
        "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
        "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
        "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
        "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
        "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
        "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
        "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
        "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
        "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
        "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
        "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
        "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
        "We recommend [2] for a good review.",
        "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
        "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
        "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
        "This algorithm also fails to converge to a solution for most cases.",
        "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
        "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
        "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
        "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
        "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
        "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
        "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
        "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
        "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
        "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
        "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
        "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
        "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
        "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
        "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
        "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
        "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
        "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
        "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
        "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
        "REFERENCES [1] P. J.",
        "Brewer.",
        "Decentralized computation procurement and computational robustness in a smart market.",
        "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
        "Combinatorial Auctions.",
        "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
        "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
        "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
        "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
        "A combinatorial auction with multiple winners for universal service.",
        "Management Science, 46(4):586-596, 2000. [5] A.",
        "Land, S. Powell, and R. Steinberg.",
        "PAUSE: A computationally tractable combinatorial auction.",
        "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
        "Towards a universal test suite for combinatorial auction algorithms.",
        "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
        "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
        "Algorithms for distributed winner determination in combinatorial auctions.",
        "In LNAI volume of AMEC/TADA.",
        "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
        "Auctions with endogenously determined allowable combinations.",
        "Technical report, Rutgets Center for Operations Research, January 2001.",
        "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
        "Distributed implementations of vickrey-clarke-groves auctions.",
        "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
        "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
        "Computationally manageable combinational auctions.",
        "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
        "An algorithm for winner determination in combinatorial auctions.",
        "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
        "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
        "Management Science, 51(3):374-391, 2005.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
    ],
    "translated_text_sentences": [
        "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias.",
        "Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados.",
        "La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador).",
        "Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo.",
        "Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario.",
        "PAUSE establece las reglas que los licitadores deben obedecer.",
        "Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas.",
        "Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE.",
        "Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores.",
        "Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva.",
        "En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores.",
        "Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente.",
        "Términos generales Algoritmos, Rendimiento. 1.",
        "Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años.",
        "En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales.",
        "Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador.",
        "Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10].",
        "Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica.",
        "Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2].",
        "Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema.",
        "Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador.",
        "Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores.",
        "Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12].",
        "Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador.",
        "La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores.",
        "PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos.",
        "Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar.",
        "En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad.",
        "Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
        "La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas.",
        "La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales.",
        "Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta.",
        "Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos.",
        "Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones.",
        "Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente.",
        "Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor.",
        "Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas.",
        "Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor.",
        "Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos.",
        "Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración.",
        "Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos.",
        "Nuestros resultados de prueba proporcionan una respuesta a esta pregunta.",
        "La subasta PAUSE facilita mucho el trabajo del subastador.",
        "Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente.",
        "El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas.",
        "Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas.",
        "La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual.",
        "Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás).",
        "Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2].",
        "Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador.",
        "Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual.",
        "Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada.",
        "Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas).",
        "Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente.",
        "Cualquier persona que afirme un valor más alto para otro agente está mintiendo.",
        "Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente.",
        "FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta).",
        "Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual.",
        "En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales.",
        "Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos.",
        "Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos.",
        "Si el agente no está ganando ningún ítem, entonces su utilidad es cero.",
        "El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta.",
        "Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero).",
        "Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4.",
        "ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales.",
        "En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular.",
        "Nuestros algoritmos se centran en las etapas siguientes: k > 1.",
        "Cuando k > 1, los agentes tienen que encontrar g∗ i.",
        "Esto se puede hacer realizando una búsqueda completa en B.",
        "Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande.",
        "Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda.",
        "Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B.",
        "Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante).",
        "De manera similar, establecemos sus ofertas como el resto de las ofertas de B.",
        "Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas.",
        "Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa).",
        "El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas.",
        "Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2).",
        "Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda.",
        "El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas.",
        "Lo llamamos u∗.",
        "Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad.",
        "Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch).",
        "Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará.",
        "Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W).",
        "El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch.",
        "Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo.",
        "Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta.",
        "Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente.",
        "De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística.",
        "Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch).",
        "El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente.",
        "Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible.",
        "Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗.",
        "Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente.",
        "Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas.",
        "Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución.",
        "Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento.",
        "Sin embargo, repite la búsqueda completa en cada etapa.",
        "Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE.",
        "Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez.",
        "El problema es el mismo; el agente i tiene que encontrar g∗ i.",
        "Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i.",
        "Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i).",
        "Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S.",
        "En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes.",
        "Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0.",
        "Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles.",
        "Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B.",
        "Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa.",
        "Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0.",
        "Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3).",
        "Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar.",
        "Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8).",
        "Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S?",
        "Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S].",
        "Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S].",
        "Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid.",
        "En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S.",
        "Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este.",
        "Construimos la lista de ofertas que contiene solo esas ofertas.",
        "Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado.",
        "Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19).",
        "El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch.",
        "La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1).",
        "Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23).",
        "Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual.",
        "Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii).",
        "Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché).",
        "Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto.",
        "Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible.",
        "Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS.",
        "Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos.",
        "En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid).",
        "La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe.",
        "Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional.",
        "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5.",
        "PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí.",
        "Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes.",
        "El algoritmo que utilizamos se muestra en la Figura 5.",
        "El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas.",
        "Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones.",
        "Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar.",
        "Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas.",
        "El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes.",
        "Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos.",
        "Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes.",
        "Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta.",
        "Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos.",
        "Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la solución que maximiza los ingresos cuando los agentes ofrecen sus verdaderas valoraciones.",
        "Dado que PAUSE utiliza subastas inglesas, los precios finales (aproximadamente) representan la segunda valoración más alta, más , para ese conjunto de artículos.",
        "Fijamos el número de agentes en 5 y experimentamos con diferentes cantidades de artículos, concretamente de 2 a 10.",
        "Ejecutamos ambos algoritmos 100 veces para cada combinación.",
        "Cuando comparamos las soluciones de nuestros algoritmos con la solución que maximiza los ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de artículos que la solución que maximiza los ingresos (como se muestra en la Figura 6).",
        "Los casos en los que nuestros algoritmos no lograron llegar a la distribución de la solución que maximiza los ingresos son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos.",
        "Si la solución que maximiza los ingresos contiene la oferta (o ofertas) utilizando estas valoraciones más altas, entonces es imposible que la subasta PAUSE encuentre esta solución porque esa oferta (esas ofertas) nunca se realiza.",
        "Por ejemplo, si el agente i tiene vi(1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces i solo necesita hacer una oferta de 11 para ganar ese artículo.",
        "Si la solución que maximiza los ingresos requiere que 1 se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se realizará.",
        "También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen hacia la solución que maximiza los ingresos disminuye a medida que aumenta el número de elementos.",
        "Para 2 elementos es casi del 100%, pero disminuye un poco menos del 1 por ciento a medida que los elementos aumentan, por lo que este porcentaje promedio de convergencia es alrededor del 90% para 10 elementos.",
        "En algunas ocasiones, nuestros algoritmos encuentran soluciones diferentes debido a The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de elementos en cachéPausaOferta 3 3 3 3 3 3 3 3 3 PausaOferta + + + + + + + + + + Figura 8: Promedio de nodos expandidos (eje y) en función de los elementos en la subasta. orden de las ofertas en la lista de ofertas que hace que se busquen en diferente orden.",
        "Sabemos que los ingresos generados por la subasta de PAUSE suelen ser inferiores a los ingresos de la solución que maximiza los ingresos, pero ¿cuánto más bajos son?",
        "Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos proporcionados por nuestros algoritmos en relación con los ingresos proporcionados por CASS.",
        "Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio un 2.7% a medida que aumenta el número de artículos, como se muestra en la Figura 7.",
        "Sin embargo, descubrimos que cachedpausebid genera un mayor ingreso que pausebid (un 4.3% más en promedio) excepto en subastas con 2 artículos donde ambos tienen aproximadamente el mismo porcentaje.",
        "Nuevamente, esta diferencia es producida por el orden de la búsqueda.",
        "En el caso de 2 artículos, ambos algoritmos generan en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 artículos), cachedpausebid generó en promedio una proporción de ingresos del 91.5%, mientras que pausebid generó en promedio una proporción de ingresos del 87.7%.",
        "La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el árbol de búsqueda.",
        "Para esto contamos el número de veces que se invoca pbsearch cada vez que se llama a pausebid y el número de veces que se invoca fastpausebidsearch cada vez que se llama a cachedpausebid, respectivamente para cada uno de nuestros algoritmos.",
        "Como era de esperar, dado que este es un problema NP-Difícil, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8).",
        "Sin embargo, descubrimos que cachedpausebid supera a pausebid, ya que en promedio expande menos de la mitad del número de nodos.",
        "Por ejemplo, el número promedio de nodos expandidos cuando hay 2 elementos es cero para cachedpausebid, mientras que para pausebid es 2; y en el otro extremo (10 elementos) cachedpausebid se expande en promedio solo 633 nodos, mientras que pausebid se expande en promedio en 1672 nodos, una diferencia de más de 1000 nodos.",
        "Aunque el número de nodos expandidos por nuestros algoritmos aumenta en función del número de elementos, el número real de nodos es mucho menor que el peor escenario de nn donde n es el número de elementos.",
        "Por ejemplo, para 10 artículos expandimos ligeramente más de 103 nodos para el caso de pausebid y menos que eso para el caso de cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de Artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 9: Tiempo promedio en segundos que tarda en finalizar una subasta (eje y) en función del número de artículos en la subasta, que son números mucho menores que 1010.",
        "También hay que tener en cuenta que nuestro algoritmo de generación de valor (Figura 5) genera una cantidad de ofertas que es exponencial en el número de artículos, como podría esperarse en muchas situaciones.",
        "Por lo tanto, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos.",
        "Esperamos que ambos algoritmos crezcan de forma exponencial en función del número de ofertas, pero se mantengan aproximadamente constantes a medida que crece el número de artículos.",
        "Queríamos asegurarnos de que menos nodos expandidos realmente se corresponde con una ejecución más rápida, especialmente dado que nuestros algoritmos ejecutan diferentes operaciones.",
        "Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, un PC portátil Intel Centrino de 2.0 GHz con 1 GB de RAM y un disco duro de 60 GB a 7200 RPM, y calculamos el tiempo promedio que tarda en finalizar una subasta para cada algoritmo.",
        "Como se muestra en la Figura 9, cachedpausebid es más rápido que pausebid, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos.",
        "TRABAJO RELACIONADO Se ha realizado mucha investigación sobre varios aspectos de las subastas combinatorias.",
        "Recomendamos [2] para una buena reseña.",
        "Sin embargo, el estudio de algoritmos distribuidos para la determinación de ganadores en subastas combinatorias todavía es relativamente nuevo.",
        "Un enfoque está dado por los algoritmos para distribuir el problema de determinación del ganador en subastas combinatorias presentados en [7], pero estos algoritmos asumen que las entidades computacionales son los artículos que se están vendiendo y, por lo tanto, terminan con un tipo diferente de distribución.",
        "El algoritmo VSA [3] es otra forma de realizar la determinación distribuida del ganador en una subasta combinatoria, pero asume que las propias ofertas realizan el cálculo.",
        "Este algoritmo también falla en converger hacia una solución en la mayoría de los casos.",
        "En [9] los autores presentan un mecanismo distribuido para calcular los pagos VCG en un problema de diseño de mecanismos.",
        "Su mecanismo se resume aproximadamente en hacer que cada agente calcule los pagos para otros dos agentes y se los entregue a un 700 seguro de The Sixth Intl.",
        "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) tiene un servidor central que luego verifica que los resultados de todos los pares estén de acuerdo; de lo contrario, se ordena una nueva recalcuación.",
        "Esta idea general, a la que llaman principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen.",
        "Otro enfoque interesante se presenta en [8] donde los agentes de oferta priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo centralizado de determinación de ganadores debe considerar, facilitando así ese problema.",
        "Finalmente, en el proceso de cálculo de la subasta de reloj [1], a los agentes se les otorga un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual.",
        "Por lo tanto, asume que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores como asume la subasta PAUSE. 7.",
        "CONCLUSIONES Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entre los postores.",
        "La subasta PAUSE es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en subastas combinatorias.",
        "Con esta subasta, incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador.",
        "Sin embargo, mientras que PAUSE establece las reglas que los licitadores deben obedecer, no nos dice cómo los licitadores deben calcular sus ofertas.",
        "Hemos presentado dos algoritmos, pausebid y cachedpausebid, que los agentes ofertantes pueden utilizar para participar en una subasta de PAUSE.",
        "Ambos algoritmos implementan una estrategia de maximización de utilidad miope que garantiza encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dado el conjunto de mejores ofertas pendientes en cualquier momento, sin considerar posibles ofertas futuras.",
        "Ambos algoritmos encuentran, la mayor parte del tiempo, la misma distribución de elementos que la solución que maximiza los ingresos.",
        "Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de artículos.",
        "Dado que es un problema NP-Difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se invoca. cachedpausebid almacena en caché soluciones parciales y realiza una búsqueda de ramificación y acotación solo en las pocas partes afectadas por los cambios en las ofertas entre tiempos consecutivos. cachedpausebid tiene un mejor rendimiento ya que explora menos nodos (menos de la mitad) y es más rápido.",
        "Como era de esperar, los ingresos generados por una subasta de PAUSE son inferiores a los ingresos de una solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores, sin embargo, descubrimos que cachedpausebid genera en promedio un 4.7% más de ingresos que pausebid.",
        "También descubrimos que los ingresos generados por nuestros algoritmos aumentan en función del número de artículos en la subasta.",
        "Nuestros algoritmos han demostrado que es factible implementar las complejas restricciones de coordinación respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores.",
        "Además, debido al diseño de la subasta PAUSE, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido.",
        "Nuestros algoritmos de oferta pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la coordinación, pero que prefiera no implementar un subastador centralizado. 8.",
        "REFERENCIAS [1] P. J.",
        "Cervecero.",
        "Adquisición descentralizada de computación y robustez computacional en un mercado inteligente.",
        "Teoría Económica, 13(1):41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores.",
        "Subastas combinatorias.",
        "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, y Y. Shoham.",
        "Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados.",
        "En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553.",
        "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg.",
        "Una subasta combinatoria con múltiples ganadores para el servicio universal.",
        "Ciencias de la Gestión, 46(4):586-596, 2000. [5] A.",
        "Land, S. Powell y R. Steinberg.",
        "PAUSA: Una subasta combinatoria computacionalmente viable.",
        "En Cramton et al. [2], capítulo 6, páginas 139-157. [6] K. Leyton-Brown, M. Pearson y Y. Shoham.",
        "Hacia un conjunto de pruebas universal para algoritmos de subasta combinatoria.",
        "En Actas de la 2ª conferencia de la ACM sobre comercio electrónico, páginas 66-76.",
        "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi y J. M. Vidal.",
        "Algoritmos para la determinación distribuida de ganadores en subastas combinatorias.",
        "En el volumen de LNAI de AMEC/TADA.",
        "Springer, 2006. [8] S. Park y M. H. Rothkopf.",
        "Subastas con combinaciones permitidas determinadas endógenamente.",
        "Informe técnico, Centro de Investigación de Operaciones Rutgets, enero de 2001.",
        "RRR 3-2001. [9] D. C. Parkes y J. Shneidman.",
        "Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves.",
        "En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 261-268.",
        "ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad.",
        "Subastas combinatorias manejables computacionalmente.",
        "Ciencia de la Gestión, 44(8):1131-1147, 1998. [11] T. Sandholm.",
        "Un algoritmo para la determinación del ganador en subastas combinatorias.",
        "Inteligencia Artificial, 135(1-2):1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine.",
        "CABOB: un algoritmo óptimo y rápido para la determinación del ganador en subastas combinatorias.",
        "Ciencia de la Gestión, 51(3):374-391, 2005.",
        "La Sexta Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 701"
    ],
    "error_count": 6,
    "keys": {
        "distributed allocation": {
            "translated_key": "asignación distribuida",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT <br>distributed allocation</br> and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT <br>distributed allocation</br> and multiagent coordination problems can be solved through combinatorial auctions."
            ],
            "translated_annotated_samples": [
                "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de <br>asignación distribuida</br> y coordinación multiagente pueden resolverse a través de subastas combinatorias."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de <br>asignación distribuida</br> y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes. Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta. Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos. Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la solución que maximiza los ingresos cuando los agentes ofrecen sus verdaderas valoraciones. Dado que PAUSE utiliza subastas inglesas, los precios finales (aproximadamente) representan la segunda valoración más alta, más , para ese conjunto de artículos. Fijamos el número de agentes en 5 y experimentamos con diferentes cantidades de artículos, concretamente de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución que maximiza los ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de artículos que la solución que maximiza los ingresos (como se muestra en la Figura 6). Los casos en los que nuestros algoritmos no lograron llegar a la distribución de la solución que maximiza los ingresos son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución que maximiza los ingresos contiene la oferta (o ofertas) utilizando estas valoraciones más altas, entonces es imposible que la subasta PAUSE encuentre esta solución porque esa oferta (esas ofertas) nunca se realiza. Por ejemplo, si el agente i tiene vi(1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces i solo necesita hacer una oferta de 11 para ganar ese artículo. Si la solución que maximiza los ingresos requiere que 1 se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se realizará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen hacia la solución que maximiza los ingresos disminuye a medida que aumenta el número de elementos. Para 2 elementos es casi del 100%, pero disminuye un poco menos del 1 por ciento a medida que los elementos aumentan, por lo que este porcentaje promedio de convergencia es alrededor del 90% para 10 elementos. En algunas ocasiones, nuestros algoritmos encuentran soluciones diferentes debido a The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de elementos en cachéPausaOferta 3 3 3 3 3 3 3 3 3 PausaOferta + + + + + + + + + + Figura 8: Promedio de nodos expandidos (eje y) en función de los elementos en la subasta. orden de las ofertas en la lista de ofertas que hace que se busquen en diferente orden. Sabemos que los ingresos generados por la subasta de PAUSE suelen ser inferiores a los ingresos de la solución que maximiza los ingresos, pero ¿cuánto más bajos son? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos proporcionados por nuestros algoritmos en relación con los ingresos proporcionados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio un 2.7% a medida que aumenta el número de artículos, como se muestra en la Figura 7. Sin embargo, descubrimos que cachedpausebid genera un mayor ingreso que pausebid (un 4.3% más en promedio) excepto en subastas con 2 artículos donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 artículos, ambos algoritmos generan en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 artículos), cachedpausebid generó en promedio una proporción de ingresos del 91.5%, mientras que pausebid generó en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el árbol de búsqueda. Para esto contamos el número de veces que se invoca pbsearch cada vez que se llama a pausebid y el número de veces que se invoca fastpausebidsearch cada vez que se llama a cachedpausebid, respectivamente para cada uno de nuestros algoritmos. Como era de esperar, dado que este es un problema NP-Difícil, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que cachedpausebid supera a pausebid, ya que en promedio expande menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos expandidos cuando hay 2 elementos es cero para cachedpausebid, mientras que para pausebid es 2; y en el otro extremo (10 elementos) cachedpausebid se expande en promedio solo 633 nodos, mientras que pausebid se expande en promedio en 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta en función del número de elementos, el número real de nodos es mucho menor que el peor escenario de nn donde n es el número de elementos. Por ejemplo, para 10 artículos expandimos ligeramente más de 103 nodos para el caso de pausebid y menos que eso para el caso de cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de Artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 9: Tiempo promedio en segundos que tarda en finalizar una subasta (eje y) en función del número de artículos en la subasta, que son números mucho menores que 1010. También hay que tener en cuenta que nuestro algoritmo de generación de valor (Figura 5) genera una cantidad de ofertas que es exponencial en el número de artículos, como podría esperarse en muchas situaciones. Por lo tanto, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan de forma exponencial en función del número de ofertas, pero se mantengan aproximadamente constantes a medida que crece el número de artículos. Queríamos asegurarnos de que menos nodos expandidos realmente se corresponde con una ejecución más rápida, especialmente dado que nuestros algoritmos ejecutan diferentes operaciones. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, un PC portátil Intel Centrino de 2.0 GHz con 1 GB de RAM y un disco duro de 60 GB a 7200 RPM, y calculamos el tiempo promedio que tarda en finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, cachedpausebid es más rápido que pausebid, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos. TRABAJO RELACIONADO Se ha realizado mucha investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena reseña. Sin embargo, el estudio de algoritmos distribuidos para la determinación de ganadores en subastas combinatorias todavía es relativamente nuevo. Un enfoque está dado por los algoritmos para distribuir el problema de determinación del ganador en subastas combinatorias presentados en [7], pero estos algoritmos asumen que las entidades computacionales son los artículos que se están vendiendo y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación distribuida del ganador en una subasta combinatoria, pero asume que las propias ofertas realizan el cálculo. Este algoritmo también falla en converger hacia una solución en la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos VCG en un problema de diseño de mecanismos. Su mecanismo se resume aproximadamente en hacer que cada agente calcule los pagos para otros dos agentes y se los entregue a un 700 seguro de The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) tiene un servidor central que luego verifica que los resultados de todos los pares estén de acuerdo; de lo contrario, se ordena una nueva recalcuación. Esta idea general, a la que llaman principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se presenta en [8] donde los agentes de oferta priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo centralizado de determinación de ganadores debe considerar, facilitando así ese problema. Finalmente, en el proceso de cálculo de la subasta de reloj [1], a los agentes se les otorga un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Por lo tanto, asume que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores como asume la subasta PAUSE. 7. CONCLUSIONES Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entre los postores. La subasta PAUSE es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en subastas combinatorias. Con esta subasta, incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Sin embargo, mientras que PAUSE establece las reglas que los licitadores deben obedecer, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos presentado dos algoritmos, pausebid y cachedpausebid, que los agentes ofertantes pueden utilizar para participar en una subasta de PAUSE. Ambos algoritmos implementan una estrategia de maximización de utilidad miope que garantiza encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dado el conjunto de mejores ofertas pendientes en cualquier momento, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayor parte del tiempo, la misma distribución de elementos que la solución que maximiza los ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de artículos. Dado que es un problema NP-Difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se invoca. cachedpausebid almacena en caché soluciones parciales y realiza una búsqueda de ramificación y acotación solo en las pocas partes afectadas por los cambios en las ofertas entre tiempos consecutivos. cachedpausebid tiene un mejor rendimiento ya que explora menos nodos (menos de la mitad) y es más rápido. Como era de esperar, los ingresos generados por una subasta de PAUSE son inferiores a los ingresos de una solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores, sin embargo, descubrimos que cachedpausebid genera en promedio un 4.7% más de ingresos que pausebid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan en función del número de artículos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas restricciones de coordinación respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores. Además, debido al diseño de la subasta PAUSE, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros algoritmos de oferta pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la coordinación, pero que prefiera no implementar un subastador centralizado. 8. REFERENCIAS [1] P. J. Cervecero. Adquisición descentralizada de computación y robustez computacional en un mercado inteligente. Teoría Económica, 13(1):41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. Subastas combinatorias. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Ciencias de la Gestión, 46(4):586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. PAUSA: Una subasta combinatoria computacionalmente viable. En Cramton et al. [2], capítulo 6, páginas 139-157. [6] K. Leyton-Brown, M. Pearson y Y. Shoham. Hacia un conjunto de pruebas universal para algoritmos de subasta combinatoria. En Actas de la 2ª conferencia de la ACM sobre comercio electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación distribuida de ganadores en subastas combinatorias. En el volumen de LNAI de AMEC/TADA. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas determinadas endógenamente. Informe técnico, Centro de Investigación de Operaciones Rutgets, enero de 2001. RRR 3-2001. [9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo y rápido para la determinación del ganador en subastas combinatorias. Ciencia de la Gestión, 51(3):374-391, 2005. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 701 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "combinatorial auction": {
            "translated_key": "subasta combinatoria",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed <br>combinatorial auction</br> Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price <br>combinatorial auction</br> that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a <br>combinatorial auction</br> bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional <br>combinatorial auction</br> where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a <br>combinatorial auction</br> but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in <br>combinatorial auction</br> but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A <br>combinatorial auction</br> with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable <br>combinatorial auction</br>.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for <br>combinatorial auction</br> algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "Bidding Algorithms for a Distributed <br>combinatorial auction</br> Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "It is an increasing price <br>combinatorial auction</br> that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "In a <br>combinatorial auction</br> bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "That is, the final prices will not be the same as the prices in a traditional <br>combinatorial auction</br> where all the bidders bid their true valuation.",
                "It is as if you were told the set of bids placed in a <br>combinatorial auction</br> but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms."
            ],
            "translated_annotated_samples": [
                "Algoritmos de subasta para una <br>subasta combinatoria</br> distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias.",
                "Es una <br>subasta combinatoria</br> de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo.",
                "En una <br>subasta combinatoria</br>, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales.",
                "Es decir, los precios finales no serán los mismos que los precios en una <br>subasta combinatoria</br> tradicional donde todos los postores ofrecen su verdadera valoración.",
                "Es como si te dijeran el conjunto de ofertas realizadas en una <br>subasta combinatoria</br>, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos."
            ],
            "translated_text": "Algoritmos de subasta para una <br>subasta combinatoria</br> distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una <br>subasta combinatoria</br> de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una <br>subasta combinatoria</br>, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una <br>subasta combinatoria</br> tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una <br>subasta combinatoria</br>, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "coordination": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent <br>coordination</br> problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex <br>coordination</br> constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for <br>coordination</br> but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent <br>coordination</br> problems can be solved through combinatorial auctions.",
                "Our algorithms have shown that it is feasible to implement the complex <br>coordination</br> constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for <br>coordination</br> but would rather not implement a centralized auctioneer. 8."
            ],
            "translated_annotated_samples": [
                "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y <br>coordinación</br> multiagente pueden resolverse a través de subastas combinatorias.",
                "Nuestros algoritmos han demostrado que es factible implementar las complejas <br>restricciones de coordinación</br> respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores.",
                "Nuestros algoritmos de oferta pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la <br>coordinación</br>, pero que prefiera no implementar un subastador centralizado. 8."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y <br>coordinación</br> multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes. Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta. Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos. Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la solución que maximiza los ingresos cuando los agentes ofrecen sus verdaderas valoraciones. Dado que PAUSE utiliza subastas inglesas, los precios finales (aproximadamente) representan la segunda valoración más alta, más , para ese conjunto de artículos. Fijamos el número de agentes en 5 y experimentamos con diferentes cantidades de artículos, concretamente de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución que maximiza los ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de artículos que la solución que maximiza los ingresos (como se muestra en la Figura 6). Los casos en los que nuestros algoritmos no lograron llegar a la distribución de la solución que maximiza los ingresos son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución que maximiza los ingresos contiene la oferta (o ofertas) utilizando estas valoraciones más altas, entonces es imposible que la subasta PAUSE encuentre esta solución porque esa oferta (esas ofertas) nunca se realiza. Por ejemplo, si el agente i tiene vi(1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces i solo necesita hacer una oferta de 11 para ganar ese artículo. Si la solución que maximiza los ingresos requiere que 1 se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se realizará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen hacia la solución que maximiza los ingresos disminuye a medida que aumenta el número de elementos. Para 2 elementos es casi del 100%, pero disminuye un poco menos del 1 por ciento a medida que los elementos aumentan, por lo que este porcentaje promedio de convergencia es alrededor del 90% para 10 elementos. En algunas ocasiones, nuestros algoritmos encuentran soluciones diferentes debido a The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de elementos en cachéPausaOferta 3 3 3 3 3 3 3 3 3 PausaOferta + + + + + + + + + + Figura 8: Promedio de nodos expandidos (eje y) en función de los elementos en la subasta. orden de las ofertas en la lista de ofertas que hace que se busquen en diferente orden. Sabemos que los ingresos generados por la subasta de PAUSE suelen ser inferiores a los ingresos de la solución que maximiza los ingresos, pero ¿cuánto más bajos son? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos proporcionados por nuestros algoritmos en relación con los ingresos proporcionados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio un 2.7% a medida que aumenta el número de artículos, como se muestra en la Figura 7. Sin embargo, descubrimos que cachedpausebid genera un mayor ingreso que pausebid (un 4.3% más en promedio) excepto en subastas con 2 artículos donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 artículos, ambos algoritmos generan en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 artículos), cachedpausebid generó en promedio una proporción de ingresos del 91.5%, mientras que pausebid generó en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el árbol de búsqueda. Para esto contamos el número de veces que se invoca pbsearch cada vez que se llama a pausebid y el número de veces que se invoca fastpausebidsearch cada vez que se llama a cachedpausebid, respectivamente para cada uno de nuestros algoritmos. Como era de esperar, dado que este es un problema NP-Difícil, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que cachedpausebid supera a pausebid, ya que en promedio expande menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos expandidos cuando hay 2 elementos es cero para cachedpausebid, mientras que para pausebid es 2; y en el otro extremo (10 elementos) cachedpausebid se expande en promedio solo 633 nodos, mientras que pausebid se expande en promedio en 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta en función del número de elementos, el número real de nodos es mucho menor que el peor escenario de nn donde n es el número de elementos. Por ejemplo, para 10 artículos expandimos ligeramente más de 103 nodos para el caso de pausebid y menos que eso para el caso de cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de Artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 9: Tiempo promedio en segundos que tarda en finalizar una subasta (eje y) en función del número de artículos en la subasta, que son números mucho menores que 1010. También hay que tener en cuenta que nuestro algoritmo de generación de valor (Figura 5) genera una cantidad de ofertas que es exponencial en el número de artículos, como podría esperarse en muchas situaciones. Por lo tanto, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan de forma exponencial en función del número de ofertas, pero se mantengan aproximadamente constantes a medida que crece el número de artículos. Queríamos asegurarnos de que menos nodos expandidos realmente se corresponde con una ejecución más rápida, especialmente dado que nuestros algoritmos ejecutan diferentes operaciones. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, un PC portátil Intel Centrino de 2.0 GHz con 1 GB de RAM y un disco duro de 60 GB a 7200 RPM, y calculamos el tiempo promedio que tarda en finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, cachedpausebid es más rápido que pausebid, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos. TRABAJO RELACIONADO Se ha realizado mucha investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena reseña. Sin embargo, el estudio de algoritmos distribuidos para la determinación de ganadores en subastas combinatorias todavía es relativamente nuevo. Un enfoque está dado por los algoritmos para distribuir el problema de determinación del ganador en subastas combinatorias presentados en [7], pero estos algoritmos asumen que las entidades computacionales son los artículos que se están vendiendo y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación distribuida del ganador en una subasta combinatoria, pero asume que las propias ofertas realizan el cálculo. Este algoritmo también falla en converger hacia una solución en la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos VCG en un problema de diseño de mecanismos. Su mecanismo se resume aproximadamente en hacer que cada agente calcule los pagos para otros dos agentes y se los entregue a un 700 seguro de The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) tiene un servidor central que luego verifica que los resultados de todos los pares estén de acuerdo; de lo contrario, se ordena una nueva recalcuación. Esta idea general, a la que llaman principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se presenta en [8] donde los agentes de oferta priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo centralizado de determinación de ganadores debe considerar, facilitando así ese problema. Finalmente, en el proceso de cálculo de la subasta de reloj [1], a los agentes se les otorga un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Por lo tanto, asume que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores como asume la subasta PAUSE. 7. CONCLUSIONES Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entre los postores. La subasta PAUSE es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en subastas combinatorias. Con esta subasta, incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Sin embargo, mientras que PAUSE establece las reglas que los licitadores deben obedecer, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos presentado dos algoritmos, pausebid y cachedpausebid, que los agentes ofertantes pueden utilizar para participar en una subasta de PAUSE. Ambos algoritmos implementan una estrategia de maximización de utilidad miope que garantiza encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dado el conjunto de mejores ofertas pendientes en cualquier momento, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayor parte del tiempo, la misma distribución de elementos que la solución que maximiza los ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de artículos. Dado que es un problema NP-Difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se invoca. cachedpausebid almacena en caché soluciones parciales y realiza una búsqueda de ramificación y acotación solo en las pocas partes afectadas por los cambios en las ofertas entre tiempos consecutivos. cachedpausebid tiene un mejor rendimiento ya que explora menos nodos (menos de la mitad) y es más rápido. Como era de esperar, los ingresos generados por una subasta de PAUSE son inferiores a los ingresos de una solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores, sin embargo, descubrimos que cachedpausebid genera en promedio un 4.7% más de ingresos que pausebid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan en función del número de artículos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas <br>restricciones de coordinación</br> respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores. Además, debido al diseño de la subasta PAUSE, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros algoritmos de oferta pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la <br>coordinación</br>, pero que prefiera no implementar un subastador centralizado. 8. REFERENCIAS [1] P. J. Cervecero. Adquisición descentralizada de computación y robustez computacional en un mercado inteligente. Teoría Económica, 13(1):41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. Subastas combinatorias. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Ciencias de la Gestión, 46(4):586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. PAUSA: Una subasta combinatoria computacionalmente viable. En Cramton et al. [2], capítulo 6, páginas 139-157. [6] K. Leyton-Brown, M. Pearson y Y. Shoham. Hacia un conjunto de pruebas universal para algoritmos de subasta combinatoria. En Actas de la 2ª conferencia de la ACM sobre comercio electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación distribuida de ganadores en subastas combinatorias. En el volumen de LNAI de AMEC/TADA. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas determinadas endógenamente. Informe técnico, Centro de Investigación de Operaciones Rutgets, enero de 2001. RRR 3-2001. [9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo y rápido para la determinación del ganador en subastas combinatorias. Ciencia de la Gestión, 51(3):374-391, 2005. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 701 ",
            "candidates": [],
            "error": [
                [
                    "coordinación",
                    "restricciones de coordinación",
                    "coordinación"
                ]
            ]
        },
        "task and resource allocation": {
            "translated_key": "Asignación de tareas y recursos",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "bidding algorithm": {
            "translated_key": "algoritmos de oferta",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of <br>bidding algorithm</br>s for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our <br>bidding algorithm</br>s, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our <br>bidding algorithm</br>s can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "We have developed a couple of <br>bidding algorithm</br>s for the bidders in a PAUSE auction.",
                "In this paper we present our <br>bidding algorithm</br>s, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Our <br>bidding algorithm</br>s can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8."
            ],
            "translated_annotated_samples": [
                "Hemos desarrollado un par de <br>algoritmos de oferta</br> para los postores en una subasta de PAUSE.",
                "En este documento presentamos nuestros <br>algoritmos de oferta</br>, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores.",
                "Nuestros <br>algoritmos de oferta</br> pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la coordinación, pero que prefiera no implementar un subastador centralizado. 8."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de <br>algoritmos de oferta</br> para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros <br>algoritmos de oferta</br>, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes. Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta. Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos. Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la solución que maximiza los ingresos cuando los agentes ofrecen sus verdaderas valoraciones. Dado que PAUSE utiliza subastas inglesas, los precios finales (aproximadamente) representan la segunda valoración más alta, más , para ese conjunto de artículos. Fijamos el número de agentes en 5 y experimentamos con diferentes cantidades de artículos, concretamente de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución que maximiza los ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de artículos que la solución que maximiza los ingresos (como se muestra en la Figura 6). Los casos en los que nuestros algoritmos no lograron llegar a la distribución de la solución que maximiza los ingresos son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución que maximiza los ingresos contiene la oferta (o ofertas) utilizando estas valoraciones más altas, entonces es imposible que la subasta PAUSE encuentre esta solución porque esa oferta (esas ofertas) nunca se realiza. Por ejemplo, si el agente i tiene vi(1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces i solo necesita hacer una oferta de 11 para ganar ese artículo. Si la solución que maximiza los ingresos requiere que 1 se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se realizará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen hacia la solución que maximiza los ingresos disminuye a medida que aumenta el número de elementos. Para 2 elementos es casi del 100%, pero disminuye un poco menos del 1 por ciento a medida que los elementos aumentan, por lo que este porcentaje promedio de convergencia es alrededor del 90% para 10 elementos. En algunas ocasiones, nuestros algoritmos encuentran soluciones diferentes debido a The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de elementos en cachéPausaOferta 3 3 3 3 3 3 3 3 3 PausaOferta + + + + + + + + + + Figura 8: Promedio de nodos expandidos (eje y) en función de los elementos en la subasta. orden de las ofertas en la lista de ofertas que hace que se busquen en diferente orden. Sabemos que los ingresos generados por la subasta de PAUSE suelen ser inferiores a los ingresos de la solución que maximiza los ingresos, pero ¿cuánto más bajos son? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos proporcionados por nuestros algoritmos en relación con los ingresos proporcionados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio un 2.7% a medida que aumenta el número de artículos, como se muestra en la Figura 7. Sin embargo, descubrimos que cachedpausebid genera un mayor ingreso que pausebid (un 4.3% más en promedio) excepto en subastas con 2 artículos donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 artículos, ambos algoritmos generan en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 artículos), cachedpausebid generó en promedio una proporción de ingresos del 91.5%, mientras que pausebid generó en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el árbol de búsqueda. Para esto contamos el número de veces que se invoca pbsearch cada vez que se llama a pausebid y el número de veces que se invoca fastpausebidsearch cada vez que se llama a cachedpausebid, respectivamente para cada uno de nuestros algoritmos. Como era de esperar, dado que este es un problema NP-Difícil, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que cachedpausebid supera a pausebid, ya que en promedio expande menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos expandidos cuando hay 2 elementos es cero para cachedpausebid, mientras que para pausebid es 2; y en el otro extremo (10 elementos) cachedpausebid se expande en promedio solo 633 nodos, mientras que pausebid se expande en promedio en 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta en función del número de elementos, el número real de nodos es mucho menor que el peor escenario de nn donde n es el número de elementos. Por ejemplo, para 10 artículos expandimos ligeramente más de 103 nodos para el caso de pausebid y menos que eso para el caso de cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de Artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 9: Tiempo promedio en segundos que tarda en finalizar una subasta (eje y) en función del número de artículos en la subasta, que son números mucho menores que 1010. También hay que tener en cuenta que nuestro algoritmo de generación de valor (Figura 5) genera una cantidad de ofertas que es exponencial en el número de artículos, como podría esperarse en muchas situaciones. Por lo tanto, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan de forma exponencial en función del número de ofertas, pero se mantengan aproximadamente constantes a medida que crece el número de artículos. Queríamos asegurarnos de que menos nodos expandidos realmente se corresponde con una ejecución más rápida, especialmente dado que nuestros algoritmos ejecutan diferentes operaciones. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, un PC portátil Intel Centrino de 2.0 GHz con 1 GB de RAM y un disco duro de 60 GB a 7200 RPM, y calculamos el tiempo promedio que tarda en finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, cachedpausebid es más rápido que pausebid, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos. TRABAJO RELACIONADO Se ha realizado mucha investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena reseña. Sin embargo, el estudio de algoritmos distribuidos para la determinación de ganadores en subastas combinatorias todavía es relativamente nuevo. Un enfoque está dado por los algoritmos para distribuir el problema de determinación del ganador en subastas combinatorias presentados en [7], pero estos algoritmos asumen que las entidades computacionales son los artículos que se están vendiendo y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación distribuida del ganador en una subasta combinatoria, pero asume que las propias ofertas realizan el cálculo. Este algoritmo también falla en converger hacia una solución en la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos VCG en un problema de diseño de mecanismos. Su mecanismo se resume aproximadamente en hacer que cada agente calcule los pagos para otros dos agentes y se los entregue a un 700 seguro de The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) tiene un servidor central que luego verifica que los resultados de todos los pares estén de acuerdo; de lo contrario, se ordena una nueva recalcuación. Esta idea general, a la que llaman principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se presenta en [8] donde los agentes de oferta priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo centralizado de determinación de ganadores debe considerar, facilitando así ese problema. Finalmente, en el proceso de cálculo de la subasta de reloj [1], a los agentes se les otorga un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Por lo tanto, asume que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores como asume la subasta PAUSE. 7. CONCLUSIONES Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entre los postores. La subasta PAUSE es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en subastas combinatorias. Con esta subasta, incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Sin embargo, mientras que PAUSE establece las reglas que los licitadores deben obedecer, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos presentado dos algoritmos, pausebid y cachedpausebid, que los agentes ofertantes pueden utilizar para participar en una subasta de PAUSE. Ambos algoritmos implementan una estrategia de maximización de utilidad miope que garantiza encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dado el conjunto de mejores ofertas pendientes en cualquier momento, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayor parte del tiempo, la misma distribución de elementos que la solución que maximiza los ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de artículos. Dado que es un problema NP-Difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se invoca. cachedpausebid almacena en caché soluciones parciales y realiza una búsqueda de ramificación y acotación solo en las pocas partes afectadas por los cambios en las ofertas entre tiempos consecutivos. cachedpausebid tiene un mejor rendimiento ya que explora menos nodos (menos de la mitad) y es más rápido. Como era de esperar, los ingresos generados por una subasta de PAUSE son inferiores a los ingresos de una solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores, sin embargo, descubrimos que cachedpausebid genera en promedio un 4.7% más de ingresos que pausebid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan en función del número de artículos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas restricciones de coordinación respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores. Además, debido al diseño de la subasta PAUSE, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros <br>algoritmos de oferta</br> pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la coordinación, pero que prefiera no implementar un subastador centralizado. 8. REFERENCIAS [1] P. J. Cervecero. Adquisición descentralizada de computación y robustez computacional en un mercado inteligente. Teoría Económica, 13(1):41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. Subastas combinatorias. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Ciencias de la Gestión, 46(4):586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. PAUSA: Una subasta combinatoria computacionalmente viable. En Cramton et al. [2], capítulo 6, páginas 139-157. [6] K. Leyton-Brown, M. Pearson y Y. Shoham. Hacia un conjunto de pruebas universal para algoritmos de subasta combinatoria. En Actas de la 2ª conferencia de la ACM sobre comercio electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación distribuida de ganadores en subastas combinatorias. En el volumen de LNAI de AMEC/TADA. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas determinadas endógenamente. Informe técnico, Centro de Investigación de Operaciones Rutgets, enero de 2001. RRR 3-2001. [9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo y rápido para la determinación del ganador en subastas combinatorias. Ciencia de la Gestión, 51(3):374-391, 2005. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 701 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "revenue-maximizing solution": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the <br>revenue-maximizing solution</br> found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the <br>revenue-maximizing solution</br>, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the <br>revenue-maximizing solution</br> and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the <br>revenue-maximizing solution</br> as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the <br>revenue-maximizing solution</br> when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the <br>revenue-maximizing solution</br>, we realized that they do not always find the same distribution of items as the <br>revenue-maximizing solution</br> (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the <br>revenue-maximizing solution</br> are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the <br>revenue-maximizing solution</br> contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the <br>revenue-maximizing solution</br> requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the <br>revenue-maximizing solution</br> decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the <br>revenue-maximizing solution</br>.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a <br>revenue-maximizing solution</br> found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the <br>revenue-maximizing solution</br> found by a centralized winner determination algorithm.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the <br>revenue-maximizing solution</br>, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the <br>revenue-maximizing solution</br> and how their times compare with each other.",
                "We then compared the solutions found by both of them to the <br>revenue-maximizing solution</br> as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the <br>revenue-maximizing solution</br> when the agents bid their true valuations."
            ],
            "translated_annotated_samples": [
                "En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la <br>solución de maximización de ingresos</br> encontrada por un algoritmo centralizado de determinación de ganadores.",
                "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la <br>solución que maximiza los ingresos</br>, en función del número de items en la subasta. 5.",
                "PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la <br>solución que maximiza los ingresos</br> y cómo sus tiempos se comparan entre sí.",
                "Luego comparamos las soluciones encontradas por ambos con la <br>solución de maximización de ingresos</br> encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes.",
                "Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la <br>solución que maximiza los ingresos</br> cuando los agentes ofrecen sus verdaderas valoraciones."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la <br>solución de maximización de ingresos</br> encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la <br>solución que maximiza los ingresos</br>, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la <br>solución que maximiza los ingresos</br> y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la <br>solución de maximización de ingresos</br> encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes. Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta. Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos. Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la <br>solución que maximiza los ingresos</br> cuando los agentes ofrecen sus verdaderas valoraciones. ",
            "candidates": [],
            "error": [
                [
                    "solución de maximización de ingresos",
                    "solución que maximiza los ingresos",
                    "solución que maximiza los ingresos",
                    "solución de maximización de ingresos",
                    "solución que maximiza los ingresos"
                ]
            ]
        },
        "combinatorial optimization problem": {
            "translated_key": "problema de optimización combinatoria",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a <br>combinatorial optimization problem</br> and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "This problem, known as the winner determination problem, is a <br>combinatorial optimization problem</br> and is NP-Hard [10]."
            ],
            "translated_annotated_samples": [
                "Este problema, conocido como el problema de determinación del ganador, es un <br>problema de optimización combinatoria</br> y es NP-Difícil [10]."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un <br>problema de optimización combinatoria</br> y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes. Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta. Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos. Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la solución que maximiza los ingresos cuando los agentes ofrecen sus verdaderas valoraciones. Dado que PAUSE utiliza subastas inglesas, los precios finales (aproximadamente) representan la segunda valoración más alta, más , para ese conjunto de artículos. Fijamos el número de agentes en 5 y experimentamos con diferentes cantidades de artículos, concretamente de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución que maximiza los ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de artículos que la solución que maximiza los ingresos (como se muestra en la Figura 6). Los casos en los que nuestros algoritmos no lograron llegar a la distribución de la solución que maximiza los ingresos son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución que maximiza los ingresos contiene la oferta (o ofertas) utilizando estas valoraciones más altas, entonces es imposible que la subasta PAUSE encuentre esta solución porque esa oferta (esas ofertas) nunca se realiza. Por ejemplo, si el agente i tiene vi(1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces i solo necesita hacer una oferta de 11 para ganar ese artículo. Si la solución que maximiza los ingresos requiere que 1 se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se realizará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen hacia la solución que maximiza los ingresos disminuye a medida que aumenta el número de elementos. Para 2 elementos es casi del 100%, pero disminuye un poco menos del 1 por ciento a medida que los elementos aumentan, por lo que este porcentaje promedio de convergencia es alrededor del 90% para 10 elementos. En algunas ocasiones, nuestros algoritmos encuentran soluciones diferentes debido a The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de elementos en cachéPausaOferta 3 3 3 3 3 3 3 3 3 PausaOferta + + + + + + + + + + Figura 8: Promedio de nodos expandidos (eje y) en función de los elementos en la subasta. orden de las ofertas en la lista de ofertas que hace que se busquen en diferente orden. Sabemos que los ingresos generados por la subasta de PAUSE suelen ser inferiores a los ingresos de la solución que maximiza los ingresos, pero ¿cuánto más bajos son? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos proporcionados por nuestros algoritmos en relación con los ingresos proporcionados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio un 2.7% a medida que aumenta el número de artículos, como se muestra en la Figura 7. Sin embargo, descubrimos que cachedpausebid genera un mayor ingreso que pausebid (un 4.3% más en promedio) excepto en subastas con 2 artículos donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 artículos, ambos algoritmos generan en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 artículos), cachedpausebid generó en promedio una proporción de ingresos del 91.5%, mientras que pausebid generó en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el árbol de búsqueda. Para esto contamos el número de veces que se invoca pbsearch cada vez que se llama a pausebid y el número de veces que se invoca fastpausebidsearch cada vez que se llama a cachedpausebid, respectivamente para cada uno de nuestros algoritmos. Como era de esperar, dado que este es un problema NP-Difícil, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que cachedpausebid supera a pausebid, ya que en promedio expande menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos expandidos cuando hay 2 elementos es cero para cachedpausebid, mientras que para pausebid es 2; y en el otro extremo (10 elementos) cachedpausebid se expande en promedio solo 633 nodos, mientras que pausebid se expande en promedio en 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta en función del número de elementos, el número real de nodos es mucho menor que el peor escenario de nn donde n es el número de elementos. Por ejemplo, para 10 artículos expandimos ligeramente más de 103 nodos para el caso de pausebid y menos que eso para el caso de cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de Artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 9: Tiempo promedio en segundos que tarda en finalizar una subasta (eje y) en función del número de artículos en la subasta, que son números mucho menores que 1010. También hay que tener en cuenta que nuestro algoritmo de generación de valor (Figura 5) genera una cantidad de ofertas que es exponencial en el número de artículos, como podría esperarse en muchas situaciones. Por lo tanto, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan de forma exponencial en función del número de ofertas, pero se mantengan aproximadamente constantes a medida que crece el número de artículos. Queríamos asegurarnos de que menos nodos expandidos realmente se corresponde con una ejecución más rápida, especialmente dado que nuestros algoritmos ejecutan diferentes operaciones. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, un PC portátil Intel Centrino de 2.0 GHz con 1 GB de RAM y un disco duro de 60 GB a 7200 RPM, y calculamos el tiempo promedio que tarda en finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, cachedpausebid es más rápido que pausebid, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos. TRABAJO RELACIONADO Se ha realizado mucha investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena reseña. Sin embargo, el estudio de algoritmos distribuidos para la determinación de ganadores en subastas combinatorias todavía es relativamente nuevo. Un enfoque está dado por los algoritmos para distribuir el problema de determinación del ganador en subastas combinatorias presentados en [7], pero estos algoritmos asumen que las entidades computacionales son los artículos que se están vendiendo y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación distribuida del ganador en una subasta combinatoria, pero asume que las propias ofertas realizan el cálculo. Este algoritmo también falla en converger hacia una solución en la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos VCG en un problema de diseño de mecanismos. Su mecanismo se resume aproximadamente en hacer que cada agente calcule los pagos para otros dos agentes y se los entregue a un 700 seguro de The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) tiene un servidor central que luego verifica que los resultados de todos los pares estén de acuerdo; de lo contrario, se ordena una nueva recalcuación. Esta idea general, a la que llaman principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se presenta en [8] donde los agentes de oferta priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo centralizado de determinación de ganadores debe considerar, facilitando así ese problema. Finalmente, en el proceso de cálculo de la subasta de reloj [1], a los agentes se les otorga un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Por lo tanto, asume que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores como asume la subasta PAUSE. 7. CONCLUSIONES Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entre los postores. La subasta PAUSE es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en subastas combinatorias. Con esta subasta, incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Sin embargo, mientras que PAUSE establece las reglas que los licitadores deben obedecer, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos presentado dos algoritmos, pausebid y cachedpausebid, que los agentes ofertantes pueden utilizar para participar en una subasta de PAUSE. Ambos algoritmos implementan una estrategia de maximización de utilidad miope que garantiza encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dado el conjunto de mejores ofertas pendientes en cualquier momento, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayor parte del tiempo, la misma distribución de elementos que la solución que maximiza los ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de artículos. Dado que es un problema NP-Difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se invoca. cachedpausebid almacena en caché soluciones parciales y realiza una búsqueda de ramificación y acotación solo en las pocas partes afectadas por los cambios en las ofertas entre tiempos consecutivos. cachedpausebid tiene un mejor rendimiento ya que explora menos nodos (menos de la mitad) y es más rápido. Como era de esperar, los ingresos generados por una subasta de PAUSE son inferiores a los ingresos de una solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores, sin embargo, descubrimos que cachedpausebid genera en promedio un 4.7% más de ingresos que pausebid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan en función del número de artículos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas restricciones de coordinación respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores. Además, debido al diseño de la subasta PAUSE, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros algoritmos de oferta pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la coordinación, pero que prefiera no implementar un subastador centralizado. 8. REFERENCIAS [1] P. J. Cervecero. Adquisición descentralizada de computación y robustez computacional en un mercado inteligente. Teoría Económica, 13(1):41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. Subastas combinatorias. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Ciencias de la Gestión, 46(4):586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. PAUSA: Una subasta combinatoria computacionalmente viable. En Cramton et al. [2], capítulo 6, páginas 139-157. [6] K. Leyton-Brown, M. Pearson y Y. Shoham. Hacia un conjunto de pruebas universal para algoritmos de subasta combinatoria. En Actas de la 2ª conferencia de la ACM sobre comercio electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación distribuida de ganadores en subastas combinatorias. En el volumen de LNAI de AMEC/TADA. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas determinadas endógenamente. Informe técnico, Centro de Investigación de Operaciones Rutgets, enero de 2001. RRR 3-2001. [9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo y rápido para la determinación del ganador en subastas combinatorias. Ciencia de la Gestión, 51(3):374-391, 2005. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 701 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "agent": {
            "translated_key": "agente",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no <br>agent</br> can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each <br>agent</br> must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the <br>agent</br> needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each <br>agent</br> also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every <br>agent</br> perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an <br>agent</br> receives a bid from another <br>agent</br> it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every <br>agent</br> (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the <br>agent</br> itself.",
                "Anyone claiming a higher value for some other <br>agent</br> is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each <br>agent</br>. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the <br>agent</br> that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) <br>agent</br> is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the <br>agent</br> is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, <br>agent</br> i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the <br>agent</br> i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the <br>agent</br> and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The <br>agent</br> can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the <br>agent</br> can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the <br>agent</br> currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the <br>agent</br> can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the <br>agent</br> is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an <br>agent</br> has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) <br>agent</br>.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the <br>agent</br> has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the <br>agent</br> has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes <br>agent</br> is utility.",
                "However, <br>agent</br> is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the <br>agent</br> has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the <br>agent</br> has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the <br>agent</br> i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the <br>agent</br> i.",
                "Let S be a set of items for which the <br>agent</br> i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each <br>agent</br> i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the <br>agent</br> i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the <br>agent</br>, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder <br>agent</br> i (line 5); this a bid that the <br>agent</br> is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an <br>agent</br> different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the <br>agent</br> i has for those same items with a bid from <br>agent</br> i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, <br>agent</br> is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the <br>agent</br> i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each <br>agent</br> i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if <br>agent</br> i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each <br>agent</br> calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center <br>agent</br> that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every <br>agent</br> performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no <br>agent</br> can propose a better bidset.",
                "Each <br>agent</br> must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the <br>agent</br> needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each <br>agent</br> also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "We can even envision completely eliminating the auctioneer and, instead, have every <br>agent</br> perform the task of the auctioneer."
            ],
            "translated_annotated_samples": [
                "Dado que en la ronda final todos los <br>agente</br>s consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún <br>agente</br> pueda proponer un conjunto de ofertas mejor.",
                "Cada <br>agente</br> debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas.",
                "La búsqueda se facilita por el hecho de que el <br>agente</br> solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual.",
                "Cada <br>agente</br> también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás).",
                "Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada <br>agente</br> realice la tarea del subastador."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los <br>agente</br>s consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún <br>agente</br> pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada <br>agente</br> debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el <br>agente</br> solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada <br>agente</br> también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada <br>agente</br> realice la tarea del subastador. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "progressive adaptive user selection environment": {
            "translated_key": "Entorno de Selección de Usuario Adaptativo Progresivo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (<br>progressive adaptive user selection environment</br>) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "The PAUSE (<br>progressive adaptive user selection environment</br>) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders."
            ],
            "translated_annotated_samples": [
                "La subasta PAUSE (<br>Entorno de Selección de Usuario Adaptativo Progresivo</br>) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (<br>Entorno de Selección de Usuario Adaptativo Progresivo</br>) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes. Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta. Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos. Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la solución que maximiza los ingresos cuando los agentes ofrecen sus verdaderas valoraciones. Dado que PAUSE utiliza subastas inglesas, los precios finales (aproximadamente) representan la segunda valoración más alta, más , para ese conjunto de artículos. Fijamos el número de agentes en 5 y experimentamos con diferentes cantidades de artículos, concretamente de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución que maximiza los ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de artículos que la solución que maximiza los ingresos (como se muestra en la Figura 6). Los casos en los que nuestros algoritmos no lograron llegar a la distribución de la solución que maximiza los ingresos son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución que maximiza los ingresos contiene la oferta (o ofertas) utilizando estas valoraciones más altas, entonces es imposible que la subasta PAUSE encuentre esta solución porque esa oferta (esas ofertas) nunca se realiza. Por ejemplo, si el agente i tiene vi(1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces i solo necesita hacer una oferta de 11 para ganar ese artículo. Si la solución que maximiza los ingresos requiere que 1 se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se realizará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen hacia la solución que maximiza los ingresos disminuye a medida que aumenta el número de elementos. Para 2 elementos es casi del 100%, pero disminuye un poco menos del 1 por ciento a medida que los elementos aumentan, por lo que este porcentaje promedio de convergencia es alrededor del 90% para 10 elementos. En algunas ocasiones, nuestros algoritmos encuentran soluciones diferentes debido a The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de elementos en cachéPausaOferta 3 3 3 3 3 3 3 3 3 PausaOferta + + + + + + + + + + Figura 8: Promedio de nodos expandidos (eje y) en función de los elementos en la subasta. orden de las ofertas en la lista de ofertas que hace que se busquen en diferente orden. Sabemos que los ingresos generados por la subasta de PAUSE suelen ser inferiores a los ingresos de la solución que maximiza los ingresos, pero ¿cuánto más bajos son? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos proporcionados por nuestros algoritmos en relación con los ingresos proporcionados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio un 2.7% a medida que aumenta el número de artículos, como se muestra en la Figura 7. Sin embargo, descubrimos que cachedpausebid genera un mayor ingreso que pausebid (un 4.3% más en promedio) excepto en subastas con 2 artículos donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 artículos, ambos algoritmos generan en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 artículos), cachedpausebid generó en promedio una proporción de ingresos del 91.5%, mientras que pausebid generó en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el árbol de búsqueda. Para esto contamos el número de veces que se invoca pbsearch cada vez que se llama a pausebid y el número de veces que se invoca fastpausebidsearch cada vez que se llama a cachedpausebid, respectivamente para cada uno de nuestros algoritmos. Como era de esperar, dado que este es un problema NP-Difícil, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que cachedpausebid supera a pausebid, ya que en promedio expande menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos expandidos cuando hay 2 elementos es cero para cachedpausebid, mientras que para pausebid es 2; y en el otro extremo (10 elementos) cachedpausebid se expande en promedio solo 633 nodos, mientras que pausebid se expande en promedio en 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta en función del número de elementos, el número real de nodos es mucho menor que el peor escenario de nn donde n es el número de elementos. Por ejemplo, para 10 artículos expandimos ligeramente más de 103 nodos para el caso de pausebid y menos que eso para el caso de cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de Artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 9: Tiempo promedio en segundos que tarda en finalizar una subasta (eje y) en función del número de artículos en la subasta, que son números mucho menores que 1010. También hay que tener en cuenta que nuestro algoritmo de generación de valor (Figura 5) genera una cantidad de ofertas que es exponencial en el número de artículos, como podría esperarse en muchas situaciones. Por lo tanto, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan de forma exponencial en función del número de ofertas, pero se mantengan aproximadamente constantes a medida que crece el número de artículos. Queríamos asegurarnos de que menos nodos expandidos realmente se corresponde con una ejecución más rápida, especialmente dado que nuestros algoritmos ejecutan diferentes operaciones. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, un PC portátil Intel Centrino de 2.0 GHz con 1 GB de RAM y un disco duro de 60 GB a 7200 RPM, y calculamos el tiempo promedio que tarda en finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, cachedpausebid es más rápido que pausebid, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos. TRABAJO RELACIONADO Se ha realizado mucha investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena reseña. Sin embargo, el estudio de algoritmos distribuidos para la determinación de ganadores en subastas combinatorias todavía es relativamente nuevo. Un enfoque está dado por los algoritmos para distribuir el problema de determinación del ganador en subastas combinatorias presentados en [7], pero estos algoritmos asumen que las entidades computacionales son los artículos que se están vendiendo y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación distribuida del ganador en una subasta combinatoria, pero asume que las propias ofertas realizan el cálculo. Este algoritmo también falla en converger hacia una solución en la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos VCG en un problema de diseño de mecanismos. Su mecanismo se resume aproximadamente en hacer que cada agente calcule los pagos para otros dos agentes y se los entregue a un 700 seguro de The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) tiene un servidor central que luego verifica que los resultados de todos los pares estén de acuerdo; de lo contrario, se ordena una nueva recalcuación. Esta idea general, a la que llaman principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se presenta en [8] donde los agentes de oferta priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo centralizado de determinación de ganadores debe considerar, facilitando así ese problema. Finalmente, en el proceso de cálculo de la subasta de reloj [1], a los agentes se les otorga un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Por lo tanto, asume que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores como asume la subasta PAUSE. 7. CONCLUSIONES Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entre los postores. La subasta PAUSE es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en subastas combinatorias. Con esta subasta, incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Sin embargo, mientras que PAUSE establece las reglas que los licitadores deben obedecer, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos presentado dos algoritmos, pausebid y cachedpausebid, que los agentes ofertantes pueden utilizar para participar en una subasta de PAUSE. Ambos algoritmos implementan una estrategia de maximización de utilidad miope que garantiza encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dado el conjunto de mejores ofertas pendientes en cualquier momento, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayor parte del tiempo, la misma distribución de elementos que la solución que maximiza los ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de artículos. Dado que es un problema NP-Difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se invoca. cachedpausebid almacena en caché soluciones parciales y realiza una búsqueda de ramificación y acotación solo en las pocas partes afectadas por los cambios en las ofertas entre tiempos consecutivos. cachedpausebid tiene un mejor rendimiento ya que explora menos nodos (menos de la mitad) y es más rápido. Como era de esperar, los ingresos generados por una subasta de PAUSE son inferiores a los ingresos de una solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores, sin embargo, descubrimos que cachedpausebid genera en promedio un 4.7% más de ingresos que pausebid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan en función del número de artículos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas restricciones de coordinación respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores. Además, debido al diseño de la subasta PAUSE, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros algoritmos de oferta pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la coordinación, pero que prefiera no implementar un subastador centralizado. 8. REFERENCIAS [1] P. J. Cervecero. Adquisición descentralizada de computación y robustez computacional en un mercado inteligente. Teoría Económica, 13(1):41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. Subastas combinatorias. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Ciencias de la Gestión, 46(4):586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. PAUSA: Una subasta combinatoria computacionalmente viable. En Cramton et al. [2], capítulo 6, páginas 139-157. [6] K. Leyton-Brown, M. Pearson y Y. Shoham. Hacia un conjunto de pruebas universal para algoritmos de subasta combinatoria. En Actas de la 2ª conferencia de la ACM sobre comercio electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación distribuida de ganadores en subastas combinatorias. En el volumen de LNAI de AMEC/TADA. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas determinadas endógenamente. Informe técnico, Centro de Investigación de Operaciones Rutgets, enero de 2001. RRR 3-2001. [9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo y rápido para la determinación del ganador en subastas combinatorias. Ciencia de la Gestión, 51(3):374-391, 2005. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 701 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "branch and bound search": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a <br>branch and bound search</br> completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a <br>branch and bound search</br>. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a <br>branch and bound search</br> on the branch-on-bids tree produced by these bids.",
                "This <br>branch and bound search</br> is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a <br>branch and bound search</br>.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our <br>branch and bound search</br> implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a <br>branch and bound search</br> completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a <br>branch and bound search</br> only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a <br>branch and bound search</br> completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a <br>branch and bound search</br>. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "The agent can now perform a <br>branch and bound search</br> on the branch-on-bids tree produced by these bids.",
                "This <br>branch and bound search</br> is implemented by pbsearch (Figure 2).",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a <br>branch and bound search</br>."
            ],
            "translated_annotated_samples": [
                "Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una <br>búsqueda de ramificación y acotación</br> completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una <br>búsqueda de ramificación y acotación</br>. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B.",
                "El agente ahora puede realizar una <br>búsqueda de ramificación y acotación</br> en el árbol de ramificación de ofertas generado por estas ofertas.",
                "Esta <br>búsqueda de ramificación y acotación</br> está implementada por pbsearch (Figura 2).",
                "Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una <br>búsqueda de ramificación y acotamiento</br>."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una <br>búsqueda de ramificación y acotación</br> completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un árbol de búsqueda grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el árbol de búsqueda. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una <br>búsqueda de ramificación y acotación</br>. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una <br>búsqueda de ramificación y acotación</br> en el árbol de ramificación de ofertas generado por estas ofertas. Esta <br>búsqueda de ramificación y acotación</br> está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del árbol de búsqueda. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una <br>búsqueda de ramificación y acotamiento</br>. ",
            "candidates": [],
            "error": [
                [
                    "búsqueda de ramificación y acotación",
                    "búsqueda de ramificación y acotación",
                    "búsqueda de ramificación y acotación",
                    "búsqueda de ramificación y acotación",
                    "búsqueda de ramificación y acotamiento"
                ]
            ]
        },
        "pause auction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The <br>pause auction</br> is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a <br>pause auction</br>.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a <br>pause auction</br> to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE <br>pause auction</br> A <br>pause auction</br> for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a <br>pause auction</br> is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The <br>pause auction</br> makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the <br>pause auction</br> has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the <br>pause auction</br> is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the <br>pause auction</br>, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the <br>pause auction</br>.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the <br>pause auction</br> we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the <br>pause auction</br> on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the <br>pause auction</br> to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the <br>pause auction</br> is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the <br>pause auction</br>. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The <br>pause auction</br> is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a <br>pause auction</br>.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a <br>pause auction</br> is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the <br>pause auction</br>, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "The <br>pause auction</br> is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "We have developed a couple of bidding algorithms for the bidders in a <br>pause auction</br>.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a <br>pause auction</br> to find the bidset that maximizes their utility.",
                "THE <br>pause auction</br> A <br>pause auction</br> for m items has m stages.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a <br>pause auction</br> is the same as the revenue maximizing solution."
            ],
            "translated_annotated_samples": [
                "La <br>subasta PAUSE</br> es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador).",
                "Hemos desarrollado un par de algoritmos de oferta para los postores en una <br>subasta de PAUSE</br>.",
                "En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una <br>subasta de PAUSE</br> encontrar el conjunto de ofertas que maximiza su utilidad.",
                "La <br>subasta PAUSA</br> Una <br>subasta PAUSA</br> para m artículos tiene m etapas.",
                "Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una <br>subasta de PAUSE</br> es la misma que la solución que maximiza los ingresos."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La <br>subasta PAUSE</br> es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una <br>subasta de PAUSE</br>. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una <br>subasta de PAUSE</br> encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La <br>subasta PAUSA</br> Una <br>subasta PAUSA</br> para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una <br>subasta de PAUSE</br> es la misma que la solución que maximiza los ingresos. ",
            "candidates": [],
            "error": [
                [
                    "subasta PAUSE",
                    "subasta de PAUSE",
                    "subasta de PAUSE",
                    "subasta PAUSA",
                    "subasta PAUSA",
                    "subasta de PAUSE"
                ]
            ]
        },
        "search tree": {
            "translated_key": "árbol de búsqueda",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large <br>search tree</br>.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the <br>search tree</br>.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the <br>search tree</br>.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the <br>search tree</br>.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [
                "However, this approach is computationally expensive since it produces a large <br>search tree</br>.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the <br>search tree</br>.",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the <br>search tree</br>.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the <br>search tree</br>."
            ],
            "translated_annotated_samples": [
                "Sin embargo, este enfoque es computacionalmente costoso ya que produce un <br>árbol de búsqueda</br> grande.",
                "Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el <br>árbol de búsqueda</br>.",
                "Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del <br>árbol de búsqueda</br>.",
                "La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el <br>árbol de búsqueda</br>."
            ],
            "translated_text": "Algoritmos de subasta para una subasta combinatoria distribuida Benito Mendoza ∗ y José M. Vidal Ciencias de la Computación e Ingeniería Universidad de Carolina del Sur Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu RESUMEN Los problemas de asignación distribuida y coordinación multiagente pueden resolverse a través de subastas combinatorias. Sin embargo, la mayoría de los algoritmos existentes para determinar al ganador en subastas combinatorias son centralizados. La subasta PAUSE es uno de los pocos esfuerzos para liberar al subastador de tener que hacer todo el trabajo (incluso podría ser posible prescindir del subastador). Es una subasta combinatoria de precio creciente que distribuye naturalmente el problema de la determinación del ganador entre los postores de tal manera que tengan un incentivo para realizar el cálculo. Se puede utilizar cuando deseamos distribuir la carga computacional entre los postores o cuando los postores no desean revelar sus verdaderas valoraciones a menos que sea necesario. PAUSE establece las reglas que los licitadores deben obedecer. Sin embargo, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos desarrollado un par de algoritmos de oferta para los postores en una subasta de PAUSE. Nuestros algoritmos siempre devuelven el conjunto de ofertas que maximiza la utilidad de los postores. Dado que el problema es NP-Hard, el tiempo de ejecución sigue siendo exponencial en el número de elementos, pero es notablemente mejor que una búsqueda exhaustiva. En este documento presentamos nuestros algoritmos de oferta, discutimos sus virtudes y desventajas, y comparamos las soluciones obtenidas por ellos con la solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores. Categorías y Descriptores de Asignaturas I.2.11 [Metodologías de Computación]: Inteligencia Artificial Distribuida-Agentes Inteligentes, Sistemas Multiagente. Términos generales Algoritmos, Rendimiento. 1. Tanto la investigación como la práctica de las subastas combinatorias han crecido rápidamente en los últimos diez años. En una subasta combinatoria, los postores pueden realizar ofertas en combinaciones de artículos, llamadas paquetes o conjuntos de ofertas, en lugar de solo artículos individuales. Una vez que los postores realizan sus ofertas, es necesario encontrar la asignación de artículos a los postores que maximice los ingresos del subastador. Este problema, conocido como el problema de determinación del ganador, es un problema de optimización combinatoria y es NP-Difícil [10]. Sin embargo, se han desarrollado varios algoritmos que tienen un rendimiento satisfactorio para tamaños de problemas y estructuras que ocurren en la práctica. Las aplicaciones prácticas de las subastas combinatorias incluyen: la asignación de franjas horarias de despegue y aterrizaje en aeropuertos, la adquisición de servicios de transporte de carga, la adquisición de servicios de transporte público y la adquisición industrial [2]. Debido a su amplia aplicabilidad, no se puede esperar un algoritmo de determinación de ganadores de propósito general que pueda resolver eficientemente cada instancia del problema. Por lo tanto, se han propuesto varios enfoques y algoritmos para abordar el problema de determinación del ganador. Sin embargo, la mayoría de los algoritmos existentes para la determinación de ganadores en subastas combinatorias son centralizados, lo que significa que requieren que todos los agentes envíen sus ofertas a un subastador centralizado que luego determina a los ganadores. Ejemplos de estos algoritmos son CASS [3], Bidtree [11] y CABOB [12]. Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador. La subasta PAUSE (Entorno de Selección de Usuario Adaptativo Progresivo) [4, 5] es uno de los pocos esfuerzos para distribuir el problema de la determinación del ganador entre los postores. PAUSE establece las reglas a las que los participantes deben adherirse para que el trabajo se distribuya entre ellos. Sin embargo, no se preocupa por cómo los postores determinan cuánto deben ofertar. En este documento presentamos dos algoritmos, pausebid y cachedpausebid, que permiten a los agentes en una subasta de PAUSE encontrar el conjunto de ofertas que maximiza su utilidad. Nuestros algoritmos implementan una estrategia de maximización de utilidad miope y están garantizados para encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dadas las mejores ofertas pendientes en un momento dado. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se llama. cachedpausebid es un algoritmo basado en caché que explora menos nodos, ya que almacena en caché algunas soluciones. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2. La subasta PAUSA Una subasta PAUSA para m artículos tiene m etapas. La etapa 1 consiste en tener subastas simultáneas de precio ascendente a viva voz y durante esta etapa los postores solo pueden realizar ofertas en artículos individuales. Al final de este estado sabremos cuál es la oferta más alta para cada artículo individual y quién realizó esa oferta. Cada etapa sucesiva k = 2, 3, . . . , m consiste en una subasta de precio ascendente donde los postores deben presentar conjuntos de ofertas que cubran todos los artículos, pero cada una de las ofertas debe ser por k artículos o menos. Los postores pueden utilizar las ofertas que otros agentes han realizado en rondas anteriores al construir sus conjuntos de ofertas, lo que les permite encontrar mejores soluciones. Además, cualquier nuevo conjunto de ofertas debe tener una suma de precios de oferta que sea mayor que la del conjunto de ofertas ganador actualmente. Al final de cada etapa k, todos los agentes conocen la mejor oferta para cada subconjunto de tamaño k o menor. Además, en cualquier momento después de que haya finalizado la etapa 1, existe un conjunto de ofertas en pie cuyo valor aumenta de forma monótona a medida que se presentan nuevos conjuntos de ofertas. Dado que en la ronda final todos los agentes consideran todos los conjuntos de ofertas posibles, sabemos que el conjunto de ofertas ganador final será aquel tal que ningún agente pueda proponer un conjunto de ofertas mejor. Sin embargo, cabe destacar que este conjunto de ofertas no está garantizado de ser el que maximiza los ingresos, ya que estamos utilizando una subasta de precio ascendente, por lo que la oferta ganadora para cada conjunto será solo ligeramente mayor que la segunda oferta más alta para ese conjunto particular de artículos. Es decir, los precios finales no serán los mismos que los precios en una subasta combinatoria tradicional donde todos los postores ofrecen su verdadera valoración. Sin embargo, queda la pregunta abierta de si la distribución final de los artículos a los postores encontrada en una subasta de PAUSE es la misma que la solución que maximiza los ingresos. Nuestros resultados de prueba proporcionan una respuesta a esta pregunta. La subasta PAUSE facilita mucho el trabajo del subastador. Todo lo que tiene que hacer es asegurarse de que cada nuevo conjunto de ofertas tenga una ganancia mayor que el conjunto de ofertas ganadoras actual, así como asegurarse de que cada oferta en el conjunto de ofertas de un agente que no es suya corresponda efectivamente a alguna oferta previa de otro agente. El problema computacional cambia de uno de determinación del ganador a uno de generación de ofertas. Cada agente debe buscar en el espacio de todos los conjuntos de ofertas que contienen al menos una de sus ofertas. La búsqueda se facilita por el hecho de que el agente solo necesita considerar las ofertas actuales más altas y solo desea conjuntos de ofertas donde su propia utilidad sea mayor que en el conjunto de ofertas ganadoras actual. Cada agente también tiene un claro incentivo para realizar este cálculo, es decir, su utilidad solo aumenta con cada conjunto de ofertas que propone (por supuesto, podría disminuir con los conjuntos de ofertas que proponen los demás). Finalmente, se ha demostrado que la subasta PAUSE es libre de envidia, ya que al concluir la subasta ningún postor preferiría intercambiar su asignación con la de cualquier otro postor [2]. Incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Es decir, todas las ofertas se transmiten y cuando un agente recibe una oferta de otro agente, actualiza el conjunto de mejores ofertas y determina si la nueva oferta es realmente mejor que la oferta ganadora actual. Los agentes tendrían un incentivo para realizar sus cálculos ya que aumentará su utilidad esperada. Además, cualquier mentira sobre las ofertas de otros agentes se descubre fácilmente llevando un registro de las ofertas enviadas por cada agente (el conjunto de las mejores ofertas). Es decir, el único que puede aumentar el valor de la oferta de un agente es el propio agente. Cualquier persona que afirme un valor más alto para otro agente está mintiendo. Lo único que falta es un algoritmo que calcule el conjunto de ofertas que maximiza la utilidad para cada agente. FORMULACIÓN DEL PROBLEMA Un bid b está compuesto por tres elementos bitems (el conjunto de artículos sobre los que se realiza la oferta), bagent (el agente que realizó la oferta) y bvalue (el valor o precio de la oferta). Los agentes mantienen un conjunto B de las mejores ofertas actuales, una para cada conjunto de artículos de tamaño ≤ k, donde k es la etapa actual. En cualquier momento de la subasta, después de la primera ronda, también habrá un conjunto W ⊆ B de ofertas ganadoras actuales. Este es el conjunto de ofertas que cubre todos los artículos y actualmente maximiza los ingresos, donde los ingresos de W vienen dados por r(W) = b∈W bvalue. La función de valor del agente se da por vi(S) ∈ donde S es un conjunto de artículos. Dada una función de valor de los agentes y el conjunto de ofertas ganadoras actual W, podemos calcular la utilidad de los agentes a partir de W como ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) Es decir, la utilidad de los agentes para un conjunto de ofertas W es el valor que reciben por los artículos que ganan en W menos el precio que deben pagar por esos artículos. Si el agente no está ganando ningún ítem, entonces su utilidad es cero. El objetivo de los agentes de oferta en la subasta PAUSE es maximizar su utilidad, sujeta a la restricción de que su próximo conjunto de ofertas debe tener un ingreso total que sea al menos mayor que el ingreso actual, donde ε es el incremento mínimo permitido en la subasta. Formalmente, dado que W es el conjunto de ofertas ganadoras actual, el agente i debe encontrar un g∗ i tal que r(g∗ i ) ≥ r(W) + y g∗ i = arg max g⊆2B ui(g), (3), donde cada g es un conjunto de ofertas que cubre todos los artículos y ∀b∈g (b ∈ B) o (bagent = i y bvalue > B(bitems ) y size(bitems ) ≤ k), y donde B(items) es el valor de la oferta en B para el conjunto de artículos (si no hay oferta para esos artículos, devuelve cero). Es decir, cada oferta b en g debe cumplir al menos una de las dos siguientes condiciones. 1) b ya está en B, 2) b es una oferta de tamaño ≤ k en la que el agente i ofrece más que el precio por los mismos artículos en B. 4. ALGORITMOS DE PUJA Según la subasta PAUSE, durante la primera etapa solo tenemos varias subastas inglesas, con los postores presentando ofertas en artículos individuales. En este caso, la estrategia dominante de un agente es ofertar más alto que la oferta ganadora actual hasta que alcance su valoración para ese artículo en particular. Nuestros algoritmos se centran en las etapas siguientes: k > 1. Cuando k > 1, los agentes tienen que encontrar g∗ i. Esto se puede hacer realizando una búsqueda completa en B. Sin embargo, este enfoque es computacionalmente costoso ya que produce un <br>árbol de búsqueda</br> grande. Nuestros algoritmos representan enfoques alternativos para superar esta búsqueda costosa. 4.1 El algoritmo PAUSEBID En el algoritmo pausebid (mostrado en la Figura 1) implementamos algunas heurísticas para podar el <br>árbol de búsqueda</br>. Dado que los postores desean maximizar su utilidad y que en cualquier momento dado probablemente solo haya unos pocos postores dentro de B, que es el Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 695 pausebid(i, k) 1 mis-pujas ← ∅ 2 sus-pujas ← ∅ 3 para b ∈ B 4 hacer si bagente = i o vi(bitems) > bvalor 5 entonces mis-pujas ← mis-pujas + nueva Puja(bitems, i, vi(bitems)) 6 de lo contrario sus-pujas ← sus-pujas + b 7 para S ∈ subconjuntos de k o menos elementos tales que vi(S) > 0 y ¬∃b∈Bbitems = S 8 hacer mis-pujas ← mis-pujas + nueva Puja(S, i, vi(S)) 9 pujas ← mis-pujas + sus-pujas 10 g∗ ← ∅ £ Variable global 11 u∗ ← ui(W)£ Variable global 12 pbsearch(pujas, ∅) 13 excedente ← b∈g∗ | bagente=i bvalor − B(bitems) 14 si excedente = 0 15 entonces devolver g∗ 16 mi-pago ← vi(g∗) − u∗ 17 para b ∈ g∗ | bagente = i 18 hacer si mi-pago ≤ 0 19 entonces bvalor ← B(bitems) 20 de lo contrario bvalor ← B(bitems) + mi-pago · bvalor − B(bitems) excedente 21 devolver g∗ Figura 1: El algoritmo pausebid que implementa una búsqueda de ramificación y acotación. i es el agente y k es la etapa actual de la subasta, para k ≥ 2. el agente puede dominar, comenzamos definiendo mis-pujas como la lista de pujas para las cuales la valoración de los agentes es mayor que la mejor puja actual, como se indica en B. Establecemos el valor de estas ofertas como la verdadera valoración de los agentes (pero no necesariamente estaremos ofertando la verdadera valoración, como explicaremos más adelante). De manera similar, establecemos sus ofertas como el resto de las ofertas de B. Finalmente, la lista de búsqueda de agentes es simplemente la concatenación de mis ofertas y sus ofertas. Ten en cuenta que las ofertas propias de los agentes se colocan primero en la lista de búsqueda, ya que esto nos permitirá hacer más poda (líneas de 3 a 9 de la oferta de pausa). El agente ahora puede realizar una búsqueda de ramificación y acotación en el árbol de ramificación de ofertas generado por estas ofertas. Esta búsqueda de ramificación y acotación está implementada por pbsearch (Figura 2). Nuestro algoritmo no solo implementa el límite estándar, sino que también implementa otras técnicas de poda para reducir aún más el tamaño del <br>árbol de búsqueda</br>. El límite que utilizamos es la utilidad máxima que el agente puede esperar recibir de un conjunto dado de ofertas. Lo llamamos u∗. Inicialmente, u∗ se establece en ui(W) (línea 11 de pausa) ya que esa es la utilidad que el agente recibe actualmente y cualquier solución que proponga debería darle más utilidad. Si pbsearch se encuentra alguna vez con una solución parcial donde la utilidad máxima que el agente puede esperar recibir es menor que u∗, entonces ese subárbol se poda (línea 21 de pbsearch). Ten en cuenta que solo podemos determinar la utilidad máxima después de que el algoritmo haya buscado en todas las ofertas propias de los agentes (que están al principio de la lista) porque después de eso sabemos que la solución no incluirá más ofertas donde el agente sea el ganador, por lo tanto, la utilidad del agente ya no aumentará. Por ejemplo, pbsearch(bids, g) 1 si bids = ∅ entonces devolver 2 b ← primero(bids) 3 bids ← bids − b 4 g ← g + b 5 ¯Ig ← artículos no en g 6 si g no contiene una oferta de i 7 entonces devolver 8 si g incluye todos los artículos 9 entonces min-pago ← max(0, r(W) + - (r(g) - ri(g)), b∈g | bagente=i B(bartículos)) 10 max-utilidad ← vi(g) - min-pago 11 si r(g) > r(W) y max-utilidad ≥ u∗ 12 entonces g∗ ← g 13 u∗ ← max-utilidad 14 pbsearch(bids, g - b) £ b está Fuera 15 else max-ingreso ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 si max-ingreso ≤ r(W) 17 entonces pbsearch(bids, g - b) £ b está Fuera 18 sino si bagente = i 19 entonces min-pago ← (r(W) + ) - (r(g) - ri(g)) - h(¯Ig) 20 max-utilidad ← vi(g) - min-pago 21 si max-utilidad > u∗ 22 entonces pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 23 pbsearch(bids, g - b) £ b está Fuera 24 else 25 pbsearch({x ∈ bids | xartículos ∩ bartículos = ∅}, g) £ b está Dentro 26 pbsearch(bids, g - b) £ b está Fuera 27 devolver Figura 2: El procedimiento recursivo pbsearch donde bids es el conjunto de ofertas disponibles y g es la solución parcial actual. si un agente tiene solo una oferta en mis ofertas entonces la utilidad máxima que puede esperar es igual a su valor por los artículos en esa oferta menos el pago mínimo posible que podemos hacer por esos artículos y aún así obtener un conjunto de ofertas que tenga un ingreso mayor que r(W). El cálculo del pago mínimo se muestra en la línea 19 para el caso de solución parcial y en la línea 9 para el caso en el que tenemos una solución completa en pbsearch. Ten en cuenta que para calcular el pago mínimo para el caso de solución parcial necesitamos un límite superior en los pagos que debemos hacer por cada artículo. Este límite superior es proporcionado por h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) Esta función produce un límite idéntico al utilizado por el algoritmo Bidtree, simplemente asigna a cada artículo individual en S un valor igual a la oferta máxima en B dividida por el número de artículos en esa oferta. Para podar las ramas que no pueden llevar a una solución con ingresos mayores que el valor actual de W, el algoritmo considera tanto los valores de las ofertas en B como las valoraciones de la 696 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) agente. De manera similar a (4) definimos hi(S, k) = s∈S max S | size(S )≤k y s∈S y vi(S )>0 vi(S ) size(S ) (5) que asigna a cada elemento individual s en S el valor máximo producido por la valoración de S dividido por el tamaño de S, donde S es un conjunto para el cual el agente tiene una valoración mayor que cero, contiene a s, y su tamaño es menor o igual que k. El algoritmo utiliza las heurísticas h y hi (líneas 15 y 19 de pbsearch), para podar las ramas recién mencionadas de la misma manera en que un algoritmo A∗ utiliza su heurística. Una técnica de poda final implementada por el algoritmo es ignorar cualquier rama donde el agente no tenga ofertas en la respuesta actual g y no haya más ofertas de los agentes en la lista (líneas 6 y 7 de la búsqueda pbsearch). El g∗ resultante encontrado por pbsearch es, por lo tanto, el conjunto de ofertas que tiene ingresos mayores que r(W) y maximiza la utilidad del agente. Sin embargo, las ofertas del agente en g∗ todavía se establecen según su propia valoración y no al precio más bajo posible. Las líneas 17 a 20 en pausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima u∗. Si el agente tiene solo una oferta en g∗, entonces simplemente se trata de reducir el pago de esa oferta por u∗ desde el máximo actual de la verdadera valoración del agente. Sin embargo, si el agente tiene más de una oferta, entonces nos enfrentamos al problema de cómo distribuir los pagos de los agentes entre estas ofertas. Hay muchas formas de distribuir los pagos y no parece haber una estrategia dominante para realizar esta distribución. Hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. pausebid asume que el conjunto de mejores ofertas B y el conjunto de mejores ofertas ganadoras actuales W permanecen constantes durante su ejecución, y devuelve el conjunto de ofertas que maximiza la utilidad miope de los agentes (si existe) utilizando una búsqueda de ramificación y acotamiento. Sin embargo, repite la búsqueda completa en cada etapa. Podemos minimizar este problema almacenando en caché el resultado de búsquedas anteriores. 4.2 El algoritmo CACHEDPAUSEBID El algoritmo cachedpausebid (mostrado en la Figura 3) es nuestro segundo enfoque para resolver el problema de las subastas en la subasta PAUSE. Está basado en una tabla de caché llamada C-Table donde almacenamos algunas soluciones para evitar realizar una búsqueda completa cada vez. El problema es el mismo; el agente i tiene que encontrar g∗ i. Observamos que g∗ i es un conjunto de ofertas que contiene al menos una oferta del agente i. Sea S un conjunto de elementos para los cuales el agente i tiene una valoración tal que vi(S) ≥ B(S) > 0, sea gS i un conjunto de ofertas sobre S tal que r(gS i ) ≥ r(W) + y gS i = arg max g⊆2B ui(g), (6) donde cada g es un conjunto de ofertas que cubre todos los elementos y ∀b∈g (b ∈ B) o (bagente = i y bvalor > B(belementos )) y (∃b∈belementos = S y bagente = i). Es decir, gS i es el mejor conjunto de ofertas para todos los artículos que incluye una oferta de i para todos los artículos de S. En la subasta PAUSE no podemos ofertar por conjuntos de artículos con tamaño mayor que k. Por lo tanto, si tenemos para cada conjunto de artículos S para el cual vi(S) > 0 y tamaño(S) ≤ k su correspondiente gS i, entonces g∗ i es el gS i que maximiza la utilidad de los agentes. Eso es g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Cada agente i implementa una tabla hash C-Table tal que C-Table[S] = gS para todo S donde vi(S) ≥ B(S) > 0. Podemos pausar en caché la oferta (i, k, k-cambiado) 1 por cada S en la Tabla-C 2 hacer si vi(S) < B(S) 3 entonces eliminar S de la Tabla-C 4 sino si k-cambiado y tamaño(S) = k 5 entonces B ← B + Nueva Oferta(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 por cada S con tamaño(S) ≤ k en la Tabla-C 9 hacer ¯S ← Ítems − S 10 gS ← Tabla-C[S] £ Variable global 11 pago-mínimo ← máx(r(W) + , b∈gS B(bítems)) 12 uS ← r(gS) − pago-mínimo 13 si (k-cambiado y tamaño(S) = k) o (∃b∈B bítems ⊆ ¯S y bagente = i) 14 entonces B ← {b ∈ B |bítems ⊆ ¯S} 15 ofertas ← B + {b ∈ B|bítems ⊆ ¯S y b /∈ B} 16 por b ∈ ofertas 17 hacer si vi(bítems) > bvalor 18 entonces bagente ← i 19 bvalor ← vi(bítems) 20 si k-cambiado y tamaño(S) = k 21 entonces n ← tamaño(ofertas) 22 uS ← 0 23 sino n ← tamaño(B) 24 g ← ∅ + Nueva Oferta(S, i, vi(S)) 25 búsqueda-cpb(ofertas, g, n) 26 Tabla-C[S] ← gS 27 si uS > u∗ y r(gS) ≥ r(W) + 28 entonces excedente ← b∈gS | bagente=i bvalor − B(bítems) 29 si excedente > 0 30 entonces mi-pago ← vi(gS) − ui(gS) 31 por b ∈ gS | bagente = i 32 hacer si mi-pago ≤ 0 33 entonces bvalor ← B(bítems) 34 sino bvalor ← B(bítems) + mi-pago · bvalor − B(bítems) excedente 35 u∗ ← ui(gS) 36 g∗ ← gS 37 sino si uS ≤ 0 y vi(S) < B(S) 38 entonces eliminar S de la Tabla-C 39 retornar g∗ Figura 3: El algoritmo cachedpausebid que implementa una búsqueda basada en caché para encontrar un conjunto de ofertas que maximice la utilidad para el agente i. k es la etapa actual de la subasta (para k ≥ 2), y k-cambiado es un booleano que es verdadero justo después de que la subasta pasó a la siguiente etapa. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 697 cpbsearch(bids, g, n) 1 si bids = ∅ o n ≤ 0 entonces devolver 2 b ← primero(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← elementos no en g 6 si g incluye todos los elementos 7 entonces min-pago ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagente=i B(belementos )) 8 máx-utilidad ← vi(g) − min-pago 9 si r(g) > r(W) y máx-utilidad ≥ uS 10 entonces gS ← g 11 uS ← máx-utilidad 12 cpbsearch(bids, g − b, n − 1) £ b está Fuera 13 else máx-ingreso ← r(g) + máx(h(¯Ig), hi(¯Ig)) 14 si máx-ingreso ≤ r(W) 15 entonces cpbsearch(bids, g − b, n − 1) £ b está Fuera 16 elseif bagente = i 17 entonces min-pago ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 máx-utilidad ← vi(g) − min-pago 19 si máx-utilidad > uS 20 entonces cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 21 cpbsearch(bids, g − b, n − 1) £ b está Fuera 22 else 23 cpbsearch({x ∈ bids | xelementos ∩ belementos = ∅}, g, n + 1) £ b está Dentro 24 cpbsearch(bids, g − b, n − 1) £ b está Fuera 25 devolver Figura 4: El procedimiento recursivo cpbsearch donde bids es el conjunto de ofertas disponibles, g es la solución parcial actual y n es un valor que indica qué tan profundo en la lista de ofertas el algoritmo debe buscar. luego encontrar g∗ buscando el gS , almacenado en C-Tabla[S], que maximiza la utilidad de los agentes, considerando solo el conjunto de elementos S con tamaño(S) ≤ k. El problema radica en mantener actualizada la C-Tabla y evitar buscar cada gS cada vez. cachedpausebid se encarga de esto y otros detalles. Sea B el conjunto de ofertas que contiene las nuevas mejores ofertas, es decir, B contiene las ofertas recientemente añadidas a B y las ofertas que han cambiado de precio (siempre más alto), postor, o ambas y que ya estaban en B. Sea ¯S = Items − S el complemento de S (el conjunto de elementos no incluidos en S). cachedpausebid toma tres parámetros: i el agente, k la etapa actual de la subasta, y k-changed un booleano que es verdadero justo después de que la subasta se mueve a la siguiente etapa. Inicialmente, la tabla C tiene una fila o entrada para cada conjunto S para el cual vi(S) > 0. Comenzamos eliminando las entradas correspondientes a cada conjunto S para el cual vi(S) < B(S) de la tabla C (línea 3). Entonces, en el caso de que k-changed sea verdadero, para cada conjunto S con tamaño(S) = k, agregamos a B una oferta por ese conjunto con valor igual a vi(S) y agente postor i (línea 5); esta es una oferta que el agente ahora puede considerar. Luego buscamos g∗ entre los gS almacenados en la C-Tabla, para esto solo necesitamos considerar los conjuntos con tamaño(S) ≤ k (línea 8). Pero ¿cómo sabemos que el gS en C-Tabla[S] sigue siendo la mejor solución para S? Solo hay dos casos en los que no estamos seguros acerca de eso y necesitamos hacer una búsqueda para actualizar la tabla C[S]. Estos casos son: i) Cuando k-changed es verdadero y el tamaño de S es ≤ k, ya que no había ningún gS almacenado en la tabla C para este S. ii) Cuando existe al menos una oferta en B para el conjunto de artículos ¯S o un subconjunto de él presentado por un agente diferente a i, ya que es probable que esta nueva oferta pueda producir una solución mejor que la almacenada en la tabla C-Table[S]. Manejamos los dos casos mencionados anteriormente en las líneas 13 a 26 de cachedpausebid. En ambos casos, dado que gS debe contener una oferta por S, necesitamos encontrar un conjunto de ofertas que cubra los elementos faltantes, es decir, ¯S. Por lo tanto, nuestro espacio de búsqueda consiste en todas las ofertas en B para el conjunto de artículos ¯S o para un subconjunto de este. Construimos la lista de ofertas que contiene solo esas ofertas. Sin embargo, colocamos las ofertas de B al principio de las ofertas (línea 14) ya que son las que han cambiado. Entonces, reemplazamos las ofertas en las ofertas que tienen un precio menor que la valoración que el agente i tiene para esos mismos artículos con una oferta del agente i para esos artículos y un valor igual a la valoración de los agentes (líneas 16-19). El procedimiento recursivo cpbsearch, llamado en la línea 25 de cachedpausebid y mostrado en la Figura 4, es el que encuentra el nuevo gS. cpbsearch es una versión ligeramente modificada de nuestra búsqueda de ramificación y acotación implementada en pbsearch. La primera modificación es que tiene un tercer parámetro n que indica qué tan profundo en la lista de ofertas queremos buscar, ya que deja de buscar cuando n es menor o igual a cero y no solo cuando la lista de ofertas está vacía (línea 1). Cada vez que hay una llamada recursiva de cpbsearch, n se reduce en uno cuando una oferta de las ofertas es descartada o eliminada (líneas 12, 15, 21 y 24) y n permanece igual en caso contrario (líneas 20 y 23). Establecemos el valor de n antes de llamar a cpbsearch, para que sea el tamaño de la lista de ofertas (línea 21 de cachedpausebid) en el caso i), ya que queremos que cpbsearch busque en todas las ofertas; y establecemos n como el número de ofertas de B incluidas en las ofertas (línea 23 de cachedpausebid) en el caso ii), ya que sabemos que solo las primeras n ofertas en las ofertas cambiaron y pueden afectar nuestro gS actual. Otra diferencia con pbsearch es que el límite en cpbsearch es uS, que establecemos en 0 (línea 22 de cachedpausebid) en el caso i) y r(gS)−pago mínimo (línea 12 de cachedpausebid) en el caso ii). Llamamos a cpbsearch con g ya conteniendo una oferta para S. Después de que se ejecute cpbsearch, estamos seguros de que tenemos el gS correcto, por lo que lo almacenamos en la tabla C correspondiente [S] (línea 26 de la oferta en caché). Cuando llegamos a la línea 27 en cachedpausebid, estamos seguros de que tenemos el gS correcto. Sin embargo, los agentes en las subastas de gS todavía establecen sus propias valoraciones y no el precio más bajo posible. Si uS es mayor que el u∗ actual, las líneas 31 a 34 en cachedpausebid son responsables de establecer los pagos de los agentes para que puedan alcanzar su utilidad máxima uS. Como en pausebid, hemos decidido distribuir los pagos en proporción a la verdadera valoración de los agentes para cada conjunto de artículos. En el caso de que uS sea menor o igual a cero y la valoración que el agente i tiene para el conjunto de artículos S sea menor que el valor actual de la oferta en B para el mismo conjunto de artículos, eliminamos la C-Tabla[S] correspondiente, ya que sabemos que no vale la pena mantenerla en la tabla de caché (línea 38 de cachedpausebid). La función cachedpausebid se llama cuando k > 1 y devuelve el conjunto de ofertas que maximizan la utilidad miope de los agentes, si existe. Se asume que W y B permanecen constantes durante su ejecución. 698 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) genera valores(i, items) 1 para x ∈ items 2 hacer vi(x) = expd(.01) 3 para n ← 1 . . . (num-bids − items) 4 hacer s1, s2 ← Dos conjuntos aleatorios de items con valores. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figura 5: Algoritmo para la generación de funciones de valor aleatorias. expd(x) devuelve un número aleatorio tomado de una distribución exponencial con media 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 6: Porcentaje promedio de convergencia (eje y), que es el porcentaje de veces que nuestros algoritmos convergen a la solución que maximiza los ingresos, en función del número de items en la subasta. 5. PRUEBA Y COMPARACIÓN Hemos implementado ambos algoritmos y realizado una serie de experimentos para determinar cómo su solución se compara con la solución que maximiza los ingresos y cómo sus tiempos se comparan entre sí. Para realizar nuestras pruebas tuvimos que generar funciones de valor para los agentes. El algoritmo que utilizamos se muestra en la Figura 5. El tipo de valoraciones que genera corresponden a dominios donde un conjunto de agentes debe realizar un conjunto de tareas, pero hay ahorros de costos para agentes particulares si pueden agrupar ciertos subconjuntos de tareas. Por ejemplo, imagina un conjunto de robots que deben recoger y entregar artículos en diferentes ubicaciones. Dado que cada robot se encuentra en una ubicación diferente y tiene habilidades distintas, cada uno tendrá preferencias diferentes sobre cómo agrupar. Sus costos para los paquetes de artículos son subaditivos, lo que significa que sus preferencias son superaditivas. El primer experimento que realizamos simplemente aseguró la correcta 1. Nota que no pudimos usar CATS [6] porque genera conjuntos de ofertas para un número indeterminado de agentes. Es como si te dijeran el conjunto de ofertas realizadas en una subasta combinatoria, pero no quién realizó cada oferta o incluso cuántas personas realizaron ofertas, y luego te pidieran determinar la función de valor de cada participante en la subasta. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Número de elementos en caché Pausa de oferta 3 3 3 3 3 3 3 3 3 3 Pausa de oferta + + + + + + + + + + Figura 7: Porcentaje promedio de ingresos de nuestros algoritmos en relación con los ingresos máximos (eje y) en función del número de elementos en la subasta. funcionamiento de nuestros algoritmos. Luego comparamos las soluciones encontradas por ambos con la solución de maximización de ingresos encontrada por CASS cuando se les da un conjunto de ofertas que corresponde a la verdadera valoración de los agentes. Es decir, para cada agente i y cada conjunto de artículos S para los cuales vi(S) > 0 generamos una oferta. Este conjunto de ofertas fue introducido en CASS, que implementa un algoritmo centralizado de determinación de ganadores para encontrar la solución que maximiza los ingresos. Sin embargo, hay que tener en cuenta que los ingresos de la subasta de PAUSE en todas las subastas siempre son menores que los ingresos de la solución que maximiza los ingresos cuando los agentes ofrecen sus verdaderas valoraciones. Dado que PAUSE utiliza subastas inglesas, los precios finales (aproximadamente) representan la segunda valoración más alta, más , para ese conjunto de artículos. Fijamos el número de agentes en 5 y experimentamos con diferentes cantidades de artículos, concretamente de 2 a 10. Ejecutamos ambos algoritmos 100 veces para cada combinación. Cuando comparamos las soluciones de nuestros algoritmos con la solución que maximiza los ingresos, nos dimos cuenta de que no siempre encuentran la misma distribución de artículos que la solución que maximiza los ingresos (como se muestra en la Figura 6). Los casos en los que nuestros algoritmos no lograron llegar a la distribución de la solución que maximiza los ingresos son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de elementos. Si la solución que maximiza los ingresos contiene la oferta (o ofertas) utilizando estas valoraciones más altas, entonces es imposible que la subasta PAUSE encuentre esta solución porque esa oferta (esas ofertas) nunca se realiza. Por ejemplo, si el agente i tiene vi(1) = 1000 y la segunda valoración más alta para (1) es solo 10, entonces i solo necesita hacer una oferta de 11 para ganar ese artículo. Si la solución que maximiza los ingresos requiere que 1 se venda por 1000, entonces esa solución nunca se encontrará porque esa oferta nunca se realizará. También encontramos que el porcentaje promedio de veces que nuestros algoritmos convergen hacia la solución que maximiza los ingresos disminuye a medida que aumenta el número de elementos. Para 2 elementos es casi del 100%, pero disminuye un poco menos del 1 por ciento a medida que los elementos aumentan, por lo que este porcentaje promedio de convergencia es alrededor del 90% para 10 elementos. En algunas ocasiones, nuestros algoritmos encuentran soluciones diferentes debido a The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Número de elementos en cachéPausaOferta 3 3 3 3 3 3 3 3 3 PausaOferta + + + + + + + + + + Figura 8: Promedio de nodos expandidos (eje y) en función de los elementos en la subasta. orden de las ofertas en la lista de ofertas que hace que se busquen en diferente orden. Sabemos que los ingresos generados por la subasta de PAUSE suelen ser inferiores a los ingresos de la solución que maximiza los ingresos, pero ¿cuánto más bajos son? Para responder a esta pregunta, calculamos el porcentaje que representa la proporción de los ingresos proporcionados por nuestros algoritmos en relación con los ingresos proporcionados por CASS. Encontramos que el porcentaje de ingresos de nuestros algoritmos aumenta en promedio un 2.7% a medida que aumenta el número de artículos, como se muestra en la Figura 7. Sin embargo, descubrimos que cachedpausebid genera un mayor ingreso que pausebid (un 4.3% más en promedio) excepto en subastas con 2 artículos donde ambos tienen aproximadamente el mismo porcentaje. Nuevamente, esta diferencia es producida por el orden de la búsqueda. En el caso de 2 artículos, ambos algoritmos generan en promedio una proporción de ingresos del 67.4%, mientras que en el otro extremo (10 artículos), cachedpausebid generó en promedio una proporción de ingresos del 91.5%, mientras que pausebid generó en promedio una proporción de ingresos del 87.7%. La escalabilidad de nuestros algoritmos puede determinarse contando el número de nodos expandidos en el <br>árbol de búsqueda</br>. Para esto contamos el número de veces que se invoca pbsearch cada vez que se llama a pausebid y el número de veces que se invoca fastpausebidsearch cada vez que se llama a cachedpausebid, respectivamente para cada uno de nuestros algoritmos. Como era de esperar, dado que este es un problema NP-Difícil, el número de nodos expandidos crece exponencialmente con el número de elementos (como se muestra en la Figura 8). Sin embargo, descubrimos que cachedpausebid supera a pausebid, ya que en promedio expande menos de la mitad del número de nodos. Por ejemplo, el número promedio de nodos expandidos cuando hay 2 elementos es cero para cachedpausebid, mientras que para pausebid es 2; y en el otro extremo (10 elementos) cachedpausebid se expande en promedio solo 633 nodos, mientras que pausebid se expande en promedio en 1672 nodos, una diferencia de más de 1000 nodos. Aunque el número de nodos expandidos por nuestros algoritmos aumenta en función del número de elementos, el número real de nodos es mucho menor que el peor escenario de nn donde n es el número de elementos. Por ejemplo, para 10 artículos expandimos ligeramente más de 103 nodos para el caso de pausebid y menos que eso para el caso de cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Número de Artículos CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figura 9: Tiempo promedio en segundos que tarda en finalizar una subasta (eje y) en función del número de artículos en la subasta, que son números mucho menores que 1010. También hay que tener en cuenta que nuestro algoritmo de generación de valor (Figura 5) genera una cantidad de ofertas que es exponencial en el número de artículos, como podría esperarse en muchas situaciones. Por lo tanto, estos resultados no respaldan la conclusión de que el tiempo crece exponencialmente con el número de elementos cuando el número de ofertas es independiente del número de elementos. Esperamos que ambos algoritmos crezcan de forma exponencial en función del número de ofertas, pero se mantengan aproximadamente constantes a medida que crece el número de artículos. Queríamos asegurarnos de que menos nodos expandidos realmente se corresponde con una ejecución más rápida, especialmente dado que nuestros algoritmos ejecutan diferentes operaciones. Por lo tanto, ejecutamos el mismo experimento con todos los agentes en la misma máquina, un PC portátil Intel Centrino de 2.0 GHz con 1 GB de RAM y un disco duro de 60 GB a 7200 RPM, y calculamos el tiempo promedio que tarda en finalizar una subasta para cada algoritmo. Como se muestra en la Figura 9, cachedpausebid es más rápido que pausebid, la diferencia en la velocidad de ejecución es aún más clara a medida que aumenta el número de elementos. TRABAJO RELACIONADO Se ha realizado mucha investigación sobre varios aspectos de las subastas combinatorias. Recomendamos [2] para una buena reseña. Sin embargo, el estudio de algoritmos distribuidos para la determinación de ganadores en subastas combinatorias todavía es relativamente nuevo. Un enfoque está dado por los algoritmos para distribuir el problema de determinación del ganador en subastas combinatorias presentados en [7], pero estos algoritmos asumen que las entidades computacionales son los artículos que se están vendiendo y, por lo tanto, terminan con un tipo diferente de distribución. El algoritmo VSA [3] es otra forma de realizar la determinación distribuida del ganador en una subasta combinatoria, pero asume que las propias ofertas realizan el cálculo. Este algoritmo también falla en converger hacia una solución en la mayoría de los casos. En [9] los autores presentan un mecanismo distribuido para calcular los pagos VCG en un problema de diseño de mecanismos. Su mecanismo se resume aproximadamente en hacer que cada agente calcule los pagos para otros dos agentes y se los entregue a un 700 seguro de The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) tiene un servidor central que luego verifica que los resultados de todos los pares estén de acuerdo; de lo contrario, se ordena una nueva recalcuación. Esta idea general, a la que llaman principio de redundancia, también podría aplicarse a nuestro problema, pero requiere la existencia de un agente central seguro en el que todos confíen. Otro enfoque interesante se presenta en [8] donde los agentes de oferta priorizan sus ofertas, reduciendo así el conjunto de ofertas que el algoritmo centralizado de determinación de ganadores debe considerar, facilitando así ese problema. Finalmente, en el proceso de cálculo de la subasta de reloj [1], a los agentes se les otorga un porcentaje cada vez mayor del excedente logrado por su solución propuesta sobre la mejor actual. Por lo tanto, asume que los agentes son entidades computacionales imparciales, no el conjunto de posibles compradores como asume la subasta PAUSE. 7. CONCLUSIONES Creemos que las soluciones distribuidas al problema de determinación del ganador deberían ser estudiadas, ya que ofrecen un mejor ajuste para algunas aplicaciones, como cuando, por ejemplo, los agentes no desean revelar sus valoraciones al subastador o cuando deseamos distribuir la carga computacional entre los postores. La subasta PAUSE es uno de los pocos enfoques para descentralizar el problema de determinación del ganador en subastas combinatorias. Con esta subasta, incluso podemos imaginar eliminar por completo al subastador y, en su lugar, hacer que cada agente realice la tarea del subastador. Sin embargo, mientras que PAUSE establece las reglas que los licitadores deben obedecer, no nos dice cómo los licitadores deben calcular sus ofertas. Hemos presentado dos algoritmos, pausebid y cachedpausebid, que los agentes ofertantes pueden utilizar para participar en una subasta de PAUSE. Ambos algoritmos implementan una estrategia de maximización de utilidad miope que garantiza encontrar el conjunto de ofertas que maximiza la utilidad de los agentes dado el conjunto de mejores ofertas pendientes en cualquier momento, sin considerar posibles ofertas futuras. Ambos algoritmos encuentran, la mayor parte del tiempo, la misma distribución de elementos que la solución que maximiza los ingresos. Los casos en los que nuestros algoritmos no lograron llegar a esa distribución son aquellos en los que había una gran brecha entre la primera y la segunda valoración para un conjunto (o conjuntos) de artículos. Dado que es un problema NP-Difícil, el tiempo de ejecución de nuestros algoritmos sigue siendo exponencial, pero es significativamente mejor que una búsqueda completa. pausebid realiza una búsqueda de ramificación y acotación completamente desde cero cada vez que se invoca. cachedpausebid almacena en caché soluciones parciales y realiza una búsqueda de ramificación y acotación solo en las pocas partes afectadas por los cambios en las ofertas entre tiempos consecutivos. cachedpausebid tiene un mejor rendimiento ya que explora menos nodos (menos de la mitad) y es más rápido. Como era de esperar, los ingresos generados por una subasta de PAUSE son inferiores a los ingresos de una solución de maximización de ingresos encontrada por un algoritmo centralizado de determinación de ganadores, sin embargo, descubrimos que cachedpausebid genera en promedio un 4.7% más de ingresos que pausebid. También descubrimos que los ingresos generados por nuestros algoritmos aumentan en función del número de artículos en la subasta. Nuestros algoritmos han demostrado que es factible implementar las complejas restricciones de coordinación respaldadas por subastas combinatorias sin necesidad de recurrir a un algoritmo centralizado de determinación de ganadores. Además, debido al diseño de la subasta PAUSE, los agentes en la subasta también tienen un incentivo para realizar el cálculo requerido. Nuestros algoritmos de oferta pueden ser utilizados por cualquier sistema multiagente que utilice subastas combinatorias para la coordinación, pero que prefiera no implementar un subastador centralizado. 8. REFERENCIAS [1] P. J. Cervecero. Adquisición descentralizada de computación y robustez computacional en un mercado inteligente. Teoría Económica, 13(1):41-92, enero de 1999. [2] P. Cramton, Y. Shoham y R. Steinberg, editores. Subastas combinatorias. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Actas de la Decimosexta Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly y R. Stenberg. Una subasta combinatoria con múltiples ganadores para el servicio universal. Ciencias de la Gestión, 46(4):586-596, 2000. [5] A. Land, S. Powell y R. Steinberg. PAUSA: Una subasta combinatoria computacionalmente viable. En Cramton et al. [2], capítulo 6, páginas 139-157. [6] K. Leyton-Brown, M. Pearson y Y. Shoham. Hacia un conjunto de pruebas universal para algoritmos de subasta combinatoria. En Actas de la 2ª conferencia de la ACM sobre comercio electrónico, páginas 66-76. ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi y J. M. Vidal. Algoritmos para la determinación distribuida de ganadores en subastas combinatorias. En el volumen de LNAI de AMEC/TADA. Springer, 2006. [8] S. Park y M. H. Rothkopf. Subastas con combinaciones permitidas determinadas endógenamente. Informe técnico, Centro de Investigación de Operaciones Rutgets, enero de 2001. RRR 3-2001. [9] D. C. Parkes y J. Shneidman. Implementaciones distribuidas de subastas de Vickrey-Clarke-Groves. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [11] T. Sandholm. Un algoritmo para la determinación del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, febrero de 2002. [12] T. Sandholm, S. Suri, A. Gilpin y D. Levine. CABOB: un algoritmo óptimo y rápido para la determinación del ganador en subastas combinatorias. Ciencia de la Gestión, 51(3):374-391, 2005. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 701 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "branch-on-bid tree": {
            "translated_key": "árbol de ramificación por oferta",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Bidding Algorithms for a Distributed Combinatorial Auction Benito Mendoza ∗ and Jos´e M. Vidal Computer Science and Engineering University of South Carolina Columbia, SC 29208 mendoza2@engr.sc.edu, vidal@sc.edu ABSTRACT Distributed allocation and multiagent coordination problems can be solved through combinatorial auctions.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized.",
                "The PAUSE auction is one of a few efforts to release the auctioneer from having to do all the work (it might even be possible to get rid of the auctioneer).",
                "It is an increasing price combinatorial auction that naturally distributes the problem of winner determination amongst the bidders in such a way that they have an incentive to perform the calculation.",
                "It can be used when we wish to distribute the computational load among the bidders or when the bidders do not wish to reveal their true valuations unless necessary.",
                "PAUSE establishes the rules the bidders must obey.",
                "However, it does not tell us how the bidders should calculate their bids.",
                "We have developed a couple of bidding algorithms for the bidders in a PAUSE auction.",
                "Our algorithms always return the set of bids that maximizes the bidders utility.",
                "Since the problem is NP-Hard, run time remains exponential on the number of items, but it is remarkably better than an exhaustive search.",
                "In this paper we present our bidding algorithms, discuss their virtues and drawbacks, and compare the solutions obtained by them to the revenue-maximizing solution found by a centralized winner determination algorithm.",
                "Categories and Subject Descriptors I.2.11 [Computing Methodologies]: Distributed Artificial Intelligence-Intelligent Agents, Multiagent Systems.",
                "General Terms Algorithms, Performance. 1.",
                "INTRODUCTION Both the research and practice of combinatorial auctions have grown rapidly in the past ten years.",
                "In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items.",
                "Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneers revenue.",
                "This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10].",
                "Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed.",
                "The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].",
                "Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem.",
                "Thus, several approaches and algorithms have been proposed to address the winner determination problem.",
                "However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners.",
                "Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12].",
                "We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.",
                "The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.",
                "PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them.",
                "However, it is not concerned with how the bidders determine what they should bid.",
                "In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility.",
                "Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agents utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS 2.",
                "THE PAUSE AUCTION A PAUSE auction for m items has m stages.",
                "Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items.",
                "At the end of this state we will know what the highest bid for each individual item is and who placed that bid.",
                "Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less.",
                "The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.",
                "Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset.",
                "At the end of each stage k all agents know the best bid for every subset of size k or less.",
                "Also, at any point in time after stage 1 has ended there is a standing bidset whose value increases monotonically as new bidsets are submitted.",
                "Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset.",
                "Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items.",
                "That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation.",
                "However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution.",
                "Our test results provide an answer to this question.",
                "The PAUSE auction makes the job of the auctioneer very easy.",
                "All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agents bidset that is not his does indeed correspond to some other agents previous bid.",
                "The computational problem shifts from one of winner determination to one of bid generation.",
                "Each agent must search over the space of all bidsets which contain at least one of its bids.",
                "The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset.",
                "Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).",
                "Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].",
                "We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer.",
                "That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid.",
                "The agents would have an incentive to perform their computation as it will increase their expected utility.",
                "Also, any lies about other agents bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids).",
                "Namely, the only one that can increase an agents bid value is the agent itself.",
                "Anyone claiming a higher value for some other agent is lying.",
                "The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent. 3.",
                "PROBLEM FORMULATION A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid).",
                "The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage.",
                "At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids.",
                "This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent is value function is given by vi(S) ∈ where S is a set of items.",
                "Given an agents value function and the current winning bidset W we can calculate the agents utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agents utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items.",
                "If the agent is not winning any items then its utility is zero.",
                "The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction.",
                "Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero).",
                "That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B. 4.",
                "BIDDING ALGORITHMS According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items.",
                "In this case, an agents dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item.",
                "Our algorithms focus on the subsequent stages: k > 1.",
                "When k > 1, agents have to find g∗ i .",
                "This can be done by performing a complete search on B.",
                "However, this approach is computationally expensive since it produces a large search tree.",
                "Our algorithms represent alternative approaches to overcome this expensive search. 4.1 The PAUSEBID Algorithm In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree.",
                "Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k) 1 my-bids ← ∅ 2 their-bids ← ∅ 3 for b ∈ B 4 do if bagent = i or vi(bitems ) > bvalue 5 then my-bids ← my-bids +new Bid(bitems , i, vi(bitems )) 6 else their-bids ← their-bids +b 7 for S ∈ subsets of k or fewer items such that vi(S) > 0 and ¬∃b∈Bbitems = S 8 do my-bids ← my-bids +new Bid(S, i, vi(S)) 9 bids ← my-bids + their-bids 10 g∗ ← ∅ £ Global variable 11 u∗ ← ui(W)£ Global variable 12 pbsearch(bids, ∅) 13 surplus ← b∈g∗ | bagent=i bvalue − B(bitems ) 14 if surplus = 0 15 then return g∗ 16 my-payment ← vi(g∗ ) − u∗ 17 for b ∈ g∗ | bagent = i 18 do if my-payment ≤ 0 19 then bvalue ← B(bitems ) 20 else bvalue ← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus 21 return g∗ Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agents valuation is higher than the current best bid, as given in B.",
                "We set the value of these bids to be the agents true valuation (but we wont necessarily be bidding true valuation, as we explain later).",
                "Similarly, we set their-bids to be the rest of the bids from B.",
                "Finally, the agents search list is simply the concatenation of my-bids and their-bids.",
                "Note that the agents own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9).",
                "The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids.",
                "This branch and bound search is implemented by pbsearch (Figure 2).",
                "Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.",
                "The bound we use is the maximum utility that the agent can expect to receive from a given set of bids.",
                "We call it u∗ .",
                "Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility.",
                "If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21).",
                "Note that we can determine the maximum utility only after the algorithm has searched over all of the agents own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agents utility will no longer increase.",
                "For example, pbsearch(bids, g) 1 if bids = ∅ then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g does not contain a bid from i 7 then return 8 if g includes all items 9 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 10 max-utility ← vi(g) − min-payment 11 if r(g) > r(W) and max-utility ≥ u∗ 12 then g∗ ← g 13 u∗ ← max-utility 14 pbsearch(bids, g − b) £ b is Out 15 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 16 if max-revenue ≤ r(W) 17 then pbsearch(bids, g − b) £ b is Out 18 elseif bagent = i 19 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 20 max-utility ← vi(g) − min-payment 21 if max-utility > u∗ 22 then pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 23 pbsearch(bids, g − b) £ b is Out 24 else 25 pbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g) £ b is In 26 pbsearch(bids, g − b) £ b is Out 27 return Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W).",
                "The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch.",
                "Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item.",
                "This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.",
                "To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the 696 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) agent.",
                "Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )>0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic.",
                "A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agents bids are in the list (pbsearch lines 6 and 7).",
                "The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent is utility.",
                "However, agent is bids in g∗ are still set to his own valuation and not to the lowest possible price.",
                "Lines 17 to 20 in pausebid are responsible for setting the agents payments so that it can achieve its maximum utility u∗ .",
                "If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agents true valuation.",
                "However, if the agent has more than one bid then we face the problem of how to distribute the agents payments among these bids.",
                "There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.",
                "We have chosen to distribute the payments in proportion to the agents true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agents myopic utility-maximizing bidset (if there is one) using a branch and bound search.",
                "However it repeats the whole search at every stage.",
                "We can minimize this problem by caching the result of previous searches. 4.2 The CACHEDPAUSEBID Algorithm The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction.",
                "It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time.",
                "The problem is the same; the agent i has to find g∗ i .",
                "We note that g∗ i is a bidset that contains at least one bid of the agent i.",
                "Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) > 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue > B(bitems )) and (∃b∈gbitems = S and bagent = i).",
                "That is, gS i is is best bidset for all items which includes a bid from i for all S items.",
                "In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) > 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agents utility.",
                "That is g∗ i = arg max {S | vi(S)>0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) > 0.",
                "We can cachedpausebid(i, k, k-changed) 1 for each S in C-Table 2 do if vi(S) < B(S) 3 then remove S from C-Table 4 else if k-changed and size(S) = k 5 then B ← B + new Bid(i, S, vi(S)) 6 g∗ ← ∅ 7 u∗ ← ui(W) 8 for each S with size(S) ≤ k in C-Table 9 do ¯S ← Items − S 10 gS ← C-Table[S] £ Global variable 11 min-payment ← max(r(W) + , b∈gS B(bitems )) 12 uS ← r(gS ) − min-payment £ Global variable 13 if (k-changed and size(S) = k) or (∃b∈B bitems ⊆ ¯S and bagent = i) 14 then B ← {b ∈ B |bitems ⊆ ¯S} 15 bids ← B +{b ∈ B|bitems ⊆ ¯S and b /∈ B } 16 for b ∈ bids 17 do if vi(bitems ) > bvalue 18 then bagent ← i 19 bvalue ← vi(bitems ) 20 if k-changed and size(S) = k 21 then n ← size(bids) 22 uS ← 0 23 else n ← size(B ) 24 g ← ∅ + new Bid(S, i, vi(S)) 25 cpbsearch(bids, g, n) 26 C-Table[S] ← gS 27 if uS > u∗ and r(gS ) ≥ r(W) + 28 then surplus ← b∈gS | bagent=i bvalue − B(bitems ) 29 if surplus > 0 30 then my-payment ← vi(gS ) − ui(gS ) 31 for b ∈ gS | bagent = i 32 do if my-payment ≤ 0 33 then bvalue ← B(bitems ) 34 else bvalue ← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus 35 u∗ ← ui(gS ) 36 g∗ ← gS 37 else if uS ≤ 0 and vi(S) < B(S) 38 then remove S from C-Table 39 return g∗ Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n) 1 if bids = ∅ or n ≤ 0 then return 2 b ← first(bids) 3 bids ← bids −b 4 g ← g + b 5 ¯Ig ← items not in g 6 if g includes all items 7 then min-payment ← max(0, r(W) + − (r(g) − ri(g)), b∈g | bagent=i B(bitems )) 8 max-utility ← vi(g) − min-payment 9 if r(g) > r(W) and max-utility ≥ uS 10 then gS ← g 11 uS ← max-utility 12 cpbsearch(bids, g − b, n − 1) £ b is Out 13 else max-revenue ← r(g) + max(h(¯Ig), hi(¯Ig)) 14 if max-revenue ≤ r(W) 15 then cpbsearch(bids, g − b, n − 1) £ b is Out 16 elseif bagent = i 17 then min-payment ← (r(W) + ) −(r(g) − ri(g)) − h(¯Ig) 18 max-utility ← vi(g) − min-payment 19 if max-utility > uS 20 then cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 21 cpbsearch(bids, g − b, n − 1) £ b is Out 22 else 23 cpbsearch({x ∈ bids | xitems ∩ bitems = ∅}, g, n + 1) £ b is In 24 cpbsearch(bids, g − b, n − 1) £ b is Out 25 return Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agents utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.",
                "Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B.",
                "Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage.",
                "Initially C-Table has one row or entry for each set S for which vi(S) > 0.",
                "We start by eliminating the entries corresponding to each set S for which vi(S) < B(S) from C-Table (line 3).",
                "Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider.",
                "We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8).",
                "But how do we know that the gS in C-Table[S] is still the best solution for S?",
                "There are only two cases when we are not sure about that and we need to do a search to update C-Table[S].",
                "These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].",
                "We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid.",
                "In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S.",
                "Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it.",
                "We build the list bids that contains only those bids.",
                "However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed.",
                "Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agents valuation (lines 16-19).",
                "The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.",
                "The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1).",
                "Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23).",
                "We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .",
                "Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii).",
                "We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).",
                "When we reach line 27 in cachedpausebid, we are sure that we have the right gS .",
                "However, agent is bids in gS are still set to his own valuation and not to the lowest possible price.",
                "If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agents payments so that it can achieve its maximum utility uS .",
                "As in pausebid, we have chosen to distribute the payments in proportion to the agents true valuation for each set of items.",
                "In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).",
                "The cachedpausebid function is called when k > 1 and returns the agents myopic utility-maximizing bidset, if there is one.",
                "It assumes that W and B remains constant during its execution. 698 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) generatevalues(i, items) 1 for x ∈ items 2 do vi(x) = expd(.01) 3 for n ← 1 . . . (num-bids − items) 4 do s1, s2 ←Two random sets of items with values. 5 vi(s1 ∪ s2) = vi(s1) + vi(s2) + expd(.01) Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction. 5.",
                "TEST AND COMPARISON We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other.",
                "In order to do our tests we had to generate value functions for the agents1 .",
                "The algorithm we used is shown in Figure 5.",
                "The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks.",
                "For example, imagine a set of robots which must pick up and deliver items to different locations.",
                "Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle.",
                "Their costs for the item bundles are subadditive, which means that their preferences are superadditive.",
                "The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents.",
                "It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms.",
                "We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents true valuation.",
                "That is, for each agent i and each set of items S for which vi(S) > 0 we generated a bid.",
                "This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue.",
                "Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations.",
                "Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.",
                "We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to 10.",
                "We ran both algorithms 100 times for each combination.",
                "When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6).",
                "The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed.",
                "For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item.",
                "If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.",
                "We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases.",
                "For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items.",
                "In a few instances our algorithms find different solutions this is due to the different The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.",
                "We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower?",
                "To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS.",
                "We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7.",
                "However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.",
                "Again, this difference is produced by the order of the search.",
                "In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.",
                "The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.",
                "For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms.",
                "As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8).",
                "However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.",
                "For example, the average number of nodes expanded when 2 items is zero for cachedpausebid while for pausebid is 2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.",
                "Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items.",
                "For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000 2 3 4 5 6 7 8 9 10 Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 .",
                "Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations.",
                "As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items.",
                "We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.",
                "We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations.",
                "We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm.",
                "As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases. 6.",
                "RELATED WORK A lot of research has been done on various aspects of combinatorial auctions.",
                "We recommend [2] for a good review.",
                "However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.",
                "One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution.",
                "The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation.",
                "This algorithm also fails to converge to a solution for most cases.",
                "In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem.",
                "Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure 700 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered.",
                "This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts.",
                "Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier.",
                "Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best.",
                "As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction. 7.",
                "CONCLUSIONS We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders.",
                "The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions.",
                "With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer.",
                "However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.",
                "We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction.",
                "Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agents utility given the set of outstanding best bids at any given time, without considering possible future bids.",
                "Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution.",
                "The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.",
                "As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster.",
                "As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid.",
                "We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.",
                "Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm.",
                "Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation.",
                "Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer. 8.",
                "REFERENCES [1] P. J.",
                "Brewer.",
                "Decentralized computation procurement and computational robustness in a smart market.",
                "Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.",
                "Combinatorial Auctions.",
                "MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553.",
                "Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg.",
                "A combinatorial auction with multiple winners for universal service.",
                "Management Science, 46(4):586-596, 2000. [5] A.",
                "Land, S. Powell, and R. Steinberg.",
                "PAUSE: A computationally tractable combinatorial auction.",
                "In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.",
                "Towards a universal test suite for combinatorial auction algorithms.",
                "In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.",
                "ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal.",
                "Algorithms for distributed winner determination in combinatorial auctions.",
                "In LNAI volume of AMEC/TADA.",
                "Springer, 2006. [8] S. Park and M. H. Rothkopf.",
                "Auctions with endogenously determined allowable combinations.",
                "Technical report, Rutgets Center for Operations Research, January 2001.",
                "RRR 3-2001. [9] D. C. Parkes and J. Shneidman.",
                "Distributed implementations of vickrey-clarke-groves auctions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268.",
                "ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinational auctions.",
                "Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm.",
                "An algorithm for winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.",
                "CABOB: a fast optimal algorithm for winner determination in combinatorial auctions.",
                "Management Science, 51(3):374-391, 2005.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 701"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        }
    }
}