{
    "id": "C-46",
    "original_text": "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends. We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors. We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies. At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries. At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index. We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors. Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks. Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1. Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years. Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users. To achieve its goals, a typical sensor application needs access to both live and past sensor data. Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events. Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency. There have been a spectrum of approaches for constructing sensor storage systems. In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time. Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead. In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive. Further, all data is propagated to the server, regardless of whether it is ever used by the application. An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads. A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing. More complex read requests are handled by flooding. For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system. Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads. Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors. Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing. Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1. The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage. In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items. Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table. A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach. Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained. In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors. TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction. We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks. Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors. No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers. Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet. Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars. An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication. Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads. These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks. TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor. Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs. The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors. This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors. In-network index lookups are eliminated, reducing network overheads for read requests. This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks. To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks. Our design and implementation of TSAR has resulted in four contributions. At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper. This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able. This data structure has O(log n) expected search and update complexity. Further, the index provides a logically unified view of all data in the system. Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory. Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors. Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms. Further, the local store is optimized for time-series access to archived data, as is typical in many applications. Each sensor periodically sends a summary of its data to a proxy. TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries. More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives. Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors. Our implementation supports spatio-temporal, value, and rangebased queries on sensor data. Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype. While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting. Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network . The remainder of this paper is structured as follows. Section 2 presents key design issues that guide our work. Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively. Section 5 discusses our prototype implementation, and Section 6 presents our experimental results. We present related work in Section 7 and our conclusions in Section 8. 2. Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work. We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1). The lowest tier is assumed to form a dense deployment of lowpower sensors. A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB). The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint. The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited. In general, we assume radio communication to be substantially more expensive than accesses to flash memory. The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously. In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes. In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell. Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity. A typical sensor network deployment will contain multiple geographically distributed proxies. For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity. At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20]. In this work, we focus on applications that require access to past sensor data. To support such queries, the system needs to archive data on a persistent store. Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it. A large fraction of queries on sensor data can be expected to be spatio-temporal in nature. Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred. Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring). Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time. In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering. There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18]. However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures. Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values. Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value. Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries. Specifically, if a sensor reports a numerical value, then the index is constructed on these values. A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly. Hybrid value and spatio-temporal queries are also possible. Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August. These queries require an index on both time and value. In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future. For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission. But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data. We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search. To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system. Examples of this metadata are data attributes such as location and time, or selected or summarized data values. We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors. The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups. Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated. We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data. This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies. The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata. This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application. In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location. Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data. In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy. The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record. The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series. The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system. Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor. Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors. There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task. Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches. The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for. However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources. The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives. Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3. Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values. Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13]. The resulting data structure has two properties that make it ideal for sensor networks. First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval. Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value. Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data. Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network. Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy. Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi]. These intervals can correspond to time or value ranges that are used for indexing sensor data. No assumption is made about the size of an interval or about the amount of overlap between intervals. Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq]. The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently. In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1]. Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key. Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node. In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers. Lookups make use of ordered comparisons between the search key and existing index entries. In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed. Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root. In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes. In Figure 2 we see the process of searching for a particular value in a skip graph. The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on. Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse. In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level. We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n). Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows. In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows. The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain. Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion. The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1. To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain. One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string. Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level. Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries. In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}. Our data structure can be extended to range searches in a straightforward manner. The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree. The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key. Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk). The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound). To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors. To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.) If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done. Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done. Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism. Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree. The complexity of search is O(log n). The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query. Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry. For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element. It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed. The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost. In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node. These two modifications allow us to achieve reductions in asymptotic complexity of both update and search. As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree. The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting. However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system. If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings. Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements. When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements. An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.) When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements. The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1). An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages. Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.) Note that since searches are started at root elements of expected height log2 n, search complexity is not improved. For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case. In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree. Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root. In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element. The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps. To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages. The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message. Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph. By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived. A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data. Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue. Two distributed B-Trees were examined - P-Trees [6] and RP* [19]. Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures. DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4. Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier. TSAR implements two key mechanisms at the sensor tier. The first is a local archival store at each sensor node that is optimized for resource-constrained devices. The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics. The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query. These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy. To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data. While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained. Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting. Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store. Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data. In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing. Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection. Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer. The format of each data record is shown in Figure 6. Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc. Raw sensor data is stored in the data field of the record. The data field is opaque and application-specific-the storage system does not know or care about interpreting this field. A camera-based sensor, for instance, may store binary images in this data field. In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another. Our archival store supports three operations on records: create, read, and delete. Due to the append-only nature of the store, creation of records is simple and efficient. The create operation simply creates a new record and appends it to the tail of the store. Since records are always written at the tail, the store need not maintain a free space list. All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record. Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries. In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records. However, this can be quite complex for a small sensor node with limited resources. Consequently, TSAR sensors do not maintain any index for the data stored in their archive. Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory. The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7). Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy. Within this collection, records are accessed sequentially. When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address. Any queryspecific operation can then be performed on this data. Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management. The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy. While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications. This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data. When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy. Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive. In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both). The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value. As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries. The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data. TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives. The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive. If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio. If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits. The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary. Our focus in this paper is on the interval over which the summary is constructed. Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper. Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5. TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed. Our prototype employs Crossbow Stargate nodes to implement the proxy tier. Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1. The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver. The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication. The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor. The sensor nodes run TinyOS 1.1.8. In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector. The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives. Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier. In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up. Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory. The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6. The Mote sends a report to the proxy every N readings, summarizing the observed data. The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number. The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network. Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2). Spatial constraints are specified using sensor IDs. Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch. A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data). In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy. Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6. Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations. The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy. Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings. Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform. Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy. One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy. The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days. The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space. Our experimental evaluation has four parts. First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets. Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies. These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes. We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier. Finally, we demonstrate the adaptive summarization capability at each sensor node. The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads. We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets. For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index. Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well. Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages. Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost. Next, we evaluate the lookup performance of the index structure. Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure. Figures 9(a) and (b) depict our results. There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals. The initial lookup can be seen to takes log n messages, as expected. The costs of the subsequent linear traversal, however, are highly data dependent. For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)). The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b). Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance. We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies. We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups. Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs. Figure 10(a) depicts our results. In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements. This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure. Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases. Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade. Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures. In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element. Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure. Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible. To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries. TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries. Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used. The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy. Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case. However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture. Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements. In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature. For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote. The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device. The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table. Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead. Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers. In our setup, there are four proxies connected via 802.11 links and three sensors per proxy. The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3. Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size. Our evaluation metric is the end-to-end latency of query processing. A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s). The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user. We first measure query latency for different sensors in our multi-hop topology. Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)). Figure 11(b) provides a breakdown of the various components of the end-to-end latency. The dominant component of the total latency is the communication over one or more hops. The typical time to communicate over one hop is approximately 300ms. This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased. The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size. Not surprisingly, the overhead seen at the sensor is independent of the index size. The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency. This result is shown in Figure 12(a). The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads. As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet. Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor. Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query. The coarser the summary, the larger the memory region that needs to be accessed. For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size. In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element. More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost. With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported. However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values. These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports. The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits. As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases. Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled. The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant. To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity. We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples. As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7. Related Work In this section, we review prior work on storage and indexing techniques for sensor networks. While our work addresses both problems jointly, much prior work has considered them in isolation. The problem of archival storage of sensor data has received limited attention in sensor network literature. ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14]. Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives. Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources. In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors. The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data. In order to efficiently access a distributed sensor store, an index needs to be constructed of the data. Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored. Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events. The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g.: find temperature in the south-west quadrant), and if not, the query is flooded throughout the network. These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries. Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9]. Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18]. One such scheme is DCS [26], which provides a hash function for mapping from event name to location. DCS constructs a distributed structure that groups events together spatially by their named type. Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data. While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables. TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers. Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple. In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work. DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search. While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8. Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks. We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies. At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries. At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure. We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors. Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9. REFERENCES [1] James Aspnes and Gauri Shah. Skip graphs. In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley. Multidimensional binary search trees used for associative searching. Commun. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri. Towards sensor database systems. In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon. CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms. The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram. Querying Peer-to-Peer Networks Using P-Trees. Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han. ELF: an efficient log-structured flash file system for micro sensor nodes. In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy. PRESTO: A predictive storage architecture for sensor networks. In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann. An evaluation of multi-resolution storage in sensor networks. In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer. A system for simulation, emulation, and deployment of heterogeneous sensor networks. In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker. DIFS: A distributed index for features in sensor networks. Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman. R-trees: a dynamic index structure for spatial searching. In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman. Skipnet: A scalable overlay network with practical locality properties. In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister. System architecture directions for networked sensors. In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin. Directed diffusion: A scalable and robust communication paradigm for sensor networks. In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong. Multi-dimensional range queries in sensor networks. In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider. RP*: A family of order preserving scalable distributed data structures. In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong. TAG: a tiny aggregation service for ad-hoc sensor networks. In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki. High performance, low power sensor platforms featuring gigabyte scale storage. In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler. Versatile low power media access for wireless sensor networks. In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh. Skip lists: a probabilistic alternative to balanced trees. Commun. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. Data-centric storage in sensornets. In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker. A scalable content addressable network. In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker. GHT - a geographic hash-table for data-centric storage. In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. James Reserve Data. 50",
    "original_translation": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para redes de sensores inalámbricos. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50",
    "original_sentences": [
        "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
        "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
        "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
        "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
        "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
        "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
        "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
        "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
        "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
        "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
        "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
        "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
        "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
        "There have been a spectrum of approaches for constructing sensor storage systems.",
        "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
        "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
        "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
        "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
        "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
        "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
        "More complex read requests are handled by flooding.",
        "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
        "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
        "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
        "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
        "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
        "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
        "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
        "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
        "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
        "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
        "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
        "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
        "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
        "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
        "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
        "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
        "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
        "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
        "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
        "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
        "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
        "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
        "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
        "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
        "In-network index lookups are eliminated, reducing network overheads for read requests.",
        "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
        "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
        "Our design and implementation of TSAR has resulted in four contributions.",
        "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
        "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
        "This data structure has O(log n) expected search and update complexity.",
        "Further, the index provides a logically unified view of all data in the system.",
        "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
        "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
        "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
        "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
        "Each sensor periodically sends a summary of its data to a proxy.",
        "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
        "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
        "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
        "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
        "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
        "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
        "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
        "The remainder of this paper is structured as follows.",
        "Section 2 presents key design issues that guide our work.",
        "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
        "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
        "We present related work in Section 7 and our conclusions in Section 8. 2.",
        "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
        "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
        "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
        "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
        "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
        "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
        "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
        "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
        "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
        "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
        "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
        "A typical sensor network deployment will contain multiple geographically distributed proxies.",
        "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
        "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
        "In this work, we focus on applications that require access to past sensor data.",
        "To support such queries, the system needs to archive data on a persistent store.",
        "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
        "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
        "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
        "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
        "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
        "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
        "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
        "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
        "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
        "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
        "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
        "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
        "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
        "Hybrid value and spatio-temporal queries are also possible.",
        "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
        "These queries require an index on both time and value.",
        "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
        "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
        "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
        "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
        "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
        "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
        "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
        "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
        "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
        "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
        "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
        "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
        "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
        "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
        "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
        "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
        "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
        "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
        "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
        "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
        "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
        "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
        "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
        "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
        "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
        "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
        "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
        "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
        "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
        "The resulting data structure has two properties that make it ideal for sensor networks.",
        "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
        "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
        "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
        "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
        "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
        "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
        "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
        "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
        "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
        "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
        "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
        "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
        "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
        "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
        "Lookups make use of ordered comparisons between the search key and existing index entries.",
        "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
        "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
        "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
        "In Figure 2 we see the process of searching for a particular value in a skip graph.",
        "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
        "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
        "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
        "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
        "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
        "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
        "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
        "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
        "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
        "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
        "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
        "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
        "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
        "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
        "Our data structure can be extended to range searches in a straightforward manner.",
        "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
        "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
        "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
        "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
        "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
        "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
        "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
        "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
        "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
        "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
        "The complexity of search is O(log n).",
        "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
        "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
        "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
        "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
        "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
        "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
        "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
        "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
        "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
        "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
        "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
        "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
        "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
        "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
        "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
        "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
        "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
        "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
        "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
        "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
        "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
        "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
        "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
        "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
        "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
        "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
        "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
        "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
        "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
        "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
        "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
        "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
        "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
        "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
        "TSAR implements two key mechanisms at the sensor tier.",
        "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
        "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
        "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
        "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
        "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
        "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
        "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
        "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
        "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
        "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
        "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
        "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
        "The format of each data record is shown in Figure 6.",
        "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
        "Raw sensor data is stored in the data field of the record.",
        "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
        "A camera-based sensor, for instance, may store binary images in this data field.",
        "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
        "Our archival store supports three operations on records: create, read, and delete.",
        "Due to the append-only nature of the store, creation of records is simple and efficient.",
        "The create operation simply creates a new record and appends it to the tail of the store.",
        "Since records are always written at the tail, the store need not maintain a free space list.",
        "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
        "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
        "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
        "However, this can be quite complex for a small sensor node with limited resources.",
        "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
        "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
        "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
        "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
        "Within this collection, records are accessed sequentially.",
        "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
        "Any queryspecific operation can then be performed on this data.",
        "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
        "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
        "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
        "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
        "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
        "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
        "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
        "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
        "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
        "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
        "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
        "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
        "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
        "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
        "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
        "Our focus in this paper is on the interval over which the summary is constructed.",
        "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
        "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
        "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
        "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
        "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
        "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
        "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
        "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
        "The sensor nodes run TinyOS 1.1.8.",
        "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
        "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
        "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
        "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
        "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
        "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
        "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
        "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
        "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
        "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
        "Spatial constraints are specified using sensor IDs.",
        "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
        "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
        "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
        "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
        "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
        "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
        "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
        "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
        "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
        "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
        "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
        "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
        "Our experimental evaluation has four parts.",
        "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
        "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
        "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
        "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
        "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
        "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
        "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
        "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
        "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
        "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
        "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
        "Next, we evaluate the lookup performance of the index structure.",
        "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
        "Figures 9(a) and (b) depict our results.",
        "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
        "The initial lookup can be seen to takes log n messages, as expected.",
        "The costs of the subsequent linear traversal, however, are highly data dependent.",
        "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
        "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
        "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
        "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
        "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
        "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
        "Figure 10(a) depicts our results.",
        "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
        "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
        "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
        "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
        "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
        "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
        "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
        "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
        "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
        "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
        "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
        "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
        "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
        "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
        "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
        "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
        "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
        "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
        "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
        "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
        "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
        "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
        "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
        "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
        "Our evaluation metric is the end-to-end latency of query processing.",
        "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
        "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
        "We first measure query latency for different sensors in our multi-hop topology.",
        "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
        "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
        "The dominant component of the total latency is the communication over one or more hops.",
        "The typical time to communicate over one hop is approximately 300ms.",
        "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
        "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
        "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
        "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
        "This result is shown in Figure 12(a).",
        "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
        "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
        "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
        "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
        "The coarser the summary, the larger the memory region that needs to be accessed.",
        "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
        "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
        "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
        "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
        "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
        "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
        "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
        "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
        "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
        "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
        "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
        "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
        "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
        "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
        "While our work addresses both problems jointly, much prior work has considered them in isolation.",
        "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
        "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
        "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
        "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
        "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
        "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
        "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
        "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
        "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
        "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
        "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
        "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
        "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
        "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
        "DCS constructs a distributed structure that groups events together spatially by their named type.",
        "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
        "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
        "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
        "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
        "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
        "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
        "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
        "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
        "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
        "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
        "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
        "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
        "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
        "REFERENCES [1] James Aspnes and Gauri Shah.",
        "Skip graphs.",
        "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
        "Multidimensional binary search trees used for associative searching.",
        "Commun.",
        "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
        "Towards sensor database systems.",
        "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
        "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
        "Introduction to Algorithms.",
        "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
        "Querying Peer-to-Peer Networks Using P-Trees.",
        "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
        "ELF: an efficient log-structured flash file system for micro sensor nodes.",
        "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
        "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
        "PRESTO: A predictive storage architecture for sensor networks.",
        "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
        "An evaluation of multi-resolution storage in sensor networks.",
        "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
        "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
        "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
        "DIFS: A distributed index for features in sensor networks.",
        "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
        "R-trees: a dynamic index structure for spatial searching.",
        "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
        "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
        "Skipnet: A scalable overlay network with practical locality properties.",
        "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
        "System architecture directions for networked sensors.",
        "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
        "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
        "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
        "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
        "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
        "Multi-dimensional range queries in sensor networks.",
        "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
        "RP*: A family of order preserving scalable distributed data structures.",
        "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
        "TAG: a tiny aggregation service for ad-hoc sensor networks.",
        "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
        "High performance, low power sensor platforms featuring gigabyte scale storage.",
        "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
        "Versatile low power media access for wireless sensor networks.",
        "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
        "Skip lists: a probabilistic alternative to balanced trees.",
        "Commun.",
        "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
        "Data-centric storage in sensornets.",
        "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
        "A scalable content addressable network.",
        "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
        "GHT - a geographic hash-table for data-centric storage.",
        "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
        "James Reserve Data. 50"
    ],
    "translated_text_sentences": [
        "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes.",
        "Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados.",
        "Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies.",
        "En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor.",
        "En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso.",
        "Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote.",
        "Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles.",
        "Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1.",
        "Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años.",
        "Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios.",
        "Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados.",
        "Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares.",
        "El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia.",
        "Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores.",
        "En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior.",
        "Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red.",
        "En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas.",
        "Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación.",
        "Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación.",
        "Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento.",
        "Las solicitudes de lectura más complejas son manejadas mediante inundación.",
        "Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema.",
        "Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red.",
        "Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores.",
        "Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes.",
        "Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1.",
        "El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores.",
        "En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes.",
        "Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red.",
        "Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque.",
        "La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía.",
        "En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados.",
        "TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción.",
        "Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores.",
        "Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos.",
        "Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles.",
        "Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo.",
        "Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares.",
        "Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación.",
        "Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red.",
        "Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores.",
        "TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor.",
        "Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos.",
        "Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores.",
        "Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes.",
        "Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura.",
        "Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores.",
        "Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes.",
        "Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones.",
        "En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo.",
        "Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores.",
        "Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n).",
        "Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema.",
        "En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash.",
        "Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores.",
        "El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados.",
        "Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones.",
        "Cada sensor envía periódicamente un resumen de sus datos a un proxy.",
        "TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación.",
        "Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos.",
        "Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote.",
        "Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores.",
        "En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo.",
        "Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real.",
        "Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo.",
        "El resto de este documento está estructurado de la siguiente manera.",
        "La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo.",
        "Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente.",
        "La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales.",
        "Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8.",
        "Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo.",
        "A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1).",
        "Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia.",
        "Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB).",
        "La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía.",
        "El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada.",
        "En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash.",
        "El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua.",
        "En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores.",
        "En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar.",
        "Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía.",
        "Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente.",
        "Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía.",
        "En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20].",
        "En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados.",
        "Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente.",
        "Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan.",
        "Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal.",
        "Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió.",
        "Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente).",
        "Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo.",
        "Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal.",
        "Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18].",
        "Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden.",
        "Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave.",
        "Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor.",
        "Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes.",
        "Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores.",
        "Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v.",
        "Las consultas híbridas de valor y espacio-temporales también son posibles.",
        "Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto.",
        "Estas consultas requieren un índice tanto en el tiempo como en el valor.",
        "En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano.",
        "Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas.",
        "Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos.",
        "Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva.",
        "Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento.",
        "Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos.",
        "Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos.",
        "Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia.",
        "Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información.",
        "Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados.",
        "Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies.",
        "Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación.",
        "Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación.",
        "En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor.",
        "Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos.",
        "Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano.",
        "El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro.",
        "La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real.",
        "El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema.",
        "Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor.",
        "Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores.",
        "Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea.",
        "Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas.",
        "El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado.",
        "Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red.",
        "Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos.",
        "Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos.",
        "En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular.",
        "Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13].",
        "La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores.",
        "Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo.",
        "En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor.",
        "La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor.",
        "Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles.",
        "Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy.",
        "Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi].",
        "Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores.",
        "No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos.",
        "Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq].",
        "El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente.",
        "En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1].",
        "La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave.",
        "Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo.",
        "En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros.",
        "Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes.",
        "Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados.",
        "Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda.",
        "Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos.",
        "En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto.",
        "Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente.",
        "La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer.",
        "En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel.",
        "Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n).",
        "La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece.",
        "De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece.",
        "El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena.",
        "Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples.",
        "La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1.",
        "Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía.",
        "Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga.",
        "Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel.",
        "Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor.",
        "En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}.",
        "Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla.",
        "El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos.",
        "El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave.",
        "Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk).",
        "El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior).",
        "Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda.",
        "Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.)",
        "Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado.",
        "De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado.",
        "Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo.",
        "Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos.",
        "La complejidad de la búsqueda es O(log n).",
        "El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta.",
        "En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada.",
        "Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido.",
        "Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos.",
        "El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red.",
        "Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo.",
        "Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda.",
        "Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo.",
        "La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido.",
        "Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema.",
        "Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos.",
        "Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz.",
        "Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz.",
        "Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.)",
        "Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz.",
        "El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1).",
        "Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales.",
        "Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1).",
        "Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora.",
        "Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso.",
        "En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol.",
        "Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz.",
        "En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento.",
        "La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos.",
        "Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes.",
        "La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje.",
        "Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo.",
        "Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva.",
        "Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales.",
        "Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema.",
        "Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19].",
        "Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras.",
        "DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4.",
        "Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor.",
        "TSAR implementa dos mecanismos clave en el nivel del sensor.",
        "El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados.",
        "La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas.",
        "El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta.",
        "Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy.",
        "Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor.",
        "Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos.",
        "Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados.",
        "Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR.",
        "Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados.",
        "Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales.",
        "Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos.",
        "Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer.",
        "El formato de cada registro de datos se muestra en la Figura 6.",
        "Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc.",
        "Los datos crudos del sensor se almacenan en el campo de datos del registro.",
        "El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo.",
        "Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos.",
        "Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro.",
        "Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar.",
        "Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente.",
        "La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda.",
        "Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre.",
        "Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro.",
        "Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas.",
        "En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros.",
        "Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados.",
        "Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo.",
        "En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash.",
        "El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7).",
        "Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy.",
        "Dentro de esta colección, los registros se acceden de forma secuencial.",
        "Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin.",
        "Cualquier operación específica de consulta puede realizarse en estos datos.",
        "Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor.",
        "El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy.",
        "Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos.",
        "Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos.",
        "Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy.",
        "Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash.",
        "En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos).",
        "El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor.",
        "Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas.",
        "Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen.",
        "TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos.",
        "La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local.",
        "Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos.",
        "Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos.",
        "La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación.",
        "Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen.",
        "Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento.",
        "Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5.",
        "Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles.",
        "Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy.",
        "Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1.",
        "Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar.",
        "La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies.",
        "La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L.",
        "Los nodos sensores ejecutan TinyOS 1.1.8.",
        "Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado.",
        "Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB.",
        "Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy.",
        "Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta.",
        "Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash.",
        "Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6.",
        "El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados.",
        "El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia.",
        "Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b.",
        "Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2).",
        "Las restricciones espaciales se especifican utilizando identificadores de sensores.",
        "Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación.",
        "Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos).",
        "Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy.",
        "Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6.",
        "En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones.",
        "El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy.",
        "Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes.",
        "Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware.",
        "En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy.",
        "Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy.",
        "El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días.",
        "El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores.",
        "Nuestra evaluación experimental tiene cuatro partes.",
        "Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos.",
        "Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación.",
        "Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes.",
        "Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota.",
        "Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor.",
        "El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación.",
        "Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos.",
        "Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice.",
        "Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también.",
        "La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes.",
        "Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar.",
        "A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice.",
        "Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice.",
        "Las figuras 9(a) y (b) representan nuestros resultados.",
        "Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes.",
        "La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba.",
        "Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos.",
        "Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)).",
        "Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b).",
        "Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto.",
        "Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies.",
        "Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas.",
        "Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares.",
        "La figura 10(a) representa nuestros resultados.",
        "En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos.",
        "Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura.",
        "Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta.",
        "El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse.",
        "El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy.",
        "En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz.",
        "Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo.",
        "Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles.",
        "Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes.",
        "TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares.",
        "Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo.",
        "El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal.",
        "Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal.",
        "Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento.",
        "Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas.",
        "Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura.",
        "Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2.",
        "Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo.",
        "La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla.",
        "Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo.",
        "Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas.",
        "En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy.",
        "La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3.",
        "Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor.",
        "Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas.",
        "Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s).",
        "El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario.",
        "Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos.",
        "Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)).",
        "La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo.",
        "El componente dominante de la latencia total es la comunicación a través de uno o más saltos.",
        "El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms.",
        "Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo.",
        "La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice.",
        "Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice.",
        "La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia.",
        "Este resultado se muestra en la Figura 12(a).",
        "La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes.",
        "A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional.",
        "Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor.",
        "Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta.",
        "Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder.",
        "Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda.",
        "Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado.",
        "Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información.",
        "Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado.",
        "Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores.",
        "Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes.",
        "El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos.",
        "A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye.",
        "A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado.",
        "El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña.",
        "Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización.",
        "Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras.",
        "Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7.",
        "Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores.",
        "Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada.",
        "El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores.",
        "ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14].",
        "Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales.",
        "El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento.",
        "Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos.",
        "La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos.",
        "Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos.",
        "Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos.",
        "Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos.",
        "El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red.",
        "Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes.",
        "Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9].",
        "Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18].",
        "Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación.",
        "DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado.",
        "El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos.",
        "Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes.",
        "TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles.",
        "Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo.",
        "Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo.",
        "Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos.",
        "Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8.",
        "En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes.",
        "Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies.",
        "En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango.",
        "En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa.",
        "Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote.",
        "Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles.",
        "REFERENCIAS [1] James Aspnes y Gauri Shah.",
        "Gráficos de salto.",
        "En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley.",
        "Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas.",
        "Comunicación.",
        "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri.",
        "Hacia sistemas de bases de datos de sensores.",
        "En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon.",
        "Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein.",
        "Introducción a los algoritmos.",
        "El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram.",
        "Consultando redes peer-to-peer utilizando árboles P.",
        "Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han.",
        "ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores.",
        "En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004.",
        "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy.",
        "PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores.",
        "En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann.",
        "Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores.",
        "En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer.",
        "Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas.",
        "En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker.",
        "DIFS: Un índice distribuido para características en redes de sensores.",
        "Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman.",
        "R-trees: una estructura de índice dinámica para búsquedas espaciales.",
        "En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984.",
        "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman.",
        "Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas.",
        "En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister.",
        "Direcciones de arquitectura del sistema para sensores en red.",
        "En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000.",
        "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin.",
        "Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores.",
        "En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000.",
        "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong.",
        "Consultas de rango multidimensionales en redes de sensores.",
        "En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider.",
        "RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden.",
        "En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong.",
        "TAG: un pequeño servicio de agregación para redes de sensores ad-hoc.",
        "En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki.",
        "Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes.",
        "En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler.",
        "Acceso a medios de baja potencia versátil para redes de sensores inalámbricos.",
        "En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh.",
        "Listas de salto: una alternativa probabilística a los árboles balanceados.",
        "This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish.",
        "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu.",
        "Almacenamiento centrado en datos en redes de sensores.",
        "En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker.",
        "Una red escalable de direcciones de contenido.",
        "En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker.",
        "GHT - una tabla hash geográfica para almacenamiento centrado en datos.",
        "En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
        "Datos de la Reserva James. 50"
    ],
    "error_count": 9,
    "keys": {
        "sensor datum": {
            "translated_key": "dato del sensor",
            "is_in_text": false,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "separation of datum": {
            "translated_key": "separación de datos",
            "is_in_text": false,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "datum separation": {
            "translated_key": "separación de datos",
            "is_in_text": false,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "analysis": {
            "translated_key": "análisis",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, <br>analysis</br> of historical trends, and post-mortem <br>analysis</br> of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the <br>analysis</br> in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance <br>analysis</br> of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, <br>analysis</br> of historical trends, and post-mortem <br>analysis</br> of particular events.",
                "Although the resulting structure is not perfectly balanced, following the <br>analysis</br> in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance <br>analysis</br> of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler."
            ],
            "translated_annotated_samples": [
                "Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, <br>análisis</br> de tendencias históricas y <br>análisis</br> post mortem de eventos particulares.",
                "Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el <br>análisis</br> en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor.",
                "En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, <br>análisis</br> de tendencias históricas y <br>análisis</br> post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el <br>análisis</br> en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para redes de sensores inalámbricos. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "archive": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local <br>archive</br> that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local <br>archive</br> and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data <br>archive</br> on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to <br>archive</br> data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to <br>archive</br> data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local <br>archive</br> and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local <br>archive</br> in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their <br>archive</br>.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the <br>archive</br> is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash <br>archive</br>.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local <br>archive</br>.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local <br>archive</br> (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local <br>archive</br>, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local <br>archive</br>, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "Second, at the sensor level, each sensor maintains a local <br>archive</br> that stores data on flash memory.",
                "Section 3 and 4 present the proxy-level index and the local <br>archive</br> and summarization at a sensor, respectively.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data <br>archive</br> on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "To support such queries, the system needs to <br>archive</br> data on a persistent store.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to <br>archive</br> data locally, substituting cheap memory operations for expensive radio transmission."
            ],
            "translated_annotated_samples": [
                "En segundo lugar, a nivel del sensor, cada sensor mantiene un <br>archivo</br> local que almacena datos en memoria flash.",
                "Las secciones 3 y 4 presentan el índice a nivel de proxy y el <br>archivo</br> local y la sumarización en un sensor, respectivamente.",
                "El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua.",
                "Para respaldar tales consultas, el sistema necesita archivar datos en un <br>almacenamiento persistente</br>.",
                "Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para <br>archivar</br> datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un <br>archivo</br> local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el <br>archivo</br> local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un <br>almacenamiento persistente</br>. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para <br>archivar</br> datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. ",
            "candidates": [],
            "error": [
                [
                    "archivo",
                    "archivo",
                    "almacenamiento persistente",
                    "archivar"
                ]
            ]
        },
        "flooding": {
            "translated_key": "inundación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by <br>flooding</br>.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require <br>flooding</br>, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for <br>flooding</br> in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index <br>flooding</br>, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then <br>flooding</br> queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "More complex read requests are handled by <br>flooding</br>.",
                "Requests that require <br>flooding</br>, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for <br>flooding</br> in this approach.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index <br>flooding</br>, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "Indexing locally using an appropriate singlenode structure and then <br>flooding</br> queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue."
            ],
            "translated_annotated_samples": [
                "Las solicitudes de lectura más complejas son manejadas mediante <br>inundación</br>.",
                "Las solicitudes que requieren <br>inundación</br>, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores.",
                "Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de <br>inundación</br> en este enfoque.",
                "El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua.",
                "Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante <br>inundación</br>. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren <br>inundación</br>, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de <br>inundación</br> en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "geographic hash table": {
            "translated_key": "tabla hash geográfica",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The <br>geographic hash table</br> (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or <br>geographic hash table</br> is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "The <br>geographic hash table</br> (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or <br>geographic hash table</br> is used to map keys to nodes that store the corresponding data items."
            ],
            "translated_annotated_samples": [
                "El enfoque de la <br>tabla hash geográfica</br> (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores.",
                "En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la <br>tabla hash geográfica</br> (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para redes de sensores inalámbricos. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "homogeneous architecture": {
            "translated_key": "arquitectura plana y homogénea",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, <br>homogeneous architecture</br> in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "Most of these approaches assume a flat, <br>homogeneous architecture</br> in which every sensor node is energy-constrained."
            ],
            "translated_annotated_samples": [
                "La mayoría de estos enfoques asumen una <br>arquitectura plana y homogénea</br> en la que cada nodo sensor está limitado por energía."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una <br>arquitectura plana y homogénea</br> en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para redes de sensores inalámbricos. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "multi-tier sensor network": {
            "translated_key": "red de sensores de múltiples niveles",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a <br>multi-tier sensor network</br> assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a <br>multi-tier sensor network</br> comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a <br>multi-tier sensor network</br>. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a <br>multi-tier sensor network</br> testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "Design Considerations In this section, we first describe the various components of a <br>multi-tier sensor network</br> assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a <br>multi-tier sensor network</br> comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a <br>multi-tier sensor network</br>. these resources continuously.",
                "TSAR Implementation We have implemented a prototype of TSAR on a <br>multi-tier sensor network</br> testbed."
            ],
            "translated_annotated_samples": [
                "Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una <br>red de sensores de múltiples niveles</br> asumida en nuestro trabajo.",
                "A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una <br>red de sensores de múltiples niveles</br> que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1).",
                "El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua.",
                "Hemos implementado un prototipo de TSAR en un banco de pruebas de <br>red de sensores de múltiples niveles</br>."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una <br>red de sensores de múltiples niveles</br> asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una <br>red de sensores de múltiples niveles</br> que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de <br>red de sensores de múltiples niveles</br>. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para redes de sensores inalámbricos. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "flash storage": {
            "translated_key": "almacenamiento flash",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of <br>flash storage</br> for a few tens of dollars.",
                "An even more compelling argument is the energy cost of <br>flash storage</br>, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND <br>flash storage</br> [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient <br>flash storage</br> at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "Thus it will soon be feasible to equip each sensor with 1 GB of <br>flash storage</br> for a few tens of dollars.",
                "An even more compelling argument is the energy cost of <br>flash storage</br>, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND <br>flash storage</br> [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient <br>flash storage</br> at each sensor."
            ],
            "translated_annotated_samples": [
                "Por lo tanto, pronto será factible equipar cada sensor con 1 GB de <br>almacenamiento flash</br> por unos pocos dólares.",
                "Un argumento aún más convincente es el costo energético del <br>almacenamiento flash</br>, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación.",
                "Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un <br>almacenamiento flash</br> NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red.",
                "TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el <br>almacenamiento flash</br> de bajo consumo energético en cada sensor."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de <br>almacenamiento flash</br> por unos pocos dólares. Un argumento aún más convincente es el costo energético del <br>almacenamiento flash</br>, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un <br>almacenamiento flash</br> NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el <br>almacenamiento flash</br> de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para redes de sensores inalámbricos. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "metada": {
            "translated_key": "metadatos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from <br>metada</br>ta by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting <br>metada</br>ta to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term <br>metada</br>ta, to a nearby proxy; depending on the representation used, this <br>metada</br>ta may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the <br>metada</br>ta reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the <br>metada</br>ta, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the <br>metada</br>ta index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of <br>metada</br>ta updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from <br>metada</br>ta: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate <br>metada</br>ta with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this <br>metada</br>ta are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index <br>metada</br>ta for resource-constrained sensors.",
                "The proxies share this <br>metada</br>ta index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from <br>metada</br>ta indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain <br>metada</br>ta in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific <br>metada</br>ta.",
                "This <br>metada</br>ta is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this <br>metada</br>ta might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this <br>metada</br>ta may be two or three orders of magnitude smaller than the data itself, for instance if the <br>metada</br>ta consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported <br>metada</br>ta to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the <br>metada</br>ta associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the <br>metada</br>ta overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a <br>metada</br>ta field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this <br>metada</br>ta index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends <br>metada</br>ta to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the <br>metada</br>ta associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing <br>metada</br>ta are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from <br>metada</br>ta by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting <br>metada</br>ta to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from <br>metada</br>ta by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting <br>metada</br>ta to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "Sensors send concise identifying information, which we term <br>metada</br>ta, to a nearby proxy; depending on the representation used, this <br>metada</br>ta may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the <br>metada</br>ta reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This separation of data, which is stored at the sensors, and the <br>metada</br>ta, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks."
            ],
            "translated_annotated_samples": [
                "Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de <br>metadatos</br> mediante el uso de archivado local en los sensores e indexación distribuida en los proxies.",
                "En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir <br>metadatos</br> a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso.",
                "Los sensores envían información identificativa concisa, que denominamos <br>metadatos</br>, a un proxy cercano; dependiendo de la representación utilizada, estos <br>metadatos</br> pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos.",
                "Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los <br>metadatos</br> reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores.",
                "Esta separación de datos, que se almacenan en los sensores, y los <br>metadatos</br>, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de <br>metadatos</br> mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir <br>metadatos</br> a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos <br>metadatos</br>, a un proxy cercano; dependiendo de la representación utilizada, estos <br>metadatos</br> pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los <br>metadatos</br> reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los <br>metadatos</br>, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "distributed index structure": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered <br>distributed index structure</br>, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel <br>distributed index structure</br> based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered <br>distributed index structure</br>, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "At the proxy tier, TSAR employs a novel multi-resolution ordered <br>distributed index structure</br>, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the core of the TSAR architecture is a novel <br>distributed index structure</br> based on interval skip graphs that we introduce in this paper.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered <br>distributed index structure</br>, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries."
            ],
            "translated_annotated_samples": [
                "En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el <br>Grafo de Salto de Intervalo</br>, para soportar eficientemente consultas espaciotemporales y de valor.",
                "En el núcleo de la arquitectura TSAR se encuentra una <br>estructura de índice distribuido</br> novedosa basada en gráficos de salto de intervalo que presentamos en este artículo.",
                "En el nivel de proxy, TSAR emplea una <br>estructura de índice distribuido ordenado de múltiple resolución</br> novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el <br>Grafo de Salto de Intervalo</br>, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una <br>estructura de índice distribuido</br> novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una <br>estructura de índice distribuido ordenado de múltiple resolución</br> novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para redes de sensores inalámbricos. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50 ",
            "candidates": [],
            "error": [
                [
                    "Grafo de Salto de Intervalo",
                    "estructura de índice distribuido",
                    "estructura de índice distribuido ordenado de múltiple resolución"
                ]
            ]
        },
        "interval skip graph": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the <br>interval skip graph</br>, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory <br>interval skip graph</br> Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the <br>interval skip graph</br>, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the <br>interval skip graph</br> is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the <br>interval skip graph</br> in greater detail. 3.1 Skip Graph Overview In order to inform the description of the <br>interval skip graph</br>, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: <br>interval skip graph</br> [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed <br>interval skip graph</br> and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 <br>interval skip graph</br> A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The <br>interval skip graph</br> is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple <br>interval skip graph</br>, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse <br>interval skip graph</br> The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an <br>interval skip graph</br> has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse <br>interval skip graph</br>, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse <br>interval skip graph</br>, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an <br>interval skip graph</br>.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse <br>interval skip graph</br> with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse <br>interval skip graph</br> The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into <br>interval skip graph</br> Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the <br>interval skip graph</br> at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse <br>interval skip graph</br> that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse <br>interval skip graph</br> Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse <br>interval skip graph</br>, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the <br>interval skip graph</br>, for efficiently supporting spatio-temporal and value queries.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory <br>interval skip graph</br> Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the <br>interval skip graph</br>, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "The goal of the <br>interval skip graph</br> is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the <br>interval skip graph</br> in greater detail. 3.1 Skip Graph Overview In order to inform the description of the <br>interval skip graph</br>, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1]."
            ],
            "translated_annotated_samples": [
                "En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el <br>Grafo de Salto de Intervalo</br>, para soportar eficientemente consultas espaciotemporales y de valor.",
                "El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua.",
                "En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada <br>Interval Skip Graph</br>, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular.",
                "El objetivo del <br>grafo de salto de intervalo</br> es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente.",
                "En el resto de esta sección, describimos el <br>grafo de salto de intervalo</br> con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el <br>Grafo de Salto de Intervalo</br>, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada <br>Interval Skip Graph</br>, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del <br>grafo de salto de intervalo</br> es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el <br>grafo de salto de intervalo</br> con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. ",
            "candidates": [],
            "error": [
                [
                    "Grafo de Salto de Intervalo",
                    "Interval Skip Graph",
                    "grafo de salto de intervalo",
                    "grafo de salto de intervalo"
                ]
            ]
        },
        "spatial scoping": {
            "translated_key": "alcance espacial",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include <br>spatial scoping</br>. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "In TSAR our focus is on range queries on value or time, with planned extensions to include <br>spatial scoping</br>. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future."
            ],
            "translated_annotated_samples": [
                "En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir <br>alcance espacial</br>. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir <br>alcance espacial</br>. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para redes de sensores inalámbricos. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "interval tree": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an <br>interval tree</br>.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an <br>interval tree</br>.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an <br>interval tree</br> or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an <br>interval tree</br>.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an <br>interval tree</br>, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an <br>interval tree</br>.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an <br>interval tree</br>.",
                "Insert Complexity: In an <br>interval tree</br> or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an <br>interval tree</br>.",
                "Thus, when updating the maximum value in an <br>interval tree</br>, the update is only propagated towards the root."
            ],
            "translated_annotated_samples": [
                "El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un <br>Árbol de Intervalos</br>.",
                "Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un <br>árbol de intervalos</br>.",
                "En un <br>árbol de intervalos</br> o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada.",
                "Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un <br>árbol de intervalo</br>.",
                "Por lo tanto, al actualizar el valor máximo en un <br>árbol de intervalos</br>, la actualización solo se propaga hacia la raíz."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un <br>Árbol de Intervalos</br>. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un <br>árbol de intervalos</br>. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un <br>árbol de intervalos</br> o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un <br>árbol de intervalo</br>. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un <br>árbol de intervalos</br>, la actualización solo se propaga hacia la raíz. ",
            "candidates": [],
            "error": [
                [
                    "Árbol de Intervalos",
                    "árbol de intervalos",
                    "árbol de intervalos",
                    "árbol de intervalo",
                    "árbol de intervalos"
                ]
            ]
        },
        "wireless sensor network": {
            "translated_key": "redes de sensores inalámbricos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for <br>wireless sensor network</br>s.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "Versatile low power media access for <br>wireless sensor network</br>s."
            ],
            "translated_annotated_samples": [
                "Acceso a medios de baja potencia versátil para <br>redes de sensores inalámbricos</br>."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El almacenamiento archivado de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El almacenamiento archivado de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina almacenamiento de archivos con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del almacenamiento archivístico de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ELF [7] es un sistema de archivos estructurado en registros para almacenamiento local en memoria flash que proporciona nivelación de carga y Matchbox es un sistema de archivos simple que se incluye en la distribución de TinyOS [14]. Ambos sistemas se centran en el almacenamiento local, mientras que nuestro enfoque se centra tanto en el almacenamiento en los sensores remotos como en proporcionar una vista unificada de los datos distribuidos en todos esos archivos locales. El almacenamiento de múltiples resoluciones [9] está destinado para el almacenamiento y búsqueda en red en sistemas donde hay una cantidad significativa de datos en comparación con los recursos de almacenamiento. Por el contrario, TSAR aborda el problema del almacenamiento en archivos en sistemas de dos niveles donde se pueden colocar recursos suficientes en los sensores periféricos. La plataforma RISE [21] que se está desarrollando como parte del proyecto NODE en UCR aborda los problemas de soporte de plataforma de hardware para grandes cantidades de almacenamiento en nodos de sensores remotos, pero no el indexado y la consulta de estos datos. Para acceder de manera eficiente a un almacén de sensores distribuido, es necesario construir un índice de los datos. Los primeros trabajos sobre redes de sensores como la Difusión Dirigida [17] asumen un sistema en el que todos los datos útiles de los sensores se almacenaban localmente en cada sensor, y las consultas con alcance espacial se enrutaban utilizando coordenadas geográficas a ubicaciones donde se almacenaban los datos. Las fuentes publican los eventos que detectan, y los receptores interesados en eventos específicos pueden suscribirse a estos eventos. El sustrato de Difusión Dirigida dirige las consultas a ubicaciones específicas si la consulta tiene información geográfica incrustada en ella (por ejemplo: encontrar la temperatura en el cuadrante suroeste), y si no, la consulta se difunde por toda la red. Estos esquemas tenían la desventaja de que para consultas que no están geográficamente delimitadas, el costo de búsqueda (O(n) para una red de n nodos) puede ser prohibitivo en redes grandes con consultas frecuentes. Los enfoques de almacenamiento local con indexación en red abordan este problema construyendo índices utilizando marcos como Tablas de Hash Geográficas [24] y Árboles Cuaternarios [9]. Investigaciones recientes han observado un creciente cuerpo de trabajo sobre esquemas de indexación de datos para redes de sensores[26][11][18]. Un esquema de este tipo es DCS [26], que proporciona una función hash para mapear desde el nombre del evento hasta la ubicación. DCS construye una estructura distribuida que agrupa eventos espacialmente por su tipo nombrado. El Índice Distribuido de Características en Redes de Sensores (DIFS [11]) y las Consultas de Rango Multidimensional en Redes de Sensores (DIM [18]) extienden el enfoque de almacenamiento centrado en los datos para proporcionar jerarquías distribuidas espacialmente de índices a los datos. Si bien estos enfoques abogan por el indexado en red para las redes de sensores, creemos que el indexado es una tarea demasiado complicada para ser realizada en los nodos de sensores remotos, ya que implica mantener un estado significativo y tablas grandes. TSAR proporciona una mejor coincidencia entre los requisitos de recursos de almacenamiento e indexación y la disponibilidad de recursos en diferentes niveles. Por lo tanto, operaciones complejas como indexar y gestionar metadatos se realizan en los proxies, mientras que el almacenamiento en el sensor sigue siendo sencillo. Además de las técnicas de almacenamiento e indexación específicas para redes de sensores, muchas estructuras de índices distribuidos, de pares a pares y espaciotemporales son relevantes para nuestro trabajo. Los DHTs [25] se pueden utilizar para indexar eventos según su tipo, las variantes de árbol cuádruple como los Rtrees [12] se pueden utilizar para optimizar búsquedas espaciales, y los árboles K-D [2] se pueden utilizar para búsquedas de múltiples atributos. Si bien este documento se centra en la construcción de una estructura de índice ordenado para consultas de rango, exploraremos el uso de otras estructuras de índice para consultas alternativas sobre datos de sensores. 8. En este artículo, argumentamos que los sistemas de almacenamiento de sensores existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza multinivel de las redes de sensores emergentes. Presentamos el diseño de TSAR, una arquitectura de almacenamiento fundamentalmente diferente que prevé la separación de los datos de los metadatos mediante el uso de almacenamiento local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una estructura de índice distribuido ordenado de múltiple resolución novedosa, el Grafo de Salto de Intervalo Disperso, para soportar eficientemente consultas espaciotemporales y de rango. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo energético de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar una estructura de índice de resolución más gruesa. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestra evaluación experimental de TSAR demostró los beneficios y la viabilidad de emplear nuestra arquitectura de almacenamiento distribuido de baja latencia y eficiente en energía en redes de sensores de múltiples niveles. REFERENCIAS [1] James Aspnes y Gauri Shah. Gráficos de salto. En el Decimocuarto Simposio Anual de Algoritmos Discretos ACM-SIAM, páginas 384-393, Baltimore, MD, EE. UU., 12-14 de enero de 2003. [2] Jon Louis Bentley. Árboles de búsqueda binaria multidimensionales utilizados para búsquedas asociativas. Comunicación. ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke y Praveen Seshadri. Hacia sistemas de bases de datos de sensores. En Actas de la Segunda Conferencia Internacional sobre Gestión de Datos Móviles, enero de 2001. [4] Chipcon. Transceptor de radiofrecuencia CC2420 de 2.4 GHz IEEE 802.15.4 / ZigBee-ready, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest y Clifford Stein. Introducción a los algoritmos. El MIT Press y McGraw-Hill, segunda edición, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke y Jayavel Shanmugasundaram. Consultando redes peer-to-peer utilizando árboles P. Informe técnico TR2004-1926, Universidad de Cornell, 2004. [7] Hui Dai, Michael Neufeld y Richard Han. ELF: un sistema de archivos flash eficiente y estructurado en registros para nodos de microsensores. En SenSys 04: Actas de la 2ª conferencia internacional sobre sistemas de sensores en red integrados, páginas 176-187, Nueva York, NY, EE. UU., 2004. ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li y Prashant Shenoy. PRESTO: Una arquitectura de almacenamiento predictivo para redes de sensores. En el Décimo Taller sobre Temas Candentes en Sistemas Operativos (HotOS X)., junio de 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin y John Heidemann. Una evaluación del almacenamiento de múltiples resoluciones en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil y T. Schoellhammer. Un sistema para la simulación, emulación y despliegue de redes de sensores heterogéneas. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy y S. Shenker. DIFS: Un índice distribuido para características en redes de sensores. Revista Elsevier de Redes Ad-hoc, 2003. [12] Antonin Guttman. R-trees: una estructura de índice dinámica para búsquedas espaciales. En SIGMOD 84: Actas de la conferencia internacional ACM SIGMOD 1984 sobre Gestión de datos, páginas 47-57, Nueva York, NY, EE. UU., 1984. ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer y Alec Wolman. Skipnet: Una red superpuesta escalable con propiedades de localidad prácticas. En actas del 4to Simposio USENIX sobre Tecnologías y Sistemas de Internet (USITS 03), Seattle, WA, marzo de 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler y Kristofer Pister. Direcciones de arquitectura del sistema para sensores en red. En Actas de la Novena Conferencia Internacional sobre Soporte Arquitectónico para Lenguajes de Programación y Sistemas Operativos (ASPLOS-IX), páginas 93-104, Cambridge, MA, EE. UU., noviembre de 2000. ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: memoria flash NAND de 512M x 8 bits / 1G x 8 bits, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan y Deborah Estrin. Difusión dirigida: un paradigma de comunicación escalable y robusto para redes de sensores. En Actas de la Sexta Conferencia Internacional Anual sobre Computación y Redes Móviles, páginas 56-67, Boston, MA, agosto de 2000. ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan y Wei Hong. Consultas de rango multidimensionales en redes de sensores. En Actas de la Primera Conferencia ACM sobre Sistemas de Sensores en Red Integrados (SenSys)., 2003. por aparecer. [19] Witold Litwin, Marie-Anne Neimat y Donovan A. Schneider. RP*: Una familia de estructuras de datos distribuidas escalables que preservan el orden. En VLDB 94: Actas de la 20ª Conferencia Internacional sobre Bases de Datos Muy Grandes, páginas 342-353, San Francisco, CA, EE. UU., 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein y Wei Hong. TAG: un pequeño servicio de agregación para redes de sensores ad-hoc. En OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos y V. Kalogeraki. Plataformas de sensores de alto rendimiento y bajo consumo con almacenamiento a escala de gigabytes. En SenMetrics 2005: Tercer Taller Internacional sobre Medición, Modelado y Análisis del Rendimiento de Redes de Sensores Inalámbricos, julio de 2005. [22] J. Polastre, J. Hill y D. Culler. Acceso a medios de baja potencia versátil para <br>redes de sensores inalámbricos</br>. En Actas de la Segunda Conferencia de la ACM sobre Sistemas de Sensores en Red Integrados (SenSys), noviembre de 2004. [23] William Pugh. Listas de salto: una alternativa probabilística a los árboles balanceados. This is not a complete sentence. Please provide more context or the full sentence that you would like me to translate to Spanish. ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu. \n\nACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, y F. Yu. Almacenamiento centrado en datos en redes de sensores. En el Primer Taller ACM sobre Temas Candentes en Redes, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp y S. Shenker. Una red escalable de direcciones de contenido. En Actas de la Conferencia ACM SIGCOMM de 2001, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan y S. Shenker. GHT - una tabla hash geográfica para almacenamiento centrado en datos. En el Primer Taller Internacional de la ACM sobre Redes de Sensores Inalámbricos y sus Aplicaciones, 2002. [27] N. Xu, E. Osterweil, M. Hamilton y D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/. Datos de la Reserva James. 50 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "archival storage": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT <br>archival storage</br> of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "<br>archival storage</br> of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term <br>archival storage</br> [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines <br>archival storage</br> with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of <br>archival storage</br> of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of <br>archival storage</br> in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT <br>archival storage</br> of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "<br>archival storage</br> of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "In the simplest, sensors stream data or events to a server for long-term <br>archival storage</br> [3], where the server often indexes the data to permit efficient access at a later time.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines <br>archival storage</br> with caching and prediction.",
                "The problem of <br>archival storage</br> of sensor data has received limited attention in sensor network literature."
            ],
            "translated_annotated_samples": [
                "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El <br>almacenamiento archivado</br> de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes.",
                "El <br>almacenamiento archivado</br> de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia.",
                "En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior.",
                "TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina <br>almacenamiento de archivos</br> con almacenamiento en caché y predicción.",
                "El problema del <br>almacenamiento archivístico</br> de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores."
            ],
            "translated_text": "TSAR: Una arquitectura de almacenamiento de sensores de dos niveles que utiliza gráficos de salto de intervalo ∗ Peter Desnoyers, Deepak Ganesan y Prashant Shenoy Departamento de Ciencias de la Computación Universidad de Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu RESUMEN El <br>almacenamiento archivado</br> de datos de sensores es necesario para aplicaciones que consultan, extraen y analizan dichos datos en busca de características y tendencias interesantes. Sostenemos que los sistemas de almacenamiento existentes están diseñados principalmente para jerarquías planas de nodos de sensores homogéneos y no aprovechan completamente la naturaleza de múltiples niveles de las redes de sensores emergentes, donde una aplicación puede comprender decenas de proxies conectados, cada uno gestionando decenas a cientos de sensores no conectados. Presentamos TSAR, una arquitectura de almacenamiento fundamentalmente diferente que contempla la separación de datos de metadatos mediante el uso de archivado local en los sensores e indexación distribuida en los proxies. En el nivel de proxy, TSAR emplea una novedosa estructura de índice distribuido ordenado de múltiple resolución, el Grafo de Salto de Intervalo, para soportar eficientemente consultas espaciotemporales y de valor. En la capa del sensor, TSAR admite una sumarización adaptativa consciente de la energía que puede equilibrar el costo de transmitir metadatos a los proxies con la sobrecarga de falsos aciertos resultantes de consultar un índice de grano grueso. Implementamos TSAR en un banco de pruebas de sensores de dos niveles que consta de proxies basados en Stargate y sensores basados en Mote. Nuestros experimentos demuestran los beneficios y la viabilidad de utilizar nuestra arquitectura de almacenamiento energéticamente eficiente en redes de sensores de múltiples niveles. Categorías y Descriptores de Asignaturas: C.2.4 [Computadora - Redes de Comunicación]: Sistemas Distribuidos Términos Generales: Algoritmos, rendimiento, experimentación. 1. Introducción 1.1 Motivación Han surgido muchos tipos diferentes de aplicaciones de sensores centradas en datos en red en los últimos años. Los sensores en estas aplicaciones detectan el entorno y generan datos que deben ser procesados, filtrados, interpretados y archivados para proporcionar una infraestructura útil a sus usuarios. Para lograr sus objetivos, una aplicación típica de sensor necesita acceso tanto a datos de sensores en tiempo real como a datos de sensores pasados. Si bien el acceso a datos en tiempo real es necesario en aplicaciones de monitoreo y vigilancia, el acceso a datos pasados es necesario para aplicaciones como la extracción de registros de sensores para detectar patrones inusuales, análisis de tendencias históricas y análisis post mortem de eventos particulares. El <br>almacenamiento archivado</br> de datos de sensores pasados requiere un sistema de almacenamiento, cuyos atributos clave son: dónde se almacenan los datos, si están indexados y cómo la aplicación puede acceder a estos datos de manera eficiente en términos de energía y con baja latencia. Ha habido un espectro de enfoques para construir sistemas de almacenamiento de sensores. En su forma más simple, los sensores transmiten datos o eventos a un servidor para su almacenamiento a largo plazo [3], donde el servidor suele indexar los datos para permitir un acceso eficiente en un momento posterior. Dado que los sensores pueden estar a varias conexiones del nodo base más cercano, se incurren costos de red; sin embargo, una vez que los datos están indexados y archivados, los accesos posteriores a los datos pueden ser manejados localmente en el servidor sin incurrir en sobrecarga de red. En este enfoque, el almacenamiento es centralizado, las lecturas son eficientes y económicas, mientras que las escrituras son costosas. Además, todos los datos se propagan al servidor, independientemente de si son utilizados alguna vez por la aplicación. Un enfoque alternativo es que cada sensor almacene datos o eventos localmente (por ejemplo, en memoria flash), de modo que todas las escrituras sean locales y no generen costos de comunicación. Una solicitud de lectura, como por ejemplo si un evento fue detectado por un sensor en particular, requiere que se envíe un mensaje al sensor para su procesamiento. Las solicitudes de lectura más complejas son manejadas mediante inundación. Por ejemplo, determinar si se detectó un intruso durante un intervalo de tiempo particular requiere que la solicitud se envíe a todos los sensores en el sistema. Por lo tanto, en este enfoque, el almacenamiento es distribuido, las escrituras son locales y económicas, mientras que las lecturas incurren en importantes costos de red. Las solicitudes que requieren inundación, debido a la falta de un índice, son costosas y pueden desperdiciar recursos sensoriales preciosos, incluso si no se almacenan datos coincidentes en esos sensores. Los esfuerzos de investigación como la Difusión Dirigida [17] han intentado reducir estos costos de lectura, sin embargo, mediante enrutamiento inteligente de mensajes. Entre estos dos extremos se encuentran una serie de otros sistemas de almacenamiento de sensores con diferentes compensaciones, resumidos en la Tabla 1. El enfoque de la tabla hash geográfica (GHT) [24, 26] aboga por el uso de un índice en red para complementar la naturaleza completamente distribuida del almacenamiento de sensores. En este enfoque, cada elemento de datos tiene una clave asociada, y se utiliza una tabla hash distribuida o geográfica para mapear las claves a nodos que almacenan los elementos de datos correspondientes. Por lo tanto, las escrituras hacen que los elementos de datos se envíen a los nodos hash y también desencadenan actualizaciones en la tabla hash de la red. Una solicitud de lectura requiere una búsqueda en la tabla hash de la red para localizar el nodo que almacena el elemento de datos 39; observe que la presencia de un índice elimina la necesidad de inundación en este enfoque. La mayoría de estos enfoques asumen una arquitectura plana y homogénea en la que cada nodo sensor está limitado por energía. En este artículo, proponemos una arquitectura de almacenamiento novedosa llamada TSAR1 que refleja y aprovecha la naturaleza de múltiples niveles de las redes de sensores emergentes, donde la aplicación está compuesta por decenas de proxies de sensores conectados (o más), cada uno controlando decenas o cientos de sensores no conectados. TSAR es un componente de nuestra arquitectura de almacenamiento predictivo PRESTO [8], que combina <br>almacenamiento de archivos</br> con almacenamiento en caché y predicción. Creemos que es necesaria una arquitectura de almacenamiento fundamentalmente diferente para abordar la naturaleza de múltiples niveles de las futuras redes de sensores. Específicamente, la arquitectura de almacenamiento debe aprovechar la naturaleza rica en recursos de los proxies, respetando al mismo tiempo las limitaciones de recursos en los sensores remotos. Ninguna arquitectura de almacenamiento de sensores existente aborda explícitamente esta dicotomía en las capacidades de recursos de diferentes niveles. Cualquier sistema de almacenamiento de sensores también debería aprovechar cuidadosamente las tendencias tecnológicas actuales, que indican que las capacidades de las memorias flash siguen aumentando según la Ley de Moore, mientras que sus costos siguen disminuyendo. Por lo tanto, pronto será factible equipar cada sensor con 1 GB de almacenamiento flash por unos pocos dólares. Un argumento aún más convincente es el costo energético del almacenamiento flash, que puede ser hasta dos órdenes de magnitud menor que el de la comunicación. Las nuevas memorias flash NAND ofrecen costos de escritura y borrado de energía muy bajos: nuestra comparación de un almacenamiento flash NAND Samsung de 1GB [16] y la radio inalámbrica Chipcon CC2420 802.15.4 [4] en la Sección 6.2 indica una relación de 1:100 en el costo energético por byte entre los dos dispositivos, incluso antes de tener en cuenta los gastos generados por el protocolo de red. Estas tendencias, junto con la naturaleza limitada de energía de los sensores inalámbricos, indican que el almacenamiento local ofrece una alternativa viable y eficiente en energía a la comunicación en redes de sensores. TSAR aprovecha estas tendencias almacenando datos o eventos localmente en el almacenamiento flash de bajo consumo energético en cada sensor. Los sensores envían información identificativa concisa, que denominamos metadatos, a un proxy cercano; dependiendo de la representación utilizada, estos metadatos pueden ser una orden de magnitud o más más pequeños que los propios datos, imponiendo costos de comunicación mucho más bajos. Los proxies ricos en recursos interactúan entre sí para construir un índice distribuido de los metadatos reportados por todos los sensores, y por lo tanto un índice de los datos asociados almacenados en los sensores. Este índice proporciona una vista unificada y lógica de los datos distribuidos, y permite a una aplicación consultar y leer datos pasados de manera eficiente: el índice se utiliza para localizar todos los datos que coinciden con una solicitud de lectura, seguido por mensajes para recuperar esos datos de los sensores correspondientes. Las búsquedas de índices en red se eliminan, reduciendo la sobrecarga de la red para las solicitudes de lectura. Esta separación de datos, que se almacenan en los sensores, y los metadatos, que se almacenan en los proxies, permite a TSAR reducir los costos energéticos en los sensores, aprovechando los recursos en los proxies conectados. 1.2 Contribuciones Este documento presenta TSAR, una arquitectura de almacenamiento de dos niveles novedosa para redes de sensores. Hasta donde sabemos, este es el primer sistema de almacenamiento de sensores diseñado específicamente para redes de sensores multinivel emergentes. Nuestro diseño e implementación de TSAR ha dado lugar a cuatro contribuciones. En el núcleo de la arquitectura TSAR se encuentra una estructura de índice distribuido novedosa basada en gráficos de salto de intervalo que presentamos en este artículo. Esta estructura de índice puede almacenar resúmenes generales de datos de sensores y organizarlos de manera ordenada para que sean fácilmente buscables. TSAR: Arquitectura de Almacenamiento Escalonado para redes de sensores. Esta estructura de datos tiene una complejidad esperada de búsqueda y actualización de O(log n). Además, el índice proporciona una vista lógicamente unificada de todos los datos en el sistema. En segundo lugar, a nivel del sensor, cada sensor mantiene un archivo local que almacena datos en memoria flash. Nuestra arquitectura de almacenamiento es completamente sin estado en cada sensor desde la perspectiva del índice de metadatos; todas las estructuras de índice se mantienen en los proxies ricos en recursos, y solo se envían solicitudes directas o consultas simples en ubicaciones de almacenamiento identificadas explícitamente a los sensores. El almacenamiento en el sensor remoto se trata en efecto como un apéndice del proxy, lo que resulta en una baja complejidad de implementación, lo que lo hace ideal para plataformas de sensores pequeñas y con recursos limitados. Además, la tienda local está optimizada para el acceso a series temporales de datos archivados, como es típico en muchas aplicaciones. Cada sensor envía periódicamente un resumen de sus datos a un proxy. TSAR emplea una novedosa técnica de resumen adaptativo que ajusta la granularidad de los datos informados en cada resumen a la proporción de resultados falsos para las consultas de la aplicación. Se envían resúmenes más detallados cuando se observan más falsos positivos, equilibrando así el costo energético de las actualizaciones de metadatos y los falsos positivos. Tercero, hemos implementado un prototipo de TSAR en un banco de pruebas de múltiples niveles que incluye proxies basados en Stargate y sensores basados en Mote. Nuestra implementación admite consultas espaciotemporales, de valor y basadas en rango en datos de sensores. En cuarto lugar, realizamos una evaluación experimental detallada de TSAR utilizando una combinación de EmStar/EmTOS [10] y nuestro prototipo. Mientras que nuestros experimentos EmStar/EmTOS se centran en la escalabilidad de TSAR en entornos más grandes, nuestra evaluación de prototipo implica mediciones de latencia y energía en un entorno real. Nuestros resultados demuestran la propiedad de escalamiento logarítmico del grafo de salto disperso y la baja latencia de las consultas de extremo a extremo en una red de múltiples saltos con ciclo de trabajo. El resto de este documento está estructurado de la siguiente manera. La sección 2 presenta los problemas clave de diseño que guían nuestro trabajo. Las secciones 3 y 4 presentan el índice a nivel de proxy y el archivo local y la sumarización en un sensor, respectivamente. La Sección 5 discute nuestra implementación de prototipo, y la Sección 6 presenta nuestros resultados experimentales. Presentamos el trabajo relacionado en la Sección 7 y nuestras conclusiones en la Sección 8. Consideraciones de diseño En esta sección, primero describimos los diversos componentes de una red de sensores de múltiples niveles asumida en nuestro trabajo. A continuación, presentamos una descripción de los modelos de uso esperados para este sistema, seguida de varios principios que abordan estos factores que guían el diseño de nuestro sistema de almacenamiento. Modelo del sistema Envisajamos una red de sensores de múltiples niveles que comprende varios niveles: un nivel inferior de nodos de sensores remotos no conectados, un nivel intermedio de proxies de sensores conectados por cable, y un nivel superior de aplicaciones y terminales de usuario (ver Figura 1). Se asume que el nivel más bajo formará un despliegue denso de sensores de baja potencia. Un nodo sensorial canónico en este nivel está equipado con sensores de bajo consumo, un microcontrolador y una radio, así como una cantidad significativa de memoria flash (por ejemplo, 1GB). La restricción común para este nivel es la energía, y la necesidad de una larga vida útil a pesar de una restricción finita de energía. El uso de la radio, el procesador, la RAM y la memoria flash consumen energía, la cual necesita ser limitada. En general, asumimos que la comunicación por radio es considerablemente más costosa que el acceso a la memoria flash. El nivel intermedio consiste en proxies de sensores ricos en energía que tienen recursos significativos de computación, memoria y almacenamiento y pueden utilizar estos recursos de forma continua. En entornos urbanos, la capa de proxy estaría compuesta por nodos de clase estación base conectados (por ejemplo, Crossbow Stargate), cada uno con múltiples radios: un radio 802.11 que lo conecta a una red inalámbrica de malla y un radio de baja potencia (por ejemplo, 802.15.4) que lo conecta a los nodos sensores. En aplicaciones de teledetección [10], este nivel podría incluir un nodo Stargate similar con una celda de energía solar. Cada proxy se asume que gestiona varias decenas a cientos de sensores de nivel inferior en su cercanía. Una implementación típica de una red de sensores contendrá múltiples proxies distribuidos geográficamente. Por ejemplo, en una aplicación de monitoreo de edificios, se podría colocar un proxy de sensor por piso o pasillo para monitorear sensores de temperatura, calor y luz en su cercanía. En el nivel más alto de nuestra infraestructura se encuentran las aplicaciones que consultan la red de sensores a través de una interfaz de consulta[20]. En este trabajo, nos enfocamos en aplicaciones que requieren acceso a datos de sensores pasados. Para respaldar tales consultas, el sistema necesita archivar datos en un almacenamiento persistente. Nuestro objetivo es diseñar un sistema de almacenamiento que aproveche la relativa abundancia de recursos en los proxies para enmascarar la escasez de recursos en los sensores. 2.2 Modelos de Uso El diseño de un sistema de almacenamiento como TSAR se ve afectado por las consultas que probablemente se le hagan. Una gran fracción de las consultas sobre datos de sensores se espera que sean de naturaleza espacio-temporal. Los sensores proporcionan información sobre el mundo físico; dos atributos clave de esta información son cuándo ocurrió un evento o actividad en particular y dónde ocurrió. Algunos ejemplos de tales consultas incluyen la hora y ubicación de detecciones de objetivos o intrusos (por ejemplo, aplicaciones de seguridad y monitoreo), notificaciones de tipos específicos de eventos como valores de presión y humedad que exceden un umbral (por ejemplo, aplicaciones industriales), o consultas simples de recolección de datos que solicitan datos de un tiempo o ubicación particular (por ejemplo, monitoreo del clima o del medio ambiente). Las consultas esperadas de estos datos incluyen aquellas que solicitan rangos de uno o más atributos; por ejemplo, una consulta de todos los datos de imagen de cámaras dentro de una área geográfica especificada durante un cierto período de tiempo. Además, suele ser deseable apoyar un acceso eficiente a los datos de una manera que mantenga el orden espacial y temporal. Existen varias formas de soportar consultas de rango, como las funciones hash que preservan la localidad, como las que se utilizan en DIMS [18]. Sin embargo, el mecanismo más directo, y aquel que naturalmente proporciona un acceso ordenado eficiente, es a través del uso de estructuras de datos que conservan el orden. Estructuras que preservan el orden como el conocido B-Tree mantienen relaciones entre los valores indexados y permiten un acceso natural a rangos, así como operaciones de predecesor y sucesor en sus valores clave. Las aplicaciones también pueden plantear consultas basadas en valores que implican determinar si se observó un valor v en algún sensor; la consulta devuelve una lista de sensores y los momentos en que observaron este valor. Las variantes de consultas de valor implican restringir la consulta a una región geográfica, o especificar un rango (v1, v2) en lugar de un único valor v. Las consultas de valor pueden ser manejadas indexando los valores reportados en los resúmenes. Específicamente, si un sensor reporta un valor numérico, entonces el índice se construye sobre estos valores. Una búsqueda implica encontrar valores coincidentes que estén contenidos en el rango de búsqueda (v1, v2) o que coincidan exactamente con el valor de búsqueda v. Las consultas híbridas de valor y espacio-temporales también son posibles. Tales consultas especifican un intervalo de tiempo, un rango de valores y una región espacial, y solicitan todos los registros que cumplan con estos atributos: encontrar todas las instancias donde la temperatura superó los 100 grados Fahrenheit en la ubicación R durante el mes de agosto. Estas consultas requieren un índice tanto en el tiempo como en el valor. En TSAR nuestro enfoque se centra en consultas de rango en valor o tiempo, con extensiones planeadas para incluir alcance espacial. 2.3 Principios de Diseño Nuestro diseño de un sistema de almacenamiento de sensores para redes multinivel se basa en el siguiente conjunto de principios, que abordan los problemas que surgen de los modelos de sistema y uso mencionados anteriormente. • Principio 1: Almacenar localmente, acceder globalmente: La tecnología actual permite que el almacenamiento local sea significativamente más eficiente en energía que la comunicación en red, mientras que las tendencias tecnológicas no muestran signos de eliminar esta brecha en un futuro cercano. Para una vida de red máxima, un sistema de almacenamiento de sensores debería aprovechar la memoria flash en los sensores para archivar datos localmente, sustituyendo operaciones de memoria baratas por transmisiones de radio costosas. Pero sin mecanismos eficientes de recuperación, las ganancias energéticas del almacenamiento local pueden ser superadas por los costos de comunicación incurridos por la aplicación al buscar datos. Creemos que si el sistema de almacenamiento de datos proporciona la abstracción de una única tienda lógica a las aplicaciones, como lo hace TSAR, entonces tendrá una flexibilidad adicional para optimizar los costos de comunicación y almacenamiento. • Principio 2: Distinguir datos de metadatos: Los datos deben ser identificados para que puedan ser recuperados por la aplicación sin una búsqueda exhaustiva. Para hacer esto, asociamos metadatos con cada registro de datos: campos de datos de sintaxis conocida que sirven como identificadores y pueden ser consultados por el sistema de almacenamiento. Ejemplos de estos metadatos son atributos de datos como la ubicación y el tiempo, o valores de datos seleccionados o resumidos. Aprovechamos la presencia de proxies ricos en recursos para indexar metadatos para sensores con limitaciones de recursos. Los proxies comparten este índice de metadatos para proporcionar una vista lógica unificada de todos los datos en el sistema, lo que permite búsquedas eficientes y de baja latencia. Una separación específica por niveles de almacenamiento de datos de la indexación de metadatos permite al sistema aprovechar las peculiaridades de las redes de múltiples niveles, al tiempo que mejora el rendimiento y la funcionalidad. • Principio 3: Proporcionar soporte de consulta centrado en los datos: En una aplicación de sensores, la ubicación específica (es decir, el desplazamiento) de un registro en un flujo es poco probable que sea significativa, excepto si transmite información sobre la ubicación y/o el momento en que se generó la información. Por lo tanto, esperamos que las aplicaciones se beneficien más de una interfaz de consulta que les permita localizar datos por valor o atributo (por ejemplo, ubicación y tiempo), en lugar de una interfaz de lectura para datos no estructurados. Esto a su vez implica la necesidad de mantener metadatos en forma de un índice que proporcione búsquedas de bajo costo. El diseño del sistema TSAR encarna estos principios de diseño al emplear almacenamiento local en los sensores y un índice distribuido en los proxies. Las características clave del diseño del sistema son las siguientes: En TSAR, las escrituras ocurren en los nodos del sensor, y se asume que consisten tanto en datos opacos como en metadatos específicos de la aplicación. Estos metadatos son una tupla de tipos conocidos, que pueden ser utilizados por la aplicación para localizar e identificar registros de datos, y que pueden ser buscados y comparados por TSAR en el proceso de localizar datos para la aplicación. En una aplicación de detección basada en cámara, por ejemplo, estos metadatos podrían incluir coordenadas que describen el campo de visión, luminancia promedio y valores de movimiento, además de información básica como la hora y la ubicación del sensor. Dependiendo de la aplicación, estos metadatos pueden ser dos o tres órdenes de magnitud más pequeños que los datos en sí, por ejemplo, si los metadatos consisten en características extraídas de datos de imagen o acústicos. Además de almacenar datos localmente, cada sensor envía periódicamente un resumen de los metadatos reportados a un proxy cercano. El resumen contiene información como el ID del sensor, el intervalo (t1, t2) durante el cual se generó el resumen, un identificador que identifica el registro de datos correspondiente (por ejemplo, su ubicación en la memoria flash) y una representación de grano grueso de los metadatos asociados con el registro. La representación de datos precisa utilizada en el resumen es específica de la aplicación; por ejemplo, un sensor de temperatura podría optar por informar los valores de temperatura máxima y mínima observados en un intervalo como una representación de grano grueso de la serie temporal real. El proxy utiliza el resumen para construir un índice; el índice es global en el sentido de que almacena información de todos los sensores en el sistema y está distribuido en los distintos proxies del sistema. Por lo tanto, las aplicaciones ven una vista unificada de los datos distribuidos y pueden consultar el índice en cualquier proxy para acceder a los datos almacenados en cualquier sensor. Específicamente, cada consulta activa búsquedas en este índice distribuido y la lista de coincidencias se utiliza luego para recuperar los datos correspondientes de los sensores. Hay varios métodos de índice y búsqueda distribuidos que podrían ser utilizados en este sistema; sin embargo, la estructura de índice descrita en la Sección 3 es muy adecuada para la tarea. Dado que el índice se construye utilizando un resumen de grano grueso en lugar de los datos reales, las búsquedas en el índice arrojarán coincidencias aproximadas. El mecanismo de resumen TSAR garantiza que las búsquedas en el índice nunca arrojarán falsos negativos, es decir, nunca se perderán resúmenes que incluyan el valor buscado. Sin embargo, las búsquedas de índices pueden arrojar falsos positivos, donde un resumen coincide con la consulta pero al consultar el sensor remoto no encuentra ningún valor coincidente, desperdiciando recursos de red. Cuanto más grueso sea el resumen, menor será la sobrecarga de actualización y mayor será la fracción de falsos positivos, mientras que los resúmenes más finos incurren en sobrecarga de actualización al reducir la sobrecarga de consulta debido a los falsos positivos. Los sensores remotos pueden distinguir fácilmente los falsos positivos de las consultas que resultan en coincidencias de búsqueda, y calcular la proporción entre ambos; basándose en esta proporción, TSAR emplea una técnica adaptativa novedosa que varía dinámicamente la granularidad de los resúmenes de los sensores para equilibrar la sobrecarga de metadatos y la sobrecarga de falsos positivos. En la capa de proxy, TSAR emplea una estructura de índice novedosa llamada Interval Skip Graph, que es una estructura de datos ordenada y distribuida para encontrar todos los intervalos que contienen un punto o rango de valores particular. Los interval skip graphs combinan Árboles de Intervalos [5], un árbol de búsqueda binario basado en intervalos, con Skip Graphs [1], una estructura de datos ordenada y distribuida para sistemas peer-to-peer [13]. La estructura de datos resultante tiene dos propiedades que la hacen ideal para redes de sensores. Primero, tiene una complejidad de búsqueda de O(log n) para acceder al primer intervalo que coincide con un valor o rango particular, y una complejidad constante para acceder a cada intervalo sucesivo. En segundo lugar, el indexado de intervalos en lugar de valores individuales hace que la estructura de datos sea ideal para indexar resúmenes a lo largo del tiempo o del valor. La indexación basada en resúmenes es más adecuada para nodos sensores con restricciones energéticas, ya que transmitir resúmenes conlleva menos sobrecarga energética que transmitir todos los datos del sensor. Definiciones: Suponemos que hay Np proxies y Ns sensores en una red de sensores de dos niveles. Cada proxy es responsable de múltiples nodos sensores, y no se hace ninguna suposición sobre la cantidad de sensores por proxy. Cada sensor transmite resúmenes de intervalos de datos o eventos regularmente a uno o más proxies con los que está asociado, donde el intervalo i se representa como [lowi, highi]. Estos intervalos pueden corresponder a rangos de tiempo o de valores que se utilizan para indexar datos de sensores. No se hace ninguna suposición sobre el tamaño de un intervalo o sobre la cantidad de superposición entre intervalos. Las consultas de rango en los intervalos son realizadas por los usuarios a la red de proxies y sensores; cada consulta q necesita determinar todos los valores de índice que se superponen con el intervalo [lowq, highq]. El objetivo del grafo de salto de intervalo es indexar todos los intervalos de manera que el conjunto que se superpone con un intervalo de consulta pueda ser localizado eficientemente. En el resto de esta sección, describimos el grafo de salto de intervalo con mayor detalle. 3.1 Visión general del grafo de salto Para informar la descripción del Grafo de Salto de Intervalo, primero proporcionamos una breve visión general de la estructura de datos del Grafo de Salto; para una descripción más extensa, se remite al lector a [1]. La Figura 2 muestra un grafo de salto que indexa 8 claves; las claves se pueden ver en la parte inferior, y sobre cada clave se encuentran los punteros asociados con esa clave. Cada elemento de datos, que consiste en una clave y sus punteros asociados, puede residir en un nodo diferente en la red, 42 7 9 13 17 21 25 311 nivel 0 nivel 1 nivel 2 clave único grafo de salto de un solo elemento (cada uno puede estar en un nodo diferente) encontrar(21) mensajes de nodo a nodo Figura 2: Grafo de Salto de 8 Elementos [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [bajo,alto] máximo contiene(13) coincidencia sin coincidencia detener Figura 3: Grafo de Salto de Intervalo [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Nodo 1 Nodo 2 Nodo 3 nivel 2 nivel 1 nivel 0 Figura 4: Grafo de Salto de Intervalo Distribuido y por lo tanto los punteros identifican tanto un nodo remoto como un elemento de datos en ese nodo. En esta figura podemos ver las siguientes propiedades de un grafo de salto: • Índice ordenado: Las claves son miembros de un tipo de dato ordenado, por ejemplo, enteros. Las búsquedas utilizan comparaciones ordenadas entre la clave de búsqueda y las entradas de índice existentes. Además, los punteros en el nivel más bajo apuntan directamente al sucesor de cada elemento en el índice. • Indexación en el lugar: Los elementos de datos permanecen en los nodos donde fueron insertados, y se envían mensajes entre nodos para establecer enlaces entre esos elementos y otros en el índice. • Altura logarítmica: Hay log2 n punteros asociados con cada elemento, donde n es el número de elementos de datos indexados. Cada puntero pertenece a un nivel l en [0... log2 n − 1], y junto con algunos otros punteros en ese nivel forma una cadena de n/2l elementos. • Equilibrio probabilístico: En lugar de depender de operaciones de reequilibrio que pueden ser activadas en la inserción o eliminación, los skip graphs implementan un mecanismo de equilibrio aleatorio simple que mantiene un equilibrio cercano a la perfección en promedio, con una probabilidad extremadamente baja de desequilibrio significativo. • Redundancia y resiliencia: Cada elemento de datos forma una raíz de árbol de búsqueda independiente, por lo que las búsquedas pueden comenzar en cualquier nodo de la red, eliminando puntos calientes en una sola raíz de búsqueda. Además, el índice es resistente a fallos de nodos; los datos en el nodo fallido no serán accesibles, pero los elementos de datos restantes serán accesibles a través de árboles de búsqueda enraizados en otros nodos. En la Figura 2 vemos el proceso de búsqueda de un valor particular en un grafo de salto. Los punteros alcanzables desde un solo elemento de datos forman un árbol binario: una travesía de punteros en el nivel más alto salta sobre n/2 elementos, n/4 en el siguiente nivel, y así sucesivamente. La búsqueda consiste en descender por el árbol desde el nivel más alto hasta el nivel 0, en cada nivel comparando la clave objetivo con el siguiente elemento en ese nivel y decidiendo si se debe o no recorrer. En el caso perfectamente equilibrado mostrado aquí hay log2 n niveles de punteros, y la búsqueda recorrerá 0 o 1 punteros en cada nivel. Suponemos que cada elemento de datos reside en un nodo diferente, y medimos el costo de búsqueda por el número de mensajes enviados (es decir, el número de punteros recorridos); esto claramente será O(log n). La actualización del árbol procede desde abajo, como en un árbol B, con la raíz (o raíces) ascendiendo de nivel a medida que el árbol crece. De esta manera, por ejemplo, las dos cadenas en el nivel 1 siempre contienen n/2 entradas cada una, y nunca es necesario dividir las cadenas a medida que la estructura crece. El proceso de actualización consiste en elegir en cuál de las 2l cadenas insertar un elemento en cada nivel l, e insertarlo en el lugar adecuado en cada cadena. Mantener un grafo de salto perfectamente equilibrado como se muestra en la Figura 2 sería bastante complejo; en su lugar, se utiliza el método de equilibrado probabilístico introducido en las Listas de Salto [23], que intercambia una pequeña cantidad de sobrecarga en el caso esperado a cambio de una actualización y eliminación simples. La base de este método es la observación de que cualquier elemento que pertenezca a una cadena particular en el nivel l solo puede pertenecer a una de dos cadenas en el nivel l+1. Para insertar un elemento ascendemos niveles comenzando en 0, eligiendo aleatoriamente una de las dos cadenas posibles en cada nivel, y deteniéndonos cuando alcanzamos una cadena vacía. Un medio de implementación (por ejemplo, como se describe en [1]) es asignar a cada elemento una cadena de bits aleatoria de longitud arbitrariamente larga. Cada cadena en el nivel l se construye a partir de aquellos elementos cuyas cadenas de bits coinciden en los primeros l bits, creando así 2l cadenas posibles en cada nivel y asegurando que cada cadena se divide exactamente en dos cadenas en el siguiente nivel. Aunque la estructura resultante no está perfectamente equilibrada, siguiendo el análisis en [23] podemos demostrar que la probabilidad de que esté significativamente desequilibrada es extremadamente pequeña; además, dado que la estructura está determinada por la secuencia de números aleatorios, los patrones de datos de entrada no pueden hacer que el árbol se desequilibre. 3.2 Interval Skip Graph Un grafo de salto de intervalo está diseñado para almacenar entradas de un solo valor. En esta sección, presentamos una nueva estructura de datos que extiende los skip graphs para almacenar intervalos [lowi, highi] y permite búsquedas eficientes de todos los intervalos que cubren un valor v, es decir, {i: lowi ≤ v ≤ highi}. Nuestra estructura de datos se puede extender para búsquedas de rango de manera sencilla. El grafo de salto de intervalo se construye aplicando el método de árboles de búsqueda aumentados, como se describe en Cormen, Leiserson y Rivest [5] y se aplica a los árboles de búsqueda binarios para crear un Árbol de Intervalos. El método se basa en la observación de que una estructura de búsqueda basada en la comparación de claves ordenadas, como un árbol binario, también puede utilizarse para buscar en una clave secundaria que no disminuye en la primera clave. Dado un conjunto de intervalos ordenados por el límite inferior - lowi ≤ lowi+1 - definimos la clave secundaria como el máximo acumulativo, maxi = maxk=0...i (highk). El conjunto de intervalos que intersectan un valor v puede encontrarse buscando el primer intervalo (y por lo tanto, el intervalo con el menor lowi) tal que maxi ≥ v. Luego recorremos los intervalos en orden creciente de límite inferior, hasta encontrar el primer intervalo con lowi > v, seleccionando aquellos intervalos que intersectan v. Utilizando este enfoque, mejoramos la estructura de datos del grafo de salto, como se muestra en la Figura 3, de modo que cada entrada almacene un rango (límite inferior y límite superior) y una clave secundaria (máximo acumulativo del límite superior). Para calcular eficientemente la clave secundaria maxi para una entrada i, tomamos el mayor entre highi y los valores máximos reportados por cada uno de sus vecinos de la izquierda. Para buscar los intervalos que contienen el valor v, primero buscamos v en el índice secundario, maxi, y localizamos la primera entrada con maxi ≥ v. (según la definición de maxi, para este elemento de datos maxi = highi.) Si lowi > v, entonces este intervalo no contiene v, y ningún otro intervalo lo hará, por lo que hemos terminado. De lo contrario, recorremos el índice en orden creciente de mini, devolviendo los intervalos coincidentes, hasta que llegamos a una entrada con mini > v y hemos terminado. Las búsquedas de todos los intervalos que se superponen con un rango de consulta, o que contienen completamente un rango de consulta, son extensiones directas de este mecanismo. Complejidad de búsqueda: La búsqueda del primer intervalo que coincide con un valor dado se realiza de manera muy similar a un árbol de intervalos. La complejidad de la búsqueda es O(log n). El número de intervalos que coinciden con una consulta de rango puede variar dependiendo de la cantidad de superposición en los intervalos que se están indexando, así como del rango especificado en la consulta. En un árbol de intervalos o una lista de saltos de intervalos, el valor máximo para una entrada solo necesita ser calculado sobre el subárbol con raíz en esa entrada, ya que este valor solo se examinará al buscar dentro del subárbol con raíz en esa entrada. Para un grafo de salto de intervalo simple, sin embargo, este valor máximo para una entrada debe ser calculado sobre todas las entradas que la preceden en el índice, ya que las búsquedas pueden comenzar en cualquier lugar de la estructura de datos, en lugar de en un elemento raíz distinguido. Puede verse fácilmente que en el peor de los casos, la inserción de un solo intervalo (uno que cubra todos los intervalos existentes en el índice) desencadenará la actualización de todas las entradas en el índice, con un costo de inserción en el peor de los casos de O(n). 3.3 Grafo de Salto de Intervalo Disperso Las extensiones finales que proponemos aprovechan la diferencia entre el número de elementos indexados en un grafo de salto y el número de sistemas en los que estos elementos están distribuidos. El costo en mensajes de red de una operación puede reducirse al organizar la estructura de datos de manera que la mayoría de las travesías de estructuras ocurran localmente en un solo nodo, y por lo tanto no incurran en ningún costo de red. Además, dado que tanto la congestión como el fallo ocurren a nivel de nodo, podemos eliminar enlaces sin consecuencias adversas si esos enlaces solo contribuyen a la distribución de carga y/o la resiliencia dentro de un solo nodo. Estas dos modificaciones nos permiten lograr reducciones en la complejidad asintótica tanto de la actualización como de la búsqueda. Como se puede ver en la Sección 3.2, el costo de inserción y eliminación en un grafo de salto de intervalo tiene una complejidad de peor caso de O(n), en comparación con O(log n) para un árbol de intervalo. La razón principal de la diferencia es que los gráficos de salto tienen una estructura de búsqueda completa enraizada en cada elemento, con el fin de distribuir la carga y proporcionar resistencia a las fallas del sistema en un entorno distribuido. Sin embargo, para proporcionar distribución de carga y resistencia a fallos, solo es necesario proporcionar una estructura de búsqueda completa para cada sistema. Si, al igual que en TSAR, el número de nodos (proxies) es mucho menor que el número de elementos de datos (resúmenes de datos indexados), entonces esto resultará en ahorros significativos. Implementación: Para construir un grafo de salto de intervalo disperso, nos aseguramos de que haya un único elemento distinguido en cada sistema, el elemento raíz de ese sistema; todas las búsquedas comenzarán en uno de estos elementos raíz. Al agregar un nuevo elemento, en lugar de dividir las listas en niveles crecientes l hasta que el elemento esté en una lista sin otros, detenemos cuando encontramos que el elemento estaría en una lista que no contiene elementos raíz, asegurando así que el elemento sea accesible desde todos los elementos raíz. Un ejemplo de aplicación de esta optimización se puede ver en la Figura 5. (En la práctica, en lugar de designar elementos de datos existentes como raíces, como se muestra, puede ser preferible insertar valores nulos al inicio.) Al utilizar la técnica de vectores de membresía como en [1], esto se puede hacer mediante la difusión de los vectores de membresía de cada elemento raíz a todos los demás sistemas, y deteniendo la inserción de un elemento en el nivel l cuando no comparte un prefijo de l bits con ninguno de los Np elementos raíz. El número esperado de raíces que comparten un prefijo de log2Np bits es 1, lo que da una altura esperada para cada elemento de log2Np + O(1). Una implementación alternativa, que distribuye información sobre los elementos raíz en el momento de establecer el puntero, se omite debido a limitaciones de espacio; este método elimina la necesidad de mensajes adicionales. Rendimiento: En un grafo de salto disperso (no intervalo), dado que la altura esperada de un elemento insertado es ahora log2 Np + O(1), la complejidad esperada de inserción es O(log Np), en lugar de O(log n), donde Np es el número de elementos raíz y, por lo tanto, el número de sistemas separados en la red. (En el caso degenerado de un solo sistema tenemos una lista de salto; con una probabilidad de división de 0.5, la altura esperada de un elemento individual es 1). Ten en cuenta que dado que las búsquedas comienzan en los elementos raíz de altura esperada log2 n, la complejidad de la búsqueda no se mejora. Para un grafo de salto disperso de intervalo, el rendimiento de actualización se mejora considerablemente en comparación con el peor caso O(n) para el caso no disperso. En una estructura de búsqueda aumentada como esta, un elemento solo almacena información para los nodos a los que se puede acceder desde ese elemento, por ejemplo, el subárbol con raíz en ese elemento, en el caso de un árbol. Por lo tanto, al actualizar el valor máximo en un árbol de intervalos, la actualización solo se propaga hacia la raíz. En un grafo de salto de intervalo disperso, las actualizaciones a un nodo solo se propagan hacia los Np elementos raíz, con un costo en el peor de los casos de Np log2 n. Búsqueda de atajos: al comenzar una búsqueda de un valor v, en lugar de comenzar en la raíz en ese proxy, podemos encontrar el elemento más cercano a v (por ejemplo, usando un índice local secundario) y luego comenzar la búsqueda en ese elemento. La distancia esperada entre este elemento y el término de búsqueda es log2 Np, y la búsqueda ahora tomará en promedio log2 Np + O(1) pasos. Para ilustrar esta optimización, en la Figura 4, dependiendo de la elección de la raíz de búsqueda, una búsqueda de [21, 30] comenzando en el nodo 2 puede tomar 3 saltos de red, pasando por el nodo 1, luego de regreso al nodo 2, y finalmente al nodo 3 donde se encuentra el destino, con un costo de 3 mensajes. La búsqueda de atajo, sin embargo, localiza el elemento de datos intermedio en el nodo 2, y luego procede directamente al nodo 3 por un costo de 1 mensaje. Rendimiento: Esta técnica puede aplicarse a la búsqueda de la clave primaria, que es el primer paso de las dos etapas de inserción en un grafo de salto de intervalo. Al combinar la optimización de atajos con los grafos de salto de intervalos dispersos, el costo esperado de inserción es ahora O(log Np), independiente del tamaño del índice o del grado de superposición de los intervalos insertados. 3.4 Estructuras de Datos Alternativas Hasta ahora solo hemos comparado el grafo de salto de intervalos dispersos con estructuras similares de las que se deriva. Una comparación con varias otras estructuras de datos que cumplen al menos algunos de los requisitos para el índice TSAR se muestra en la Tabla 2. 44 Tabla 2: Comparación de Estructuras de Índices Distribuidos Soporte de Consultas de Rango Representación de Intervalos Re-equilibrado Resiliencia Redes Pequeñas Redes Grandes DHT, GHT no no no sí bueno bueno Índice local, consulta de inundación sí sí no sí bueno mal P-tree, RP* (árboles B distribuidos) sí posible sí no bueno bueno DIMS sí no sí sí sí sí Interval Skipgraph sí sí no sí bueno bueno [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Raíces Nodo 1 Nodo 2 Figura 5: Grafo de Intervalos Escasos basado en Hash Los sistemas basados en hash, DHT [25] y GHT [26], carecen de la capacidad para realizar consultas de rango y, por lo tanto, no son adecuados para indexar datos espacio-temporales. Indexar localmente utilizando una estructura de un solo nodo apropiada y luego inundar consultas a todos los proxies es una alternativa competitiva para redes pequeñas; para redes grandes, la dependencia lineal en el número de proxies se convierte en un problema. Se examinaron dos B-Trees distribuidos: P-Trees [6] y RP* [19]. Cada uno de estos admite consultas de rango, y en teoría podrían ser modificados para admitir la indexación de intervalos; sin embargo, ambos requieren un reequilibrio complejo y no proporcionan las características de resistencia de las otras estructuras. DIMS [18] proporciona la capacidad de realizar consultas de rango espacio-temporales y tiene la resiliencia necesaria ante fallos; sin embargo, no puede utilizarse para indexar intervalos, los cuales son utilizados por el algoritmo de resumen de datos TSARs. 4. Almacenamiento y resumen de datos Habiendo descrito la estructura de índice a nivel de proxy, pasamos a los mecanismos en el nivel del sensor. TSAR implementa dos mecanismos clave en el nivel del sensor. El primero es una tienda de archivos local en cada nodo sensor que está optimizada para dispositivos con recursos limitados. La segunda es una técnica de resumen adaptativo que permite que cada sensor se adapte a las cambiantes características de los datos y las consultas. El resto de esta sección describe estos mecanismos en detalle. 4.1 Almacenamiento Local en Sensores Los intervalos de salto de grafo proporcionan un mecanismo eficiente para buscar nodos de sensores que contienen datos relevantes para una consulta. Estas consultas son luego enviadas a los sensores, los cuales localizan los registros de datos relevantes en el archivo local y responden al proxy. Para habilitar dichas búsquedas, cada nodo sensor en TSAR mantiene un almacén de archivos de datos del sensor. Mientras que la implementación de un almacén de archivos de este tipo es sencilla en dispositivos con recursos que pueden ejecutar una base de datos, los sensores suelen tener limitaciones de energía y recursos. Por consiguiente, el subsistema de archivo de sensores en TSAR está diseñado explícitamente para aprovechar las características de los datos de los sensores en un entorno con recursos limitados. Parámetros de calibración de la marca de tiempo Datos opacos Tamaño de los atributos de datos/eventos Figura 6: Registro de almacenamiento único Los datos del sensor tienen características muy distintas que informan nuestro diseño del almacén de archivos TSAR. Los sensores producen flujos de datos en series temporales, por lo tanto, el orden temporal de los datos es una forma natural y sencilla de almacenar datos de sensores archivados. Además de la simplicidad, una tienda ordenada temporalmente suele ser adecuada para muchas tareas de procesamiento de datos de sensores, ya que implican el procesamiento de datos de series temporales. Ejemplos incluyen operaciones de procesamiento de señales como FFT, transformadas de wavelet, agrupamiento, coincidencia de similitudes y detección de objetivos. Por consiguiente, la tienda de archivos local es una colección de registros, diseñada como un búfer circular de solo agregación, donde los nuevos registros se agregan a la cola del búfer. El formato de cada registro de datos se muestra en la Figura 6. Cada registro tiene un campo de metadatos que incluye una marca de tiempo, ajustes del sensor, parámetros de calibración, etc. Los datos crudos del sensor se almacenan en el campo de datos del registro. El campo de datos es opaco y específico de la aplicación: el sistema de almacenamiento no sabe ni le importa interpretar este campo. Un sensor basado en cámara, por ejemplo, puede almacenar imágenes binarias en este campo de datos. Para poder soportar una variedad de aplicaciones, TSAR admite campos de datos de longitud variable; como resultado, los tamaños de los registros pueden variar de un registro a otro. Nuestra tienda de archivos admite tres operaciones en registros: crear, leer y eliminar. Debido a la naturaleza de solo agregar del almacén, la creación de registros es simple y eficiente. La operación de creación simplemente crea un nuevo registro y lo añade al final de la tienda. Dado que los registros siempre se escriben al final, la tienda no necesita mantener una lista de espacio libre. Todos los campos del registro deben especificarse en el momento de la creación; por lo tanto, el tamaño del registro se conoce de antemano y la tienda simplemente asigna el número correspondiente de bytes en la cola para almacenar el registro. Dado que las escrituras son inmutables, el tamaño de un registro no cambia una vez que se crea. La operación de lectura permite recuperar los registros almacenados para responder consultas. En un sistema de base de datos tradicional, las búsquedas eficientes se logran manteniendo una estructura como un árbol B que indexa ciertas claves de los registros. Sin embargo, esto puede ser bastante complejo para un nodo sensor pequeño con recursos limitados. Por consiguiente, los sensores TSAR no mantienen ningún índice para los datos almacenados en su archivo. En cambio, dependen de los proxies para mantener este índice de metadatos: los sensores envían periódicamente la información del proxy resumiendo los datos contenidos en una secuencia contigua de registros, así como un identificador que indica la ubicación de estos registros en la memoria flash. El mecanismo funciona de la siguiente manera: Además del resumen de los datos del sensor, cada nodo envía metadatos al proxy que contienen el intervalo de tiempo correspondiente al resumen, así como los desplazamientos de inicio y fin de la ubicación de la memoria flash donde se almacenan los datos crudos correspondientes (como se muestra en la Figura 7). Por lo tanto, el acceso aleatorio se habilita en la granularidad de un resumen: el desplazamiento de inicio de cada fragmento de registros representado por un resumen es conocido por el proxy. Dentro de esta colección, los registros se acceden de forma secuencial. Cuando una consulta coincide con un resumen en el índice, el sensor utiliza estos desplazamientos para acceder a los registros relevantes en su memoria flash local mediante la lectura secuencial de datos desde la dirección de inicio hasta la dirección de fin. Cualquier operación específica de consulta puede realizarse en estos datos. Por lo tanto, no es necesario mantener un índice en el sensor, en línea con nuestro objetivo de simplificar la gestión del estado del sensor. El estado del archivo se captura en los metadatos asociados con los resúmenes, y se almacena y mantiene en el proxy. Si bien anticipamos que la capacidad de almacenamiento local será grande, eventualmente podría ser necesario sobrescribir datos antiguos, especialmente en aplicaciones de alta tasa de datos. Esto se puede hacer a través de técnicas como el almacenamiento de datos de múltiple resolución [9], o simplemente sobrescribiendo datos antiguos. Cuando se sobrescribe datos antiguos, se realiza una operación de eliminación, donde se elimina una entrada de índice del grafo de salto de intervalo en el proxy y se libera el espacio de almacenamiento correspondiente en la memoria flash en el sensor. 4.2 Resumen Adaptativo Los resúmenes de datos sirven como unión entre el almacenamiento en el sensor remoto y el índice en el proxy. Cada actualización de un sensor al proxy incluye tres piezas de información: el resumen, un período de tiempo correspondiente al resumen, y los desplazamientos de inicio y fin para el archivo flash. En general, el proxy puede indexar el intervalo de tiempo que representa un resumen o el rango de valores informado en el resumen (o ambos). El primer índice permite búsquedas rápidas en todos los registros vistos durante un cierto intervalo, mientras que el segundo índice permite búsquedas rápidas en todos los registros que coinciden con un cierto valor. Como se describe en la Sección 2.4, existe un equilibrio entre la energía utilizada en el envío de resúmenes (y, por lo tanto, la frecuencia y resolución de esos resúmenes) y el costo de los falsos positivos durante las consultas. Cuanto más gruesa y menos frecuente sea la información resumida, menos energía se requiere, mientras que las consultas falsas desperdician energía en solicitudes de datos que no existen. TSAR emplea una técnica de resumen adaptativo que equilibra el costo de enviar actualizaciones con el costo de los falsos positivos. La intuición clave es que cada sensor puede identificar de forma independiente la fracción de falsos positivos y verdaderos positivos para las consultas que acceden a su archivo local. Si la mayoría de las consultas resultan en aciertos verdaderos, entonces el sensor determina que el resumen puede ser simplificado aún más para reducir los costos de actualización sin afectar negativamente la proporción de aciertos. Si muchas consultas resultan en falsos positivos, entonces el sensor hace que la granularidad de cada resumen sea más fina para reducir el número y la carga de trabajo de los falsos positivos. La resolución del resumen depende de dos parámetros: el intervalo en el que se construyen y transmiten los resúmenes de los datos al proxy, así como el tamaño del resumen específico de la aplicación. Nuestro enfoque en este artículo se centra en el intervalo durante el cual se construye el resumen. Cambiar el tamaño del resumen de datos puede realizarse de manera específica para una aplicación (por ejemplo, utilizando técnicas de compresión de wavelet como en [9]) y está fuera del alcance de este documento. Actualmente, TSAR emplea un esquema de resumen simple que calcula la proporción de aciertos falsos y verdaderos y disminuye (aumenta) el intervalo entre resúmenes siempre que esta proporción aumente (disminuya) más allá de un umbral. 5. Hemos implementado un prototipo de TSAR en un banco de pruebas de red de sensores de múltiples niveles. Nuestro prototipo emplea nodos Crossbow Stargate para implementar la capa de proxy. Cada nodo de la Puerta Estelar emplea un procesador Intel XScale de 400MHz con 64MB de RAM y ejecuta el kernel Linux 2.4.19 y la versión EmStar 2.1. Los nodos proxy están equipados con dos radios inalámbricas, una radio 802.11b basada en Cisco Aironet 340 y un puente hostmote hacia los nodos sensores Mica2 utilizando el transceptor EmStar. La red inalámbrica 802.11b se utiliza para la comunicación entre proxies dentro del nivel de proxy, mientras que el puente inalámbrico permite la comunicación entre sensores y proxies. La capa del sensor consiste en Crossbow Mica2s y Mica2dots, cada uno compuesto por una radio CC1000 de 915MHz, una pila de protocolo BMAC, una memoria flash integrada de 4 Mb y un procesador ATMega 128L. Los nodos sensores ejecutan TinyOS 1.1.8. Además del flash incorporado, los nodos de sensor pueden equiparse con tarjetas de memoria externas MMC/SD utilizando un conector personalizado. Los nodos proxy pueden estar equipados con almacenamiento externo como tarjetas compact flash de alta capacidad (hasta 4GB), microdiscos de 6GB o discos duros móviles de 1.8 pulgadas de hasta 60GB. Dado que los nodos sensores pueden estar a varios saltos de distancia del proxy más cercano, la capa de sensores utiliza enrutamiento de múltiples saltos para comunicarse con la capa de proxy. Además, para reducir el consumo de energía de la radio mientras se mantiene el nodo del sensor disponible para consultas, se activa la escucha de baja potencia, en la que el receptor de radio se enciende periódicamente durante un breve intervalo para detectar el canal de transmisiones, y el preámbulo del paquete se extiende para tener en cuenta la latencia hasta el próximo intervalo cuando la radio receptora se despierta. Nuestro prototipo emplea el protocolo de enrutamiento MultiHopLEPSM con la capa BMAC configurada en modo de bajo consumo con un ciclo de trabajo del 11% (uno de los parámetros predeterminados de BMAC [22]). Nuestra implementación de TSAR en el Mote implica una tarea de recolección de datos que obtiene periódicamente lecturas de sensores y registra estas lecturas en la memoria flash. Se asume que la memoria flash es un almacén circular de solo escritura y el formato de los datos registrados se muestra en la Figura 6. El Mote envía un informe al proxy cada N lecturas, resumiendo los datos observados. El informe contiene: (i) la dirección del Mote, (ii) un identificador que contiene un desplazamiento y la longitud de la región en la memoria flash que contiene los datos referidos por el resumen, (iii) un intervalo (t1, t2) durante el cual se generó este informe, (iv) una tupla (bajo, alto) que representa los valores mínimo y máximo observados en el sensor en el intervalo, y (v) un número de secuencia. Las actualizaciones del sensor se utilizan para construir un grafo de salto de intervalo disperso que se distribuye entre proxies, a través de mensajes de red entre proxies sobre la red inalámbrica 802.11b. Nuestra implementación actual admite consultas que solicitan registros que coincidan con un intervalo de tiempo (t1, t2) o un rango de valores (v1, v2). Las restricciones espaciales se especifican utilizando identificadores de sensores. Dado un listado de intervalos coincidentes del skip graph, TSAR admite dos tipos de mensajes para consultar el sensor: búsqueda y recuperación. Un mensaje de búsqueda activa una búsqueda dentro de la región correspondiente en la memoria flash y devuelve el número de registros coincidentes en esa región de memoria (pero no recupera datos). Por el contrario, un mensaje de recuperación no solo desencadena una búsqueda, sino que también devuelve todos los registros de datos coincidentes al proxy. Los mensajes de búsqueda son útiles para sondear un sensor, por ejemplo, para determinar si una consulta coincide con demasiados registros. 6. En esta sección, evaluamos la eficacia de TSAR utilizando nuestro prototipo y simulaciones. El banco de pruebas para nuestros experimentos consiste en cuatro proxies de Stargate y doce sensores Mica2 y Mica2dot; tres sensores están asignados a cada proxy. Dada la limitada dimensión de nuestro banco de pruebas, empleamos simulaciones para evaluar el comportamiento de TSAR en entornos más grandes. Nuestra simulación utiliza el emulador EmTOS [10], que nos permite ejecutar el mismo código en la simulación y en la plataforma de hardware. En lugar de utilizar datos en tiempo real de un sensor real, para garantizar experimentos repetibles, sembramos cada nodo del sensor con un conjunto de datos (es decir, una traza) que dicta los valores reportados por ese nodo al proxy. Una sección de la memoria flash en cada nodo sensor se programa con puntos de datos del rastro; estas observaciones luego se reproducen durante un experimento, se registran en el archivo local (ubicado también en la memoria flash) y se informan al proxy. El primer conjunto de datos utilizado para evaluar TSAR es un conjunto de datos de temperatura de la Reserva James [27] que incluye datos de once nodos de sensores de temperatura durante un período de 34 días. El segundo conjunto de datos es generado de forma sintética; la traza de cada sensor se genera utilizando un paseo aleatorio distribuido uniformemente a través del espacio de valores. Nuestra evaluación experimental tiene cuatro partes. Primero, ejecutamos simulaciones de EmTOS para evaluar el sobrecosto de búsqueda, actualización y eliminación para los grafos de salto de intervalo disperso utilizando conjuntos de datos reales y sintéticos. Segundo, proporcionamos resultados resumidos de micro-benchmarks del componente de almacenamiento de TSAR, que incluyen la caracterización empírica de los costos energéticos y la latencia de lecturas y escrituras para el chip de memoria flash, así como para toda la plataforma mote, y comparaciones con cifras publicadas de otras tecnologías de almacenamiento y comunicación. Estos micro-benchmarks forman la base de nuestra evaluación a gran escala de TSAR en un banco de pruebas de cuatro proxies Stargate y doce Motes. Medimos la latencia de consulta de extremo a extremo en nuestro banco de pruebas de múltiples saltos, así como la sobrecarga de procesamiento de consultas en el nivel de mota. Finalmente, demostramos la capacidad de resumen adaptativo en cada nodo sensor. El resto de esta sección presenta nuestros resultados experimentales. 6.1 Rendimiento del Grafo de Salto de Intervalo Escaso Esta sección evalúa el rendimiento de los grafos de salto de intervalo escaso mediante la cuantificación de los costos adicionales de inserción, búsqueda y eliminación. Suponemos un nivel de proxy con 32 proxies y construimos gráficos de salto de intervalo dispersos de varios tamaños utilizando nuestros conjuntos de datos. Para cada salto 0 5 10 15 20 25 30 35 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (a) Reserva de Datos de James 0 2 4 6 8 10 12 14 409620481024512 Número de mensajes Tamaño del índice (entradas) Búsqueda inicial Travesía (b) Datos Sintéticos Figura 9: Rendimiento de Búsqueda de Skip Graph 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Número de mensajes Número de proxies Inserción de Skipgraph Inserción de Skipgraph disperso Búsqueda inicial (a) Impacto del Número de Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 Número de mensajes Tamaño del índice (entradas) Inserción (redundante) Inserción (no redundante) Búsqueda (redundante) Búsqueda (no redundante) (b) Impacto de Resúmenes Redundantes Figura 10: Costos Adicionales de Skip Graph, evaluamos el costo de insertar un nuevo valor en el índice. Cada entrada fue eliminada después de su inserción, lo que nos permitió cuantificar el sobrecosto de eliminación también. La figura 8(a) y (b) cuantifican el sobrecoste de inserción para nuestros dos conjuntos de datos: cada inserción implica un recorrido inicial que incurre en log n mensajes, seguido de una actualización de punteros de vecinos en niveles crecientes, con un coste de 4 log n mensajes. Nuestros resultados demuestran este comportamiento, y también muestran que el rendimiento de la eliminación, que también implica un recorrido inicial seguido de actualizaciones de punteros en cada nivel, incurre en un costo similar. A continuación, evaluamos el rendimiento de búsqueda de la estructura de índice. Nuevamente, construimos skip graphs de varios tamaños utilizando nuestros conjuntos de datos y evaluamos el costo de una búsqueda en la estructura de índice. Las figuras 9(a) y (b) representan nuestros resultados. Hay dos componentes para cada búsqueda: la búsqueda del primer intervalo que coincide con la consulta y, en el caso de intervalos superpuestos, la travesía lineal subsiguiente para identificar todos los intervalos coincidentes. La búsqueda inicial se puede ver que toma log n mensajes, como se esperaba. Los costos del recorrido lineal posterior, sin embargo, dependen en gran medida de los datos. Por ejemplo, los valores de temperatura para los datos de la Reserva James muestran correlaciones espaciales significativas, lo que resulta en una superposición significativa entre diferentes intervalos y un costo de recorrido variable y alto (ver Figura 9(a)). Los datos sintéticos, sin embargo, tienen menos superposición y generan un menor sobrecosto de recorrido, como se muestra en la Figura 9(b). Dado que los experimentos anteriores asumieron 32 proxies, evaluamos el impacto del número de proxies en el rendimiento del grafo de salto. Variamos el número de proxies de 10 a 48 y distribuimos un grafo de salto con 4096 entradas entre estos proxies. Construimos grafos de salto de intervalo regulares, así como grafos de salto de intervalo dispersos utilizando estas entradas y medimos el sobrecoste de inserciones y búsquedas. Por lo tanto, el experimento también busca demostrar los beneficios de los grafos de salto dispersos sobre los grafos de salto regulares. La figura 10(a) representa nuestros resultados. En los skip graphs regulares, la complejidad de la inserción es O(log2n) en el caso esperado 47 (y O(n) en el peor caso) donde n es el número de elementos. Esta complejidad no se ve afectada por el cambio en el número de proxies, como se indica por la línea plana en la figura. Los gráficos de salto dispersos requieren menos actualizaciones de punteros; sin embargo, su sobrecarga depende del número de proxies, y es O(log2Np) en el caso esperado, independientemente de n. Esto puede verse como un resultado de una reducción significativa en la sobrecarga cuando el número de proxies es pequeño, lo cual disminuye a medida que el número de proxies aumenta. El manejo de fallos es un tema importante en una arquitectura de sensor de múltiples niveles, ya que depende de muchos componentes: los proxies, los nodos sensores y los nodos de enrutamiento pueden fallar, y los enlaces inalámbricos pueden debilitarse. El manejo de muchos de estos modos de falla está fuera del alcance de este documento; sin embargo, consideramos el caso de la resiliencia de los gráficos de salto a fallas de proxy. En este caso, la búsqueda de gráficos de salto (y las operaciones de reparación subsiguientes) pueden seguir cualquiera de los otros enlaces desde un elemento raíz. Dado que un grafo de salto disperso tiene árboles de búsqueda enraizados en cada nodo, la búsqueda puede reanudarse una vez que la solicitud de búsqueda haya evitado el fallo. Juntas, estas dos propiedades aseguran que incluso si un proxy falla, las entradas restantes en el grafo de salto serán alcanzables con alta probabilidad, solo las entradas en el proxy fallido y los datos correspondientes en los sensores se volverán inaccesibles. Para garantizar que todos los datos de los sensores sigan siendo accesibles, incluso en caso de fallo de un proxy que contenga entradas de índice para esos datos, incorporamos entradas de índice redundantes. TSAR emplea un esquema de redundancia simple donde se utilizan resúmenes de grano grueso adicionales para proteger los resúmenes regulares. Cada sensor envía datos resumidos periódicamente a su proxy local, pero con menos frecuencia envía un resumen de menor resolución a un proxy de respaldo: el resumen de respaldo representa todos los datos representados por los resúmenes de mayor granularidad, pero de una manera menos precisa, lo que resulta en una mayor sobrecarga de lectura (debido a falsos aciertos) si se utiliza el resumen de respaldo. El costo de implementar esto en nuestro sistema es bajo: la Figura 10(b) muestra el sobrecosto de un esquema de redundancia, donde se envía un resumen general a una copia de seguridad por cada dos resúmenes enviados al proxy principal. Dado que se envía un resumen redundante por cada dos resúmenes, el costo de inserción es 1.5 veces el costo en el caso normal. Sin embargo, estas entradas redundantes resultan en un aumento insignificante en la sobrecarga de búsqueda, debido a la dependencia logarítmica del costo de búsqueda en el tamaño del índice, al tiempo que proporcionan total resiliencia ante cualquier fallo de un único proxy. 6.2 Microbenchmarks de Almacenamiento Dado que los sensores tienen recursos limitados, el consumo de energía y la latencia en esta capa son medidas importantes para evaluar el rendimiento de una arquitectura de almacenamiento. Antes de realizar una evaluación de extremo a extremo de nuestro sistema, proporcionamos información más detallada sobre el consumo de energía del componente de almacenamiento utilizado para implementar el archivo local TSAR, basado en mediciones empíricas. Además, comparamos estas cifras con las de otras tecnologías de almacenamiento local, así como con el consumo de energía de la comunicación inalámbrica, utilizando información de la literatura. Para las mediciones empíricas medimos el consumo de energía para el componente de almacenamiento en sí mismo (es decir, la corriente extraída por el chip flash), así como para todo el mote Mica2. Las mediciones de potencia en la Tabla 3 se realizaron para la memoria flash AT45DB041 [15] en un mote Mica2, que es un dispositivo NOR flash más antiguo. La tecnología más prometedora para el almacenamiento de baja energía en dispositivos de detección es NAND flash, como el dispositivo Samsung K9K4G08U0M [16]; los números de consumo de energía publicados para este dispositivo se proporcionan en la tabla. Los requisitos de energía publicados para la transmisión inalámbrica utilizando la radio Chipcon [4] CC2420 (utilizada en los nodos MicaZ y Telos) se proporcionan para su comparación, asumiendo Energía Energía/byte Mote flash Leer página de 256 bytes 58µJ* / 136µJ* total 0.23µJ* Escribir página de 256 bytes 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Leer página de 512 bytes 2.7µJ 1.8nJ Escribir página de 512 bytes 7.8µJ 15nJ Borrar sector de 16K bytes 60µJ 3.7nJ Radio CC2420 Transmitir 8 bits (-25dBm) 0.8µJ 0.8µJ Recibir 8 bits 1.9µJ 1.9µJ Procesador AVR del Mote Búsqueda en memoria, 256 bytes 1.8µJ 6.9nJ Tabla 3: Costos de energía de almacenamiento y comunicación (*valores medidos) 0 200 400 600 800 1000 1 2 3 Latencia(ms) Número de saltos (a) Rendimiento de consulta multi-salto 0 100 200 300 400 500 1 5121024 2048 4096 Latencia(ms) Tamaño del índice (entradas) Comunicación del sensor Comunicación del proxy Búsqueda y procesamiento del sensor (b) Rendimiento de consulta Figura 11: Latencia de procesamiento de consultas sin sobrecarga de red y protocolo. Al comparar el costo total de energía para escribir en flash (borrar + escribir) con el costo total de comunicación (transmitir + recibir), encontramos que la memoria flash NAND es casi 150 veces más eficiente que la comunicación por radio, incluso asumiendo protocolos de red perfectos. 6.3 Evaluación del prototipo Esta sección informa los resultados de una evaluación de extremo a extremo del prototipo TSAR que involucra ambas capas. En nuestra configuración, hay cuatro proxies conectados a través de enlaces 802.11 y tres sensores por proxy. La topología de múltiples saltos fue preconfigurada de tal manera que los nodos sensores estaban conectados en línea a cada proxy, formando un árbol mínimo de profundidad 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Latencia de recuperación (ms) Datos archivados recuperados (bytes) (a) Tiempo de consulta y recuperación de datos 0 2 4 6 8 10 12 4 8 16 32 Latencia (ms) Número de registros de 34 bytes buscados (b) Retraso en el procesamiento de consultas de sensores Figura 12: Componentes de la latencia de consulta 48 3. Debido a limitaciones de recursos, no pudimos realizar experimentos con docenas de nodos sensores, sin embargo, esta topología garantizó que el diámetro de la red fuera tan grande como en una red típica de tamaño significativamente mayor. Nuestro métrica de evaluación es la latencia de extremo a extremo del procesamiento de consultas. Una consulta planteada en TSAR primero incurre en la latencia de una búsqueda de grafo de salto disperso, seguida por el enrutamiento hacia el(los) nodo(s) sensor(es) apropiado(s). El nodo del sensor lee la(s) página(s) requerida(s) de su archivo local, procesa la consulta en la página leída y transmite la respuesta al proxy, el cual luego la reenvía al usuario. Primero medimos la latencia de consulta para diferentes sensores en nuestra topología de múltiples saltos. Dependiendo de cuál de los sensores se consulte, la latencia total aumenta casi linealmente desde aproximadamente 400 ms hasta 1 segundo, a medida que el número de saltos aumenta de 1 a 3 (ver Figura 11(a)). La Figura 11(b) proporciona un desglose de los diversos componentes de la latencia de extremo a extremo. El componente dominante de la latencia total es la comunicación a través de uno o más saltos. El tiempo típico para comunicarse a través de un salto es aproximadamente de 300ms. Esta gran latencia se debe principalmente al uso de una capa MAC con ciclo de trabajo; la latencia será mayor si se reduce el ciclo de trabajo (por ejemplo, el ajuste del 2% en lugar del ajuste del 11.5% utilizado en este experimento), y disminuirá en consecuencia si se aumenta el ciclo de trabajo. La figura también muestra la latencia para diferentes tamaños de índice; como era de esperar, la latencia de la comunicación entre proxies y las búsquedas en el grafo de saltos aumenta de forma logarítmica con el tamaño del índice. Como era de esperar, la sobrecarga vista en el sensor es independiente del tamaño del índice. La latencia también depende del número de paquetes transmitidos en respuesta a una consulta: cuanto mayor sea la cantidad de datos recuperados por una consulta, mayor será la latencia. Este resultado se muestra en la Figura 12(a). La función de paso se debe a la fragmentación en TinyOS; TinyOS envía un paquete siempre y cuando la carga útil sea menor a 30 bytes y divide la respuesta en varios paquetes para cargas útiles más grandes. A medida que los datos recuperados por una consulta aumentan, la latencia aumenta en pasos, donde cada paso denota el sobrecargo de un paquete adicional. Finalmente, la Figura 12(b) muestra el impacto de la búsqueda y procesamiento de regiones de memoria flash de tamaños crecientes en un sensor. Cada resumen representa una colección de registros en memoria flash, y todos estos registros deben ser recuperados y procesados si ese resumen coincide con una consulta. Cuanto más grueso sea el resumen, más grande será la región de memoria que se necesita acceder. Para los tamaños de búsqueda examinados, la amortización de los costos generales al buscar múltiples páginas flash y registros de archivo, así como dentro del chip flash y su controlador asociado, resulta en la aparición de un aumento sublineal en la latencia con el tamaño de búsqueda. Además, la operación puede verse que tiene una latencia muy baja, en parte debido a la simplicidad de nuestro procesamiento de consultas, que solo requiere una operación de comparación con cada elemento almacenado. Operaciones más complejas, sin embargo, por supuesto, conllevarán una mayor latencia. 6.4 Resumen Adaptativo Cuando los datos son resumidos por el sensor antes de ser reportados al proxy, se pierde información. Con el método de resumen de intervalos que estamos utilizando, esta pérdida de información nunca hará que el proxy crea que un nodo sensor no tiene un valor que de hecho tiene, ya que todos los valores archivados estarán contenidos dentro del intervalo reportado. Sin embargo, hace que el proxy crea que el sensor puede contener valores que en realidad no tiene, y reenvíe mensajes de consulta al sensor para obtener estos valores. Estos falsos positivos constituyen el costo del mecanismo de resumen, y deben ser equilibrados con los ahorros logrados al reducir el número de informes. El objetivo de la sumarización adaptativa es variar dinámicamente el tamaño del resumen para que estos dos costos estén equilibrados. La Figura 13(a) demuestra el impacto de la granularidad del resumen en los falsos aciertos. A medida que se aumenta el número de registros incluidos en un resumen, la fracción de consultas enviadas al sensor que coinciden con los datos almacenados en ese sensor (verdaderos positivos) disminuye. A continuación, en la Figura 13(b) ejecutamos una simulación de EmTOS con nuestro algoritmo de resumen adaptativo habilitado. El algoritmo adaptativo aumenta la granularidad del resumen (definida como el número de registros por resumen) cuando Cost(actualizaciones) Cost(falsos positivos) > 1 + y la reduce si Cost(actualizaciones) Cost(falsos positivos) > 1 − , donde es una constante pequeña. Para demostrar la naturaleza adaptable de nuestra técnica, trazamos una serie temporal de la granularidad de la sumarización. Comenzamos con una tasa de consulta de 1 consulta por cada 5 muestras, la disminuimos a 1 cada 30 muestras, y luego la aumentamos nuevamente a 1 consulta por cada 10 muestras. Como se muestra en la Figura 13(b), la técnica adaptativa se ajusta en consecuencia enviando más resúmenes de grano fino a tasas de consulta más altas (en respuesta a la mayor tasa de falsos positivos) y menos resúmenes de grano grueso a tasas de consulta más bajas. 7. Trabajo relacionado En esta sección, revisamos trabajos previos sobre técnicas de almacenamiento e indexación para redes de sensores. Si bien nuestro trabajo aborda ambos problemas de manera conjunta, gran parte de los trabajos anteriores los han considerado de forma aislada. El problema del <br>almacenamiento archivístico</br> de datos de sensores ha recibido una atención limitada en la literatura de redes de sensores. ",
            "candidates": [],
            "error": [
                [
                    "almacenamiento archivado",
                    "almacenamiento archivado",
                    "almacenamiento de archivos",
                    "almacenamiento archivístico"
                ]
            ]
        },
        "index method": {
            "translated_key": "método de índice",
            "is_in_text": false,
            "original_annotated_sentences": [
                "TSAR: A Two Tier Sensor Storage Architecture Using Interval Skip Graphs ∗ Peter Desnoyers, Deepak Ganesan, and Prashant Shenoy Department of Computer Science University of Massachusetts Amherst, MA 01003 pjd@cs.umass.edu, dganesan@cs.umass.edu, shenoy@cs.umass.edu ABSTRACT Archival storage of sensor data is necessary for applications that query, mine, and analyze such data for interesting features and trends.",
                "We argue that existing storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks, where an application can comprise tens of tethered proxies, each managing tens to hundreds of untethered sensors.",
                "We present TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local archiving at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Interval Skip Graph, for efficiently supporting spatio-temporal and value queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade off the cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarse-grain index.",
                "We implement TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experiments demonstrate the benefits and feasibility of using our energy-efficient storage architecture in multi-tier sensor networks.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems General Terms: Algorithms, performance, experimentation. 1.",
                "Introduction 1.1 Motivation Many different kinds of networked data-centric sensor applications have emerged in recent years.",
                "Sensors in these applications sense the environment and generate data that must be processed, filtered, interpreted, and archived in order to provide a useful infrastructure to its users.",
                "To achieve its goals, a typical sensor application needs access to both live and past sensor data.",
                "Whereas access to live data is necessary in monitoring and surveillance applications, access to past data is necessary for applications such as mining of sensor logs to detect unusual patterns, analysis of historical trends, and post-mortem analysis of particular events.",
                "Archival storage of past sensor data requires a storage system, the key attributes of which are: where the data is stored, whether it is indexed, and how the application can access this data in an energy-efficient manner with low latency.",
                "There have been a spectrum of approaches for constructing sensor storage systems.",
                "In the simplest, sensors stream data or events to a server for long-term archival storage [3], where the server often indexes the data to permit efficient access at a later time.",
                "Since sensors may be several hops from the nearest base station, network costs are incurred; however, once data is indexed and archived, subsequent data accesses can be handled locally at the server without incurring network overhead.",
                "In this approach, the storage is centralized, reads are efficient and cheap, while writes are expensive.",
                "Further, all data is propagated to the server, regardless of whether it is ever used by the application.",
                "An alternate approach is to have each sensor store data or events locally (e.g., in flash memory), so that all writes are local and incur no communication overheads.",
                "A read request, such as whether an event was detected by a particular sensor, requires a message to be sent to the sensor for processing.",
                "More complex read requests are handled by flooding.",
                "For instance, determining if an intruder was detected over a particular time interval requires the request to be flooded to all sensors in the system.",
                "Thus, in this approach, the storage is distributed, writes are local and inexpensive, while reads incur significant network overheads.",
                "Requests that require flooding, due to the lack of an index, are expensive and may waste precious sensor resources, even if no matching data is stored at those sensors.",
                "Research efforts such as Directed Diffusion [17] have attempted to reduce these read costs, however, by intelligent message routing.",
                "Between these two extremes lie a number of other sensor storage systems with different trade-offs, summarized in Table 1.",
                "The geographic hash table (GHT) approach [24, 26] advocates the use of an in-network index to augment the fully distributed nature of sensor storage.",
                "In this approach, each data item has a key associated with it, and a distributed or geographic hash table is used to map keys to nodes that store the corresponding data items.",
                "Thus, writes cause data items to be sent to the hashed nodes and also trigger updates to the in-network hash table.",
                "A read request requires a lookup in the in-network hash table to locate the node that stores the data 39 item; observe that the presence of an index eliminates the need for flooding in this approach.",
                "Most of these approaches assume a flat, homogeneous architecture in which every sensor node is energy-constrained.",
                "In this paper, we propose a novel storage architecture called TSAR1 that reflects and exploits the multi-tier nature of emerging sensor networks, where the application is comprised of tens of tethered sensor proxies (or more), each controlling tens or hundreds of untethered sensors.",
                "TSAR is a component of our PRESTO [8] predictive storage architecture, which combines archival storage with caching and prediction.",
                "We believe that a fundamentally different storage architecture is necessary to address the multi-tier nature of future sensor networks.",
                "Specifically, the storage architecture needs to exploit the resource-rich nature of proxies, while respecting resource constraints at the remote sensors.",
                "No existing sensor storage architecture explicitly addresses this dichotomy in the resource capabilities of different tiers.",
                "Any sensor storage system should also carefully exploit current technology trends, which indicate that the capacities of flash memories continue to rise as per Moores Law, while their costs continue to plummet.",
                "Thus it will soon be feasible to equip each sensor with 1 GB of flash storage for a few tens of dollars.",
                "An even more compelling argument is the energy cost of flash storage, which can be as much as two orders of magnitude lower than that for communication.",
                "Newer NAND flash memories offer very low write and erase energy costs - our comparison of a 1GB Samsung NAND flash storage [16] and the Chipcon CC2420 802.15.4 wireless radio [4] in Section 6.2 indicates a 1:100 ratio in per-byte energy cost between the two devices, even before accounting for network protocol overheads.",
                "These trends, together with the energy-constrained nature of untethered sensors, indicate that local storage offers a viable, energy-efficient alternative to communication in sensor networks.",
                "TSAR exploits these trends by storing data or events locally on the energy-efficient flash storage at each sensor.",
                "Sensors send concise identifying information, which we term metadata, to a nearby proxy; depending on the representation used, this metadata may be an order of magnitude or more smaller than the data itself, imposing much lower communication costs.",
                "The resource-rich proxies interact with one another to construct a distributed index of the metadata reported from all sensors, and thus an index of the associated data stored at the sensors.",
                "This index provides a unified, logical view of the distributed data, and enables an application to query and read past data efficiently - the index is used to pinpoint all data that match a read request, followed by messages to retrieve that data from the corresponding sensors.",
                "In-network index lookups are eliminated, reducing network overheads for read requests.",
                "This separation of data, which is stored at the sensors, and the metadata, which is stored at the proxies, enables TSAR to reduce energy overheads at the sensors, by leveraging resources at tethered proxies. 1.2 Contributions This paper presents TSAR, a novel two-tier storage architecture for sensor networks.",
                "To the best of our knowledge, this is the first sensor storage system that is explicitly tailored for emerging multitier sensor networks.",
                "Our design and implementation of TSAR has resulted in four contributions.",
                "At the core of the TSAR architecture is a novel distributed index structure based on interval skip graphs that we introduce in this paper.",
                "This index structure can store coarse summaries of sensor data and organize them in an ordered manner to be easily search1 TSAR: Tiered Storage ARchitecture for sensor networks. able.",
                "This data structure has O(log n) expected search and update complexity.",
                "Further, the index provides a logically unified view of all data in the system.",
                "Second, at the sensor level, each sensor maintains a local archive that stores data on flash memory.",
                "Our storage architecture is fully stateless at each sensor from the perspective of the metadata index; all index structures are maintained at the resource-rich proxies, and only direct requests or simple queries on explicitly identified storage locations are sent to the sensors.",
                "Storage at the remote sensor is in effect treated as appendage of the proxy, resulting in low implementation complexity, which makes it ideal for small, resourceconstrained sensor platforms.",
                "Further, the local store is optimized for time-series access to archived data, as is typical in many applications.",
                "Each sensor periodically sends a summary of its data to a proxy.",
                "TSAR employs a novel adaptive summarization technique that adapts the granularity of the data reported in each summary to the ratio of false hits for application queries.",
                "More fine grain summaries are sent whenever more false positives are observed, thereby balancing the energy cost of metadata updates and false positives.",
                "Third, we have implemented a prototype of TSAR on a multi-tier testbed comprising Stargate-based proxies and Mote-based sensors.",
                "Our implementation supports spatio-temporal, value, and rangebased queries on sensor data.",
                "Fourth, we conduct a detailed experimental evaluation of TSAR using a combination of EmStar/EmTOS [10] and our prototype.",
                "While our EmStar/EmTOS experiments focus on the scalability of TSAR in larger settings, our prototype evaluation involves latency and energy measurements in a real setting.",
                "Our results demonstrate the logarithmic scaling property of the sparse skip graph and the low latency of end-to-end queries in a duty-cycled multi-hop network .",
                "The remainder of this paper is structured as follows.",
                "Section 2 presents key design issues that guide our work.",
                "Section 3 and 4 present the proxy-level index and the local archive and summarization at a sensor, respectively.",
                "Section 5 discusses our prototype implementation, and Section 6 presents our experimental results.",
                "We present related work in Section 7 and our conclusions in Section 8. 2.",
                "Design Considerations In this section, we first describe the various components of a multi-tier sensor network assumed in our work.",
                "We then present a description of the expected usage models for this system, followed by several principles addressing these factors which guide the design of our storage system. 2.1 System Model We envision a multi-tier sensor network comprising multiple tiers - a bottom tier of untethered remote sensor nodes, a middle tier of tethered sensor proxies, and an upper tier of applications and user terminals (see Figure 1).",
                "The lowest tier is assumed to form a dense deployment of lowpower sensors.",
                "A canonical sensor node at this tier is equipped with low-power sensors, a micro-controller, and a radio as well as a significant amount of flash memory (e.g., 1GB).",
                "The common constraint for this tier is energy, and the need for a long lifetime in spite of a finite energy constraint.",
                "The use of radio, processor, RAM, and the flash memory all consume energy, which needs to be limited.",
                "In general, we assume radio communication to be substantially more expensive than accesses to flash memory.",
                "The middle tier consists of power-rich sensor proxies that have significant computation, memory and storage resources and can use 40 Table 1: Characteristics of sensor storage systems System Data Index Reads Writes Order preserving Centralized store Centralized Centralized index Handled at store Send to store Yes Local sensor store Fully distributed No index Flooding, diffusion Local No GHT/DCS [24] Fully distributed In-network index Hash to node Send to hashed node No TSAR/PRESTO Fully distributed Distributed index at proxies Proxy lookup + sensor query Local plus index update Yes User Unified Logical Store Queries (time, space, value) Query Response Cache Query forwarding Proxy Remote Sensors Local Data Archive on Flash Memory Interval Skip Graph Query forwarding summaries start index end index linear traversal Query Response Cache-miss triggered query forwarding summaries Figure 1: Architecture of a multi-tier sensor network. these resources continuously.",
                "In urban environments, the proxy tier would comprise a tethered base-station class nodes (e.g., Crossbow Stargate), each with with multiple radios-an 802.11 radio that connects it to a wireless mesh network and a low-power radio (e.g. 802.15.4) that connects it to the sensor nodes.",
                "In remote sensing applications [10], this tier could comprise a similar Stargate node with a solar power cell.",
                "Each proxy is assumed to manage several tens to hundreds of lower-tier sensors in its vicinity.",
                "A typical sensor network deployment will contain multiple geographically distributed proxies.",
                "For instance, in a building monitoring application, one sensor proxy might be placed per floor or hallway to monitor temperature, heat and light sensors in their vicinity.",
                "At the highest tier of our infrastructure are applications that query the sensor network through a query interface[20].",
                "In this work, we focus on applications that require access to past sensor data.",
                "To support such queries, the system needs to archive data on a persistent store.",
                "Our goal is to design a storage system that exploits the relative abundance of resources at proxies to mask the scarcity of resources at the sensors. 2.2 Usage Models The design of a storage system such as TSAR is affected by the queries that are likely to be posed to it.",
                "A large fraction of queries on sensor data can be expected to be spatio-temporal in nature.",
                "Sensors provide information about the physical world; two key attributes of this information are when a particular event or activity occurred and where it occurred.",
                "Some instances of such queries include the time and location of target or intruder detections (e.g., security and monitoring applications), notifications of specific types of events such as pressure and humidity values exceeding a threshold (e.g., industrial applications), or simple data collection queries which request data from a particular time or location (e.g., weather or environment monitoring).",
                "Expected queries of such data include those requesting ranges of one or more attributes; for instance, a query for all image data from cameras within a specified geographic area for a certain period of time.",
                "In addition, it is often desirable to support efficient access to data in a way that maintains spatial and temporal ordering.",
                "There are several ways of supporting range queries, such as locality-preserving hashes such as are used in DIMS [18].",
                "However, the most straightforward mechanism, and one which naturally provides efficient ordered access, is via the use of order-preserving data structures.",
                "Order-preserving structures such as the well-known B-Tree maintain relationships between indexed values and thus allow natural access to ranges, as well as predecessor and successor operations on their key values.",
                "Applications may also pose value-based queries that involve determining if a value v was observed at any sensor; the query returns a list of sensors and the times at which they observed this value.",
                "Variants of value queries involve restricting the query to a geographical region, or specifying a range (v1, v2) rather than a single value v. Value queries can be handled by indexing on the values reported in the summaries.",
                "Specifically, if a sensor reports a numerical value, then the index is constructed on these values.",
                "A search involves finding matching values that are either contained in the search range (v1, v2) or match the search value v exactly.",
                "Hybrid value and spatio-temporal queries are also possible.",
                "Such queries specify a time interval, a value range and a spatial region and request all records that match these attributes - find all instances where the temperature exceeded 100o F at location R during the month of August.",
                "These queries require an index on both time and value.",
                "In TSAR our focus is on range queries on value or time, with planned extensions to include spatial scoping. 2.3 Design Principles Our design of a sensor storage system for multi-tier networks is based on the following set of principles, which address the issues arising from the system and usage models above. • Principle 1: Store locally, access globally: Current technology allows local storage to be significantly more energyefficient than network communication, while technology trends show no signs of erasing this gap in the near future.",
                "For maximum network life a sensor storage system should leverage the flash memory on sensors to archive data locally, substituting cheap memory operations for expensive radio transmission.",
                "But without efficient mechanisms for retrieval, the energy gains of local storage may be outweighed by communication costs incurred by the application in searching for data.",
                "We believe that if the data storage system provides the abstraction of a single logical store to applications, as 41 does TSAR, then it will have additional flexibility to optimize communication and storage costs. • Principle 2: Distinguish data from metadata: Data must be identified so that it may be retrieved by the application without exhaustive search.",
                "To do this, we associate metadata with each data record - data fields of known syntax which serve as identifiers and may be queried by the storage system.",
                "Examples of this metadata are data attributes such as location and time, or selected or summarized data values.",
                "We leverage the presence of resource-rich proxies to index metadata for resource-constrained sensors.",
                "The proxies share this metadata index to provide a unified logical view of all data in the system, thereby enabling efficient, low-latency lookups.",
                "Such a tier-specific separation of data storage from metadata indexing enables the system to exploit the idiosyncrasies of multi-tier networks, while improving performance and functionality. • Principle 3: Provide data-centric query support: In a sensor application the specific location (i.e. offset) of a record in a stream is unlikely to be of significance, except if it conveys information concerning the location and/or time at which the information was generated.",
                "We thus expect that applications will be best served by a query interface which allows them to locate data by value or attribute (e.g. location and time), rather than a read interface for unstructured data.",
                "This in turn implies the need to maintain metadata in the form of an index that provides low cost lookups. 2.4 System Design TSAR embodies these design principles by employing local storage at sensors and a distributed index at the proxies.",
                "The key features of the system design are as follows: In TSAR, writes occur at sensor nodes, and are assumed to consist of both opaque data as well as application-specific metadata.",
                "This metadata is a tuple of known types, which may be used by the application to locate and identify data records, and which may be searched on and compared by TSAR in the course of locating data for the application.",
                "In a camera-based sensing application, for instance, this metadata might include coordinates describing the field of view, average luminance, and motion values, in addition to basic information such as time and sensor location.",
                "Depending on the application, this metadata may be two or three orders of magnitude smaller than the data itself, for instance if the metadata consists of features extracted from image or acoustic data.",
                "In addition to storing data locally, each sensor periodically sends a summary of reported metadata to a nearby proxy.",
                "The summary contains information such as the sensor ID, the interval (t1, t2) over which the summary was generated, a handle identifying the corresponding data record (e.g. its location in flash memory), and a coarse-grain representation of the metadata associated with the record.",
                "The precise data representation used in the summary is application-specific; for instance, a temperature sensor might choose to report the maximum and minimum temperature values observed in an interval as a coarse-grain representation of the actual time series.",
                "The proxy uses the summary to construct an index; the index is global in that it stores information from all sensors in the system and it is distributed across the various proxies in the system.",
                "Thus, applications see a unified view of distributed data, and can query the index at any proxy to get access to data stored at any sensor.",
                "Specifically, each query triggers lookups in this distributed index and the list of matches is then used to retrieve the corresponding data from the sensors.",
                "There are several distributed index and lookup methods which might be used in this system; however, the index structure described in Section 3 is highly suited for the task.",
                "Since the index is constructed using a coarse-grain summary, instead of the actual data, index lookups will yield approximate matches.",
                "The TSAR summarization mechanism guarantees that index lookups will never yield false negatives - i.e. it will never miss summaries which include the value being searched for.",
                "However, index lookups may yield false positives, where a summary matches the query but when queried the remote sensor finds no matching value, wasting network resources.",
                "The more coarse-grained the summary, the lower the update overhead and the greater the fraction of false positives, while finer summaries incur update overhead while reducing query overhead due to false positives.",
                "Remote sensors may easily distinguish false positives from queries which result in search hits, and calculate the ratio between the two; based on this ratio, TSAR employs a novel adaptive technique that dynamically varies the granularity of sensor summaries to balance the metadata overhead and the overhead of false positives. 3.",
                "Data Structures At the proxy tier, TSAR employs a novel index structure called the Interval Skip Graph, which is an ordered, distributed data structure for finding all intervals that contain a particular point or range of values.",
                "Interval skip graphs combine Interval Trees [5], an interval-based binary search tree, with Skip Graphs [1], a ordered, distributed data structure for peer-to-peer systems [13].",
                "The resulting data structure has two properties that make it ideal for sensor networks.",
                "First, it has O(log n) search complexity for accessing the first interval that matches a particular value or range, and constant complexity for accessing each successive interval.",
                "Second, indexing of intervals rather than individual values makes the data structure ideal for indexing summaries over time or value.",
                "Such summary-based indexing is a more natural fit for energyconstrained sensor nodes, since transmitting summaries incurs less energy overhead than transmitting all sensor data.",
                "Definitions: We assume that there are Np proxies and Ns sensors in a two-tier sensor network.",
                "Each proxy is responsible for multiple sensor nodes, and no assumption is made about the number of sensors per proxy.",
                "Each sensor transmits interval summaries of data or events regularly to one or more proxies that it is associated with, where interval i is represented as [lowi, highi].",
                "These intervals can correspond to time or value ranges that are used for indexing sensor data.",
                "No assumption is made about the size of an interval or about the amount of overlap between intervals.",
                "Range queries on the intervals are posed by users to the network of proxies and sensors; each query q needs to determine all index values that overlap the interval [lowq, highq].",
                "The goal of the interval skip graph is to index all intervals such that the set that overlaps a query interval can be located efficiently.",
                "In the rest of this section, we describe the interval skip graph in greater detail. 3.1 Skip Graph Overview In order to inform the description of the Interval Skip Graph, we first provide a brief overview of the Skip Graph data structure; for a more extensive description the reader is referred to [1].",
                "Figure 2 shows a skip graph which indexes 8 keys; the keys may be seen along the bottom, and above each key are the pointers associated with that key.",
                "Each data element, consisting of a key and its associated pointers, may reside on a different node in the network, 42 7 9 13 17 21 25 311 level 0 level 1 level 2 key single skip graph element (each may be on different node) find(21) node-to-node messages Figure 2: Skip Graph of 8 Elements [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] 5 14 14 16 23 23 27 30 [low,high] max contains(13) match no match halt Figure 3: Interval Skip Graph [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30] [2,5] Node 1 Node 2 Node 3 level 2 level 1 level 0 Figure 4: Distributed Interval Skip Graph and pointers therefore identify both a remote node as well as a data element on that node.",
                "In this figure we may see the following properties of a skip graph: • Ordered index: The keys are members of an ordered data type, for instance integers.",
                "Lookups make use of ordered comparisons between the search key and existing index entries.",
                "In addition, the pointers at the lowest level point directly to the successor of each item in the index. • In-place indexing: Data elements remain on the nodes where they were inserted, and messages are sent between nodes to establish links between those elements and others in the index. • Log n height: There are log2 n pointers associated with each element, where n is the number of data elements indexed.",
                "Each pointer belongs to a level l in [0... log2 n − 1], and together with some other pointers at that level forms a chain of n/2l elements. • Probabilistic balance: Rather than relying on re-balancing operations which may be triggered at insert or delete, skip graphs implement a simple random balancing mechanism which maintains close to perfect balance on average, with an extremely low probability of significant imbalance. • Redundancy and resiliency: Each data element forms an independent search tree root, so searches may begin at any node in the network, eliminating hot spots at a single search root.",
                "In addition the index is resilient against node failure; data on the failed node will not be accessible, but remaining data elements will be accessible through search trees rooted on other nodes.",
                "In Figure 2 we see the process of searching for a particular value in a skip graph.",
                "The pointers reachable from a single data element form a binary tree: a pointer traversal at the highest level skips over n/2 elements, n/4 at the next level, and so on.",
                "Search consists of descending the tree from the highest level to level 0, at each level comparing the target key with the next element at that level and deciding whether or not to traverse.",
                "In the perfectly balanced case shown here there are log2 n levels of pointers, and search will traverse 0 or 1 pointers at each level.",
                "We assume that each data element resides on a different node, and measure search cost by the number messages sent (i.e. the number of pointers traversed); this will clearly be O(log n).",
                "Tree update proceeds from the bottom, as in a B-Tree, with the root(s) being promoted in level as the tree grows.",
                "In this way, for instance, the two chains at level 1 always contain n/2 entries each, and there is never a need to split chains as the structure grows.",
                "The update process then consists of choosing which of the 2l chains to insert an element into at each level l, and inserting it in the proper place in each chain.",
                "Maintaining a perfectly balanced skip graph as shown in Figure 2 would be quite complex; instead, the probabilistic balancing method introduced in Skip Lists [23] is used, which trades off a small amount of overhead in the expected case in return for simple update and deletion.",
                "The basis for this method is the observation that any element which belongs to a particular chain at level l can only belong to one of two chains at level l+1.",
                "To insert an element we ascend levels starting at 0, randomly choosing one of the two possible chains at each level, an stopping when we reach an empty chain.",
                "One means of implementation (e.g. as described in [1]) is to assign each element an arbitrarily long random bit string.",
                "Each chain at level l is then constructed from those elements whose bit strings match in the first l bits, thus creating 2l possible chains at each level and ensuring that each chain splits into exactly two chains at the next level.",
                "Although the resulting structure is not perfectly balanced, following the analysis in [23] we can show that the probability of it being significantly out of balance is extremely small; in addition, since the structure is determined by the random number stream, input data patterns cannot cause the tree to become imbalanced. 3.2 Interval Skip Graph A skip graph is designed to store single-valued entries.",
                "In this section, we introduce a novel data structure that extends skip graphs to store intervals [lowi, highi] and allows efficient searches for all intervals covering a value v, i.e. {i : lowi ≤ v ≤ highi}.",
                "Our data structure can be extended to range searches in a straightforward manner.",
                "The interval skip graph is constructed by applying the method of augmented search trees, as described by Cormen, Leiserson, and Rivest [5] and applied to binary search trees to create an Interval Tree.",
                "The method is based on the observation that a search structure based on comparison of ordered keys, such as a binary tree, may also be used to search on a secondary key which is non-decreasing in the first key.",
                "Given a set of intervals sorted by lower bound - lowi ≤ lowi+1 - we define the secondary key as the cumulative maximum, maxi = maxk=0...i (highk).",
                "The set of intervals intersecting a value v may then be found by searching for the first interval (and thus the interval with least lowi) such that maxi ≥ v. We then 43 traverse intervals in increasing order lower bound, until we find the first interval with lowi > v, selecting those intervals which intersect v. Using this approach we augment the skip graph data structure, as shown in Figure 3, so that each entry stores a range (lower bound and upper bound) and a secondary key (cumulative maximum of upper bound).",
                "To efficiently calculate the secondary key maxi for an entry i, we take the greatest of highi and the maximum values reported by each of is left-hand neighbors.",
                "To search for those intervals containing the value v, we first search for v on the secondary index, maxi, and locate the first entry with maxi ≥ v. (by the definition of maxi, for this data element maxi = highi.)",
                "If lowi > v, then this interval does not contain v, and no other intervals will, either, so we are done.",
                "Otherwise we traverse the index in increasing order of mini, returning matching intervals, until we reach an entry with mini > v and we are done.",
                "Searches for all intervals which overlap a query range, or which completely contain a query range, are straightforward extensions of this mechanism.",
                "Lookup Complexity: Lookup for the first interval that matches a given value is performed in a manner very similar to an interval tree.",
                "The complexity of search is O(log n).",
                "The number of intervals that match a range query can vary depending on the amount of overlap in the intervals being indexed, as well as the range specified in the query.",
                "Insert Complexity: In an interval tree or interval skip list, the maximum value for an entry need only be calculated over the subtree rooted at that entry, as this value will be examined only when searching within the subtree rooted at that entry.",
                "For a simple interval skip graph, however, this maximum value for an entry must be computed over all entries preceding it in the index, as searches may begin anywhere in the data structure, rather than at a distinguished root element.",
                "It may be easily seen that in the worse case the insertion of a single interval (one that covers all existing intervals in the index) will trigger the update of all entries in the index, for a worst-case insertion cost of O(n). 3.3 Sparse Interval Skip Graph The final extensions we propose take advantage of the difference between the number of items indexed in a skip graph and the number of systems on which these items are distributed.",
                "The cost in network messages of an operation may be reduced by arranging the data structure so that most structure traversals occur locally on a single node, and thus incur zero network cost.",
                "In addition, since both congestion and failure occur on a per-node basis, we may eliminate links without adverse consequences if those links only contribute to load distribution and/or resiliency within a single node.",
                "These two modifications allow us to achieve reductions in asymptotic complexity of both update and search.",
                "As may be in Section 3.2, insert and delete cost on an interval skip graph has a worst case complexity of O(n), compared to O(log n) for an interval tree.",
                "The main reason for the difference is that skip graphs have a full search structure rooted at each element, in order to distribute load and provide resilience to system failures in a distributed setting.",
                "However, in order to provide load distribution and failure resilience it is only necessary to provide a full search structure for each system.",
                "If as in TSAR the number of nodes (proxies) is much smaller than the number of data elements (data summaries indexed), then this will result in significant savings.",
                "Implementation: To construct a sparse interval skip graph, we ensure that there is a single distinguished element on each system, the root element for that system; all searches will start at one of these root elements.",
                "When adding a new element, rather than splitting lists at increasing levels l until the element is in a list with no others, we stop when we find that the element would be in a list containing no root elements, thus ensuring that the element is reachable from all root elements.",
                "An example of applying this optimization may be seen in Figure 5. (In practice, rather than designating existing data elements as roots, as shown, it may be preferable to insert null values at startup.)",
                "When using the technique of membership vectors as in [1], this may be done by broadcasting the membership vectors of each root element to all other systems, and stopping insertion of an element at level l when it does not share an l-bit prefix with any of the Np root elements.",
                "The expected number of roots sharing a log2Np-bit prefix is 1, giving an expected expected height for each element of log2Np +O(1).",
                "An alternate implementation, which distributes information concerning root elements at pointer establishment time, is omitted due to space constraints; this method eliminates the need for additional messages.",
                "Performance: In a (non-interval) sparse skip graph, since the expected height of an inserted element is now log2 Np + O(1), expected insertion complexity is O(log Np), rather than O(log n), where Np is the number of root elements and thus the number of separate systems in the network. (In the degenerate case of a single system we have a skip list; with splitting probability 0.5 the expected height of an individual element is 1.)",
                "Note that since searches are started at root elements of expected height log2 n, search complexity is not improved.",
                "For an interval sparse skip graph, update performance is improved considerably compared to the O(n) worst case for the nonsparse case.",
                "In an augmented search structure such as this, an element only stores information for nodes which may be reached from that element-e.g. the subtree rooted at that element, in the case of a tree.",
                "Thus, when updating the maximum value in an interval tree, the update is only propagated towards the root.",
                "In a sparse interval skip graph, updates to a node only propagate towards the Np root elements, for a worst-case cost of Np log2 n. Shortcut search: When beginning a search for a value v, rather than beginning at the root on that proxy, we can find the element that is closest to v (e.g. using a secondary local index), and then begin the search at that element.",
                "The expected distance between this element and the search terminus is log2 Np, and the search will now take on average log2 Np + O(1) steps.",
                "To illustrate this optimization, in Figure 4 depending on the choice of search root, a search for [21, 30] beginning at node 2 may take 3 network hops, traversing to node 1, then back to node 2, and finally to node 3 where the destination is located, for a cost of 3 messages.",
                "The shortcut search, however, locates the intermediate data element on node 2, and then proceeds directly to node 3 for a cost of 1 message.",
                "Performance: This technique may be applied to the primary key search which is the first of two insertion steps in an interval skip graph.",
                "By combining the short-cut optimization with sparse interval skip graphs, the expected cost of insertion is now O(log Np), independent of the size of the index or the degree of overlap of the inserted intervals. 3.4 Alternative Data Structures Thus far we have only compared the sparse interval skip graph with similar structures from which it is derived.",
                "A comparison with several other data structures which meet at least some of the requirements for the TSAR index is shown in Table 2. 44 Table 2: Comparison of Distributed Index Structures Range Query Support Interval Representation Re-balancing Resilience Small Networks Large Networks DHT, GHT no no no yes good good Local index, flood query yes yes no yes good bad P-tree, RP* (distributed B-Trees) yes possible yes no good good DIMS yes no yes yes yes yes Interval Skipgraph yes yes no yes good good [6,14] [9,12] [14,16] [15,23] [18,19] [20,27] [21,30][2,5] Roots Node 1 Node 2 Figure 5: Sparse Interval Skip Graph The hash-based systems, DHT [25] and GHT [26], lack the ability to perform range queries and are thus not well-suited to indexing spatio-temporal data.",
                "Indexing locally using an appropriate singlenode structure and then flooding queries to all proxies is a competitive alternative for small networks; for large networks the linear dependence on the number of proxies becomes an issue.",
                "Two distributed B-Trees were examined - P-Trees [6] and RP* [19].",
                "Each of these supports range queries, and in theory could be modified to support indexing of intervals; however, they both require complex re-balancing, and do not provide the resilience characteristics of the other structures.",
                "DIMS [18] provides the ability to perform spatio-temporal range queries, and has the necessary resilience to failures; however, it cannot be used index intervals, which are used by TSARs data summarization algorithm. 4.",
                "Data Storage and Summarization Having described the proxy-level index structure, we turn to the mechanisms at the sensor tier.",
                "TSAR implements two key mechanisms at the sensor tier.",
                "The first is a local archival store at each sensor node that is optimized for resource-constrained devices.",
                "The second is an adaptive summarization technique that enables each sensor to adapt to changing data and query characteristics.",
                "The rest of this section describes these mechanisms in detail. 4.1 Local Storage at Sensors Interval skip graphs provide an efficient mechanism to lookup sensor nodes containing data relevant to a query.",
                "These queries are then routed to the sensors, which locate the relevant data records in the local archive and respond back to the proxy.",
                "To enable such lookups, each sensor node in TSAR maintains an archival store of sensor data.",
                "While the implementation of such an archival store is straightforward on resource-rich devices that can run a database, sensors are often power and resource-constrained.",
                "Consequently, the sensor archiving subsystem in TSAR is explicitly designed to exploit characteristics of sensor data in a resource-constrained setting.",
                "Timestamp Calibration Parameters Opaque DataData/Event Attributes size Figure 6: Single storage record Sensor data has very distinct characteristics that inform our design of the TSAR archival store.",
                "Sensors produce time-series data streams, and therefore, temporal ordering of data is a natural and simple way of storing archived sensor data.",
                "In addition to simplicity, a temporally ordered store is often suitable for many sensor data processing tasks since they involve time-series data processing.",
                "Examples include signal processing operations such as FFT, wavelet transforms, clustering, similarity matching, and target detection.",
                "Consequently, the local archival store is a collection of records, designed as an append-only circular buffer, where new records are appended to the tail of the buffer.",
                "The format of each data record is shown in Figure 6.",
                "Each record has a metadata field which includes a timestamp, sensor settings, calibration parameters, etc.",
                "Raw sensor data is stored in the data field of the record.",
                "The data field is opaque and application-specific-the storage system does not know or care about interpreting this field.",
                "A camera-based sensor, for instance, may store binary images in this data field.",
                "In order to support a variety of applications, TSAR supports variable-length data fields; as a result, record sizes can vary from one record to another.",
                "Our archival store supports three operations on records: create, read, and delete.",
                "Due to the append-only nature of the store, creation of records is simple and efficient.",
                "The create operation simply creates a new record and appends it to the tail of the store.",
                "Since records are always written at the tail, the store need not maintain a free space list.",
                "All fields of the record need to be specified at creation time; thus, the size of the record is known a priori and the store simply allocates the the corresponding number of bytes at the tail to store the record.",
                "Since writes are immutable, the size of a record does not change once it is created. proxy proxy proxy record 3 record summary local archive in flash memory data summary start,end offset time interval sensor summary sent to proxy Insert summaries into interval skip graph Figure 7: Sensor Summarization 45 The read operation enables stored records to be retrieved in order to answer queries.",
                "In a traditional database system, efficient lookups are enabled by maintaining a structure such as a B-tree that indexes certain keys of the records.",
                "However, this can be quite complex for a small sensor node with limited resources.",
                "Consequently, TSAR sensors do not maintain any index for the data stored in their archive.",
                "Instead, they rely on the proxies to maintain this metadata index-sensors periodically send the proxy information summarizing the data contained in a contiguous sequence of records, as well as a handle indicating the location of these records in flash memory.",
                "The mechanism works as follows: In addition to the summary of sensor data, each node sends metadata to the proxy containing the time interval corresponding to the summary, as well as the start and end offsets of the flash memory location where the raw data corresponding is stored (as shown in Figure 7).",
                "Thus, random access is enabled at granularity of a summary-the start offset of each chunk of records represented by a summary is known to the proxy.",
                "Within this collection, records are accessed sequentially.",
                "When a query matches a summary in the index, the sensor uses these offsets to access the relevant records on its local flash by sequentially reading data from the start address until the end address.",
                "Any queryspecific operation can then be performed on this data.",
                "Thus, no index needs to be maintained at the sensor, in line with our goal of simplifying sensor state management.",
                "The state of the archive is captured in the metadata associated with the summaries, and is stored and maintained at the proxy.",
                "While we anticipate local storage capacity to be large, eventually there might be a need to overwrite older data, especially in high data rate applications.",
                "This may be done via techniques such as multi-resolution storage of data [9], or just simply by overwriting older data.",
                "When older data is overwritten, a delete operation is performed, where an index entry is deleted from the interval skip graph at the proxy and the corresponding storage space in flash memory at the sensor is freed. 4.2 Adaptive Summarization The data summaries serve as glue between the storage at the remote sensor and the index at the proxy.",
                "Each update from a sensor to the proxy includes three pieces of information: the summary, a time period corresponding to the summary, and the start and end offsets for the flash archive.",
                "In general, the proxy can index the time interval representing a summary or the value range reported in the summary (or both).",
                "The former index enables quick lookups on all records seen during a certain interval, while the latter index enables quick lookups on all records matching a certain value.",
                "As described in Section 2.4, there is a trade-off between the energy used in sending summaries (and thus the frequency and resolution of those summaries) and the cost of false hits during queries.",
                "The coarser and less frequent the summary information, the less energy required, while false query hits in turn waste energy on requests for non-existent data.",
                "TSAR employs an adaptive summarization technique that balances the cost of sending updates against the cost of false positives.",
                "The key intuition is that each sensor can independently identify the fraction of false hits and true hits for queries that access its local archive.",
                "If most queries result in true hits, then the sensor determines that the summary can be coarsened further to reduce update costs without adversely impacting the hit ratio.",
                "If many queries result in false hits, then the sensor makes the granularity of each summary finer to reduce the number and overhead of false hits.",
                "The resolution of the summary depends on two parametersthe interval over which summaries of the data are constructed and transmitted to the proxy, as well as the size of the applicationspecific summary.",
                "Our focus in this paper is on the interval over which the summary is constructed.",
                "Changing the size of the data summary can be performed in an application-specific manner (e.g. using wavelet compression techniques as in [9]) and is beyond the scope of this paper.",
                "Currently, TSAR employs a simple summarization scheme that computes the ratio of false and true hits and decreases (increases) the interval between summaries whenever this ratio increases (decreases) beyond a threshold. 5.",
                "TSAR Implementation We have implemented a prototype of TSAR on a multi-tier sensor network testbed.",
                "Our prototype employs Crossbow Stargate nodes to implement the proxy tier.",
                "Each Stargate node employs a 400MHz Intel XScale processor with 64MB RAM and runs the Linux 2.4.19 kernel and EmStar release 2.1.",
                "The proxy nodes are equipped with two wireless radios, a Cisco Aironet 340-based 802.11b radio and a hostmote bridge to the Mica2 sensor nodes using the EmStar transceiver.",
                "The 802.11b wireless network is used for inter-proxy communication within the proxy tier, while the wireless bridge enables sensor-proxy communication.",
                "The sensor tier consists of Crossbow Mica2s and Mica2dots, each consisting of a 915MHz CC1000 radio, a BMAC protocol stack, a 4 Mb on-board flash memory and an ATMega 128L processor.",
                "The sensor nodes run TinyOS 1.1.8.",
                "In addition to the on-board flash, the sensor nodes can be equipped with external MMC/SD flash cards using a custom connector.",
                "The proxy nodes can be equipped with external storage such as high-capacity compact flash (up to 4GB), 6GB micro-drives, or up to 60GB 1.8inch mobile disk drives.",
                "Since sensor nodes may be several hops away from the nearest proxy, the sensor tier employs multi-hop routing to communicate with the proxy tier.",
                "In addition, to reduce the power consumption of the radio while still making the sensor node available for queries, low power listening is enabled, in which the radio receiver is periodically powered up for a short interval to sense the channel for transmissions, and the packet preamble is extended to account for the latency until the next interval when the receiving radio wakes up.",
                "Our prototype employs the MultiHopLEPSM routing protocol with the BMAC layer configured in the low-power mode with a 11% duty cycle (one of the default BMAC [22] parameters) Our TSAR implementation on the Mote involves a data gathering task that periodically obtains sensor readings and logs these reading to flash memory.",
                "The flash memory is assumed to be a circular append-only store and the format of the logged data is depicted in Figure 6.",
                "The Mote sends a report to the proxy every N readings, summarizing the observed data.",
                "The report contains: (i) the address of the Mote, (ii) a handle that contains an offset and the length of the region in flash memory containing data referred to by the summary, (iii) an interval (t1, t2) over which this report is generated, (iv) a tuple (low, high) representing the minimum and the maximum values observed at the sensor in the interval, and (v) a sequence number.",
                "The sensor updates are used to construct a sparse interval skip graph that is distributed across proxies, via network messages between proxies over the 802.11b wireless network.",
                "Our current implementation supports queries that request records matching a time interval (t1, t2) or a value range (v1, v2).",
                "Spatial constraints are specified using sensor IDs.",
                "Given a list of matching intervals from the skip graph, TSAR supports two types of messages to query the sensor: lookup and fetch.",
                "A lookup message triggers a search within the corresponding region in flash memory and returns the number of matching records in that memory region (but does not retrieve data).",
                "In contrast, a fetch message not only 46 0 10 20 30 40 50 60 70 80 128512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (a) James Reserve Data 0 10 20 30 40 50 60 70 80 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (skipgraph) Insert (sparse skipgraph) Initial lookup (b) Synthetic Data Figure 8: Skip Graph Insert Performance triggers a search but also returns all matching data records to the proxy.",
                "Lookup messages are useful for polling a sensor, for instance, to determine if a query matches too many records. 6.",
                "Experimental Evaluation In this section, we evaluate the efficacy of TSAR using our prototype and simulations.",
                "The testbed for our experiments consists of four Stargate proxies and twelve Mica2 and Mica2dot sensors; three sensors each are assigned to each proxy.",
                "Given the limited size of our testbed, we employ simulations to evaluate the behavior of TSAR in larger settings.",
                "Our simulation employs the EmTOS emulator [10], which enables us to run the same code in simulation and the hardware platform.",
                "Rather than using live data from a real sensor, to ensure repeatable experiments, we seed each sensor node with a dataset (i.e., a trace) that dictates the values reported by that node to the proxy.",
                "One section of the flash memory on each sensor node is programmed with data points from the trace; these observations are then replayed during an experiment, logged to the local archive (located in flash memory, as well), and reported to the proxy.",
                "The first dataset used to evaluate TSAR is a temperature dataset from James Reserve [27] that includes data from eleven temperature sensor nodes over a period of 34 days.",
                "The second dataset is synthetically generated; the trace for each sensor is generated using a uniformly distributed random walk though the value space.",
                "Our experimental evaluation has four parts.",
                "First, we run EmTOS simulations to evaluate the lookup, update and delete overhead for sparse interval skip graphs using the real and synthetic datasets.",
                "Second, we provide summary results from micro-benchmarks of the storage component of TSAR, which include empirical characterization of the energy costs and latency of reads and writes for the flash memory chip as well as the whole mote platform, and comparisons to published numbers for other storage and communication technologies.",
                "These micro-benchmarks form the basis for our full-scale evaluation of TSAR on a testbed of four Stargate proxies and twelve Motes.",
                "We measure the end-to-end query latency in our multi-hop testbed as well as the query processing overhead at the mote tier.",
                "Finally, we demonstrate the adaptive summarization capability at each sensor node.",
                "The remainder of this section presents our experimental results. 6.1 Sparse Interval Skip Graph Performance This section evaluates the performance of sparse interval skip graphs by quantifying insert, lookup and delete overheads.",
                "We assume a proxy tier with 32 proxies and construct sparse interval skip graphs of various sizes using our datasets.",
                "For each skip 0 5 10 15 20 25 30 35 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (a) James Reserve Data 0 2 4 6 8 10 12 14 409620481024512 NumberofMessages Index size (entries) Initial lookup Traversal (b) Synthetic Data Figure 9: Skip Graph Lookup Performance 0 10 20 30 40 50 60 70 1 4 8 16 24 32 48 Numberofmessages Number of proxies Skipgraph insert Sparse skipgraph insert Initial lookup (a) Impact of Number of Proxies 0 20 40 60 80 100 120 512 1024 2048 4096 NumberofMessages Index size (entries) Insert (redundant) Insert (non-redundant) Lookup (redundant) Lookup (non-redundant) (b) Impact of Redundant Summaries Figure 10: Skip Graph Overheads graph, we evaluate the cost of inserting a new value into the index.",
                "Each entry was deleted after its insertion, enabling us to quantify the delete overhead as well.",
                "Figure 8(a) and (b) quantify the insert overhead for our two datasets: each insert entails an initial traversal that incurs log n messages, followed by neighbor pointer update at increasing levels, incurring a cost of 4 log n messages.",
                "Our results demonstrate this behavior, and show as well that performance of delete-which also involves an initial traversal followed by pointer updates at each level-incurs a similar cost.",
                "Next, we evaluate the lookup performance of the index structure.",
                "Again, we construct skip graphs of various sizes using our datasets and evaluate the cost of a lookup on the index structure.",
                "Figures 9(a) and (b) depict our results.",
                "There are two components for each lookup-the lookup of the first interval that matches the query and, in the case of overlapping intervals, the subsequent linear traversal to identify all matching intervals.",
                "The initial lookup can be seen to takes log n messages, as expected.",
                "The costs of the subsequent linear traversal, however, are highly data dependent.",
                "For instance, temperature values for the James Reserve data exhibit significant spatial correlations, resulting in significant overlap between different intervals and variable, high traversal cost (see Figure 9(a)).",
                "The synthetic data, however, has less overlap and incurs lower traversal overhead as shown in Figure 9(b).",
                "Since the previous experiments assumed 32 proxies, we evaluate the impact of the number of proxies on skip graph performance.",
                "We vary the number of proxies from 10 to 48 and distribute a skip graph with 4096 entries among these proxies.",
                "We construct regular interval skip graphs as well as sparse interval skip graphs using these entries and measure the overhead of inserts and lookups.",
                "Thus, the experiment also seeks to demonstrate the benefits of sparse skip graphs over regular skip graphs.",
                "Figure 10(a) depicts our results.",
                "In regular skip graphs, the complexity of insert is O(log2n) in the 47 expected case (and O(n) in the worst case) where n is the number of elements.",
                "This complexity is unaffected by changing the number of proxies, as indicated by the flat line in the figure.",
                "Sparse skip graphs require fewer pointer updates; however, their overhead is dependent on the number of proxies, and is O(log2Np) in the expected case, independent of n. This can be seen to result in significant reduction in overhead when the number of proxies is small, which decreases as the number of proxies increases.",
                "Failure handling is an important issue in a multi-tier sensor architecture since it relies on many components-proxies, sensor nodes and routing nodes can fail, and wireless links can fade.",
                "Handling of many of these failure modes is outside the scope of this paper; however, we consider the case of resilience of skip graphs to proxy failures.",
                "In this case, skip graph search (and subsequent repair operations) can follow any one of the other links from a root element.",
                "Since a sparse skip graph has search trees rooted at each node, searching can then resume once the lookup request has routed around the failure.",
                "Together, these two properties ensure that even if a proxy fails, the remaining entries in the skip graph will be reachable with high probability-only the entries on the failed proxy and the corresponding data at the sensors becomes inaccessible.",
                "To ensure that all data on sensors remains accessible, even in the event of failure of a proxy holding index entries for that data, we incorporate redundant index entries.",
                "TSAR employs a simple redundancy scheme where additional coarse-grain summaries are used to protect regular summaries.",
                "Each sensor sends summary data periodically to its local proxy, but less frequently sends a lowerresolution summary to a backup proxy-the backup summary represents all of the data represented by the finer-grained summaries, but in a lossier fashion, thus resulting in higher read overhead (due to false hits) if the backup summary is used.",
                "The cost of implementing this in our system is low - Figure 10(b) shows the overhead of such a redundancy scheme, where a single coarse summary is send to a backup for every two summaries sent to the primary proxy.",
                "Since a redundant summary is sent for every two summaries, the insert cost is 1.5 times the cost in the normal case.",
                "However, these redundant entries result in only a negligible increase in lookup overhead, due the logarithmic dependence of lookup cost on the index size, while providing full resilience to any single proxy failure. 6.2 Storage Microbenchmarks Since sensors are resource-constrained, the energy consumption and the latency at this tier are important measures for evaluating the performance of a storage architecture.",
                "Before performing an endto-end evaluation of our system, we provide more detailed information on the energy consumption of the storage component used to implement the TSAR local archive, based on empirical measurements.",
                "In addition we compare these figures to those for other local storage technologies, as well as to the energy consumption of wireless communication, using information from the literature.",
                "For empirical measurements we measure energy usage for the storage component itself (i.e. current drawn by the flash chip), as well as for the entire Mica2 mote.",
                "The power measurements in Table 3 were performed for the AT45DB041 [15] flash memory on a Mica2 mote, which is an older NOR flash device.",
                "The most promising technology for low-energy storage on sensing devices is NAND flash, such as the Samsung K9K4G08U0M device [16]; published power numbers for this device are provided in the table.",
                "Published energy requirements for wireless transmission using the Chipcon [4] CC2420 radio (used in MicaZ and Telos motes) are provided for comparison, assuming Energy Energy/byte Mote flash Read 256 byte page 58µJ* / 136µJ* total 0.23µJ* Write 256 byte page 926µJ* / 1042µJ* total 3.6µJ* NAND Flash Read 512 byte page 2.7µJ 1.8nJ Write 512 byte page 7.8µJ 15nJ Erase 16K byte sector 60µJ 3.7nJ CC2420 radio Transmit 8 bits (-25dBm) 0.8µJ 0.8µJ Receive 8 bits 1.9µJ 1.9µJ Mote AVR processor In-memory search, 256 bytes 1.8µJ 6.9nJ Table 3: Storage and Communication Energy Costs (*measured values) 0 200 400 600 800 1000 1 2 3 Latency(ms) Number of hops (a) Multi-hop query performance 0 100 200 300 400 500 1 5121024 2048 4096 Latency(ms) Index size (entries) Sensor communication Proxy communication Sensor lookup, processing (b) Query Performance Figure 11: Query Processing Latency zero network and protocol overhead.",
                "Comparing the total energy cost for writing flash (erase + write) to the total cost for communication (transmit + receive), we find that the NAND flash is almost 150 times more efficient than radio communication, even assuming perfect network protocols. 6.3 Prototype Evaluation This section reports results from an end-to-end evaluation of the TSAR prototype involving both tiers.",
                "In our setup, there are four proxies connected via 802.11 links and three sensors per proxy.",
                "The multi-hop topology was preconfigured such that sensor nodes were connected in a line to each proxy, forming a minimal tree of depth 0 400 800 1200 1600 0 20 40 60 80 100 120 140 160 Retrievallatency(ms) Archived data retrieved (bytes) (a) Data Query and Fetch Time 0 2 4 6 8 10 12 4 8 16 32 Latency(ms) Number of 34-byte records searched (b) Sensor query processing delay Figure 12: Query Latency Components 48 3.",
                "Due to resource constraints we were unable to perform experiments with dozens of sensor nodes, however this topology ensured that the network diameter was as large as for a typical network of significantly larger size.",
                "Our evaluation metric is the end-to-end latency of query processing.",
                "A query posed on TSAR first incurs the latency of a sparse skip graph lookup, followed by routing to the appropriate sensor node(s).",
                "The sensor node reads the required page(s) from its local archive, processes the query on the page that is read, and transmits the response to the proxy, which then forwards it to the user.",
                "We first measure query latency for different sensors in our multi-hop topology.",
                "Depending on which of the sensors is queried, the total latency increases almost linearly from about 400ms to 1 second, as the number of hops increases from 1 to 3 (see Figure 11(a)).",
                "Figure 11(b) provides a breakdown of the various components of the end-to-end latency.",
                "The dominant component of the total latency is the communication over one or more hops.",
                "The typical time to communicate over one hop is approximately 300ms.",
                "This large latency is primarily due to the use of a duty-cycled MAC layer; the latency will be larger if the duty cycle is reduced (e.g. the 2% setting as opposed to the 11.5% setting used in this experiment), and will conversely decrease if the duty cycle is increased.",
                "The figure also shows the latency for varying index sizes; as expected, the latency of inter-proxy communication and skip graph lookups increases logarithmically with index size.",
                "Not surprisingly, the overhead seen at the sensor is independent of the index size.",
                "The latency also depends on the number of packets transmitted in response to a query-the larger the amount of data retrieved by a query, the greater the latency.",
                "This result is shown in Figure 12(a).",
                "The step function is due to packetization in TinyOS; TinyOS sends one packet so long as the payload is smaller than 30 bytes and splits the response into multiple packets for larger payloads.",
                "As the data retrieved by a query is increased, the latency increases in steps, where each step denotes the overhead of an additional packet.",
                "Finally, Figure 12(b) shows the impact of searching and processing flash memory regions of increasing sizes on a sensor.",
                "Each summary represents a collection of records in flash memory, and all of these records need to be retrieved and processed if that summary matches a query.",
                "The coarser the summary, the larger the memory region that needs to be accessed.",
                "For the search sizes examined, amortization of overhead when searching multiple flash pages and archival records, as well as within the flash chip and its associated driver, results in the appearance of sub-linear increase in latency with search size.",
                "In addition, the operation can be seen to have very low latency, in part due to the simplicity of our query processing, requiring only a compare operation with each stored element.",
                "More complex operations, however, will of course incur greater latency. 6.4 Adaptive Summarization When data is summarized by the sensor before being reported to the proxy, information is lost.",
                "With the interval summarization method we are using, this information loss will never cause the proxy to believe that a sensor node does not hold a value which it in fact does, as all archived values will be contained within the interval reported.",
                "However, it does cause the proxy to believe that the sensor may hold values which it does not, and forward query messages to the sensor for these values.",
                "These false positives constitute the cost of the summarization mechanism, and need to be balanced against the savings achieved by reducing the number of reports.",
                "The goal of adaptive summarization is to dynamically vary the summary size so that these two costs are balanced. 0 0.1 0.2 0.3 0.4 0.5 0 5 10 15 20 25 30 Fractionoftruehits Summary size (number of records) (a) Impact of summary size 0 5 10 15 20 25 30 35 0 5000 10000 15000 20000 25000 30000 Summarizationsize(num.records) Normalized time (units) query rate 0.2 query rate 0.03 query rate 0.1 (b) Adaptation to query rate Figure 13: Impact of Summarization Granularity Figure 13(a) demonstrates the impact of summary granularity on false hits.",
                "As the number of records included in a summary is increased, the fraction of queries forwarded to the sensor which match data held on that sensor (true positives) decreases.",
                "Next, in Figure 13(b) we run the a EmTOS simulation with our adaptive summarization algorithm enabled.",
                "The adaptive algorithm increases the summary granularity (defined as the number of records per summary) when Cost(updates) Cost(falsehits) > 1 + and reduces it if Cost(updates) Cost(falsehits) > 1 − , where is a small constant.",
                "To demonstrate the adaptive nature of our technique, we plot a time series of the summarization granularity.",
                "We begin with a query rate of 1 query per 5 samples, decrease it to 1 every 30 samples, and then increase it again to 1 query every 10 samples.",
                "As shown in Figure 13(b), the adaptive technique adjusts accordingly by sending more fine-grain summaries at higher query rates (in response to the higher false hit rate), and fewer, coarse-grain summaries at lower query rates. 7.",
                "Related Work In this section, we review prior work on storage and indexing techniques for sensor networks.",
                "While our work addresses both problems jointly, much prior work has considered them in isolation.",
                "The problem of archival storage of sensor data has received limited attention in sensor network literature.",
                "ELF [7] is a logstructured file system for local storage on flash memory that provides load leveling and Matchbox is a simple file system that is packaged with the TinyOS distribution [14].",
                "Both these systems focus on local storage, whereas our focus is both on storage at the remote sensors as well as providing a unified view of distributed data across all such local archives.",
                "Multi-resolution storage [9] is intended for in-network storage and search in systems where there is significant data in comparison to storage resources.",
                "In contrast, TSAR addresses the problem of archival storage in two-tier systems where sufficient resources can be placed at the edge sensors.",
                "The RISE platform [21] being developed as part of the NODE project at UCR addresses the issues of hardware platform support for large amounts of storage in remote sensor nodes, but not the indexing and querying of this data.",
                "In order to efficiently access a distributed sensor store, an index needs to be constructed of the data.",
                "Early work on sensor networks such as Directed Diffusion [17] assumes a system where all useful sensor data was stored locally at each sensor, and spatially scoped queries are routed using geographic co-ordinates to locations where the data is stored.",
                "Sources publish the events that they detect, and sinks with interest in specific events can subscribe to these events.",
                "The Directed Diffusion substrate routes queries to specific locations 49 if the query has geographic information embedded in it (e.g. : find temperature in the south-west quadrant), and if not, the query is flooded throughout the network.",
                "These schemes had the drawback that for queries that are not geographically scoped, search cost (O(n) for a network of n nodes) may be prohibitive in large networks with frequent queries.",
                "Local storage with in-network indexing approaches address this issue by constructing indexes using frameworks such as Geographic Hash Tables [24] and Quad Trees [9].",
                "Recent research has seen a growing body of work on data indexing schemes for sensor networks[26][11][18].",
                "One such scheme is DCS [26], which provides a hash function for mapping from event name to location.",
                "DCS constructs a distributed structure that groups events together spatially by their named type.",
                "Distributed Index of Features in Sensornets (DIFS [11]) and Multi-dimensional Range Queries in Sensor Networks (DIM [18]) extend the data-centric storage approach to provide spatially distributed hierarchies of indexes to data.",
                "While these approaches advocate in-network indexing for sensor networks, we believe that indexing is a task that is far too complicated to be performed at the remote sensor nodes since it involves maintaining significant state and large tables.",
                "TSAR provides a better match between resource requirements of storage and indexing and the availability of resources at different tiers.",
                "Thus complex operations such as indexing and managing metadata are performed at the proxies, while storage at the sensor remains simple.",
                "In addition to storage and indexing techniques specific to sensor networks, many distributed, peer-to-peer and spatio-temporal index structures are relevant to our work.",
                "DHTs [25] can be used for indexing events based on their type, quad-tree variants such as Rtrees [12] can be used for optimizing spatial searches, and K-D trees [2] can be used for multi-attribute search.",
                "While this paper focuses on building an ordered index structure for range queries, we will explore the use of other index structures for alternate queries over sensor data. 8.",
                "Conclusions In this paper, we argued that existing sensor storage systems are designed primarily for flat hierarchies of homogeneous sensor nodes and do not fully exploit the multi-tier nature of emerging sensor networks.",
                "We presented the design of TSAR, a fundamentally different storage architecture that envisions separation of data from metadata by employing local storage at the sensors and distributed indexing at the proxies.",
                "At the proxy tier, TSAR employs a novel multi-resolution ordered distributed index structure, the Sparse Interval Skip Graph, for efficiently supporting spatio-temporal and range queries.",
                "At the sensor tier, TSAR supports energy-aware adaptive summarization that can trade-off the energy cost of transmitting metadata to the proxies against the overhead of false hits resulting from querying a coarser resolution index structure.",
                "We implemented TSAR in a two-tier sensor testbed comprising Stargatebased proxies and Mote-based sensors.",
                "Our experimental evaluation of TSAR demonstrated the benefits and feasibility of employing our energy-efficient low-latency distributed storage architecture in multi-tier sensor networks. 9.",
                "REFERENCES [1] James Aspnes and Gauri Shah.",
                "Skip graphs.",
                "In Fourteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pages 384-393, Baltimore, MD, USA, 12-14 January 2003. [2] Jon Louis Bentley.",
                "Multidimensional binary search trees used for associative searching.",
                "Commun.",
                "ACM, 18(9):509-517, 1975. [3] Philippe Bonnet, J. E. Gehrke, and Praveen Seshadri.",
                "Towards sensor database systems.",
                "In Proceedings of the Second International Conference on Mobile Data Management., January 2001. [4] Chipcon.",
                "CC2420 2.4 GHz IEEE 802.15.4 / ZigBee-ready RF transceiver, 2004. [5] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.",
                "Introduction to Algorithms.",
                "The MIT Press and McGraw-Hill, second edition edition, 2001. [6] Adina Crainiceanu, Prakash Linga, Johannes Gehrke, and Jayavel Shanmugasundaram.",
                "Querying Peer-to-Peer Networks Using P-Trees.",
                "Technical Report TR2004-1926, Cornell University, 2004. [7] Hui Dai, Michael Neufeld, and Richard Han.",
                "ELF: an efficient log-structured flash file system for micro sensor nodes.",
                "In SenSys 04: Proceedings of the 2nd international conference on Embedded networked sensor systems, pages 176-187, New York, NY, USA, 2004.",
                "ACM Press. [8] Peter Desnoyers, Deepak Ganesan, Huan Li, and Prashant Shenoy.",
                "PRESTO: A predictive storage architecture for sensor networks.",
                "In Tenth Workshop on Hot Topics in Operating Systems (HotOS X)., June 2005. [9] Deepak Ganesan, Ben Greenstein, Denis Perelyubskiy, Deborah Estrin, and John Heidemann.",
                "An evaluation of multi-resolution storage in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. [10] L. Girod, T. Stathopoulos, N. Ramanathan, J. Elson, D. Estrin, E. Osterweil, and T. Schoellhammer.",
                "A system for simulation, emulation, and deployment of heterogeneous sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems, Baltimore, MD, 2004. [11] B. Greenstein, D. Estrin, R. Govindan, S. Ratnasamy, and S. Shenker.",
                "DIFS: A distributed index for features in sensor networks.",
                "Elsevier Journal of ad-hoc Networks, 2003. [12] Antonin Guttman.",
                "R-trees: a dynamic index structure for spatial searching.",
                "In SIGMOD 84: Proceedings of the 1984 ACM SIGMOD international conference on Management of data, pages 47-57, New York, NY, USA, 1984.",
                "ACM Press. [13] Nicholas Harvey, Michael B. Jones, Stefan Saroiu, Marvin Theimer, and Alec Wolman.",
                "Skipnet: A scalable overlay network with practical locality properties.",
                "In In proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS 03), Seattle, WA, March 2003. [14] Jason Hill, Robert Szewczyk, Alec Woo, Seth Hollar, David Culler, and Kristofer Pister.",
                "System architecture directions for networked sensors.",
                "In Proceedings of the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX), pages 93-104, Cambridge, MA, USA, November 2000.",
                "ACM. [15] Atmel Inc. 4-megabit 2.5-volt or 2.7-volt DataFlash AT45DB041B, 2005. [16] Samsung Semiconductor Inc. K9W8G08U1M, K9K4G08U0M: 512M x 8 bit / 1G x 8 bit NAND flash memory, 2003. [17] Chalermek Intanagonwiwat, Ramesh Govindan, and Deborah Estrin.",
                "Directed diffusion: A scalable and robust communication paradigm for sensor networks.",
                "In Proceedings of the Sixth Annual International Conference on Mobile Computing and Networking, pages 56-67, Boston, MA, August 2000.",
                "ACM Press. [18] Xin Li, Young-Jin Kim, Ramesh Govindan, and Wei Hong.",
                "Multi-dimensional range queries in sensor networks.",
                "In Proceedings of the First ACM Conference on Embedded Networked Sensor Systems (SenSys)., 2003. to appear. [19] Witold Litwin, Marie-Anne Neimat, and Donovan A. Schneider.",
                "RP*: A family of order preserving scalable distributed data structures.",
                "In VLDB 94: Proceedings of the 20th International Conference on Very Large Data Bases, pages 342-353, San Francisco, CA, USA, 1994. [20] Samuel Madden, Michael Franklin, Joseph Hellerstein, and Wei Hong.",
                "TAG: a tiny aggregation service for ad-hoc sensor networks.",
                "In OSDI, Boston, MA, 2002. [21] A. Mitra, A. Banerjee, W. Najjar, D. Zeinalipour-Yazti, D.Gunopulos, and V. Kalogeraki.",
                "High performance, low power sensor platforms featuring gigabyte scale storage.",
                "In SenMetrics 2005: Third International Workshop on Measurement, Modeling, and Performance Analysis of Wireless Sensor Networks, July 2005. [22] J. Polastre, J. Hill, and D. Culler.",
                "Versatile low power media access for wireless sensor networks.",
                "In Proceedings of the Second ACM Conference on Embedded Networked Sensor Systems (SenSys), November 2004. [23] William Pugh.",
                "Skip lists: a probabilistic alternative to balanced trees.",
                "Commun.",
                "ACM, 33(6):668-676, 1990. [24] S. Ratnasamy, D. Estrin, R. Govindan, B. Karp, L. Yin S. Shenker, and F. Yu.",
                "Data-centric storage in sensornets.",
                "In ACM First Workshop on Hot Topics in Networks, 2001. [25] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker.",
                "A scalable content addressable network.",
                "In Proceedings of the 2001 ACM SIGCOMM Conference, 2001. [26] S. Ratnasamy, B. Karp, L. Yin, F. Yu, D. Estrin, R. Govindan, and S. Shenker.",
                "GHT - a geographic hash-table for data-centric storage.",
                "In First ACM International Workshop on Wireless Sensor Networks and their Applications, 2002. [27] N. Xu, E. Osterweil, M. Hamilton, and D. Estrin. http://www.lecs.cs.ucla.edu/˜nxu/ess/.",
                "James Reserve Data. 50"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        }
    }
}