{
    "id": "J-13",
    "original_text": "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices. While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs). Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph. Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness. In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem. In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3. Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions. We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here. Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width. Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph. Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1. INTRODUCTION Combinatorial auctions. Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items. This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items. This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18]. Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I. Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I. An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j. The winner determination problem. A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes. This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19]. Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]). In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions. Item graphs. Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph. Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16]. To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}. A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B . Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge. Example 1. The hypergraph H I0,B0 reported in Figure 1.(a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3. The primal graph for H I0,B0 is reported in Figure 1.(b), while two example item graphs are reported in Figure 1.(c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently. The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined. However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently. Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so. Weighted Set Packing. Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]). Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅. Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0. Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi). Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B . Example 2. Consider again the hypergraph H I0,B0 reported in Figure 1.(a). An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1. By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ). Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable. Towards this aim, we first study structured item graphs and solve the open problem in [3]. The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3. More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete. In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem. Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs). Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most. For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP. Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm. Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]). Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs. To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs. In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach. Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition. The proof of the above results give us some interesting insight into the notion of structured item graph. Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions. A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions. The rest of the paper is organized as follows. Section 2 discusses the intractability of structured item graphs. Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable. The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4. Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2. COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph. A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected. An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below. A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|. The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions. The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3]. Theorem 1 (cf. [3]). Assume a k-width tree decomposition T, χ of an item graph for H is given. Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ). Many item graphs can be associated with a hypergraph. As an example, observe that the item graph in Figure 1.(c) has treewidth 1, while Figure 1.(d) reports an item graph whose treewidth is 2. Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed. Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize. Theorem 2. Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard. The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E). To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 . The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution. First, we discuss the way HG is constructed. See Figure 2.(a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. From G to HG. Let G = (N, E) be a directed graph. Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y. No other node is in N(HG). Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}. Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes. As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2.(a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind. In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below. Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}. Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v). Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG. Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2). Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4). The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4). In the following lemma, we positively answer this question and refer the reader to its proof for an example construction. Lemma 1. A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ). Key Ingredients. We are now in the position of presenting an overview of the key ingredients of the proof. Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least). There are three basic observations serving the purpose of proving the correctness of the reduction. Blocks of TD: First, we observe that TD must contain some special kinds of vertex. Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}. And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }. Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2). Each of these vertices plays a specific role in the reduction. Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y. Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x. As an example, Figure 2.(b) reports the skeleton of a tree decomposition TD. The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2.(a) - other blocks in it (of the form w(x,y)) are defined next. Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG. The arguments for the proof are as follows. First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}. Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))). Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}). Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty). When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG. In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x). To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path. In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y). As an example, in Figure 2.(b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path. Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD. E.g., Figure 2.(a) shows w(x,t), which is not used in TD, and Figure 2.(b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3. TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances. To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems. A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H). If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v). We denote the set of vertices N of T by vertices(T). Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1. A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p). The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|. The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions. A hypergraph H is acyclic if hw(H) = 1. P Example 3. The hypergraph H I0,B0 reported in Figure 1.(a) is an example acyclic hypergraph. Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3.(a) and Figure 3.(b), respectively, are not acyclic since their hypertree width is 2. A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c). In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H). As an example, the reader may want to check again the hypergraph H1 in Figure 3.(a) and notice that the hypergraph in Figure 3.(b) is in fact its dual. The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios. Theorem 3. On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4. The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H. For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v). In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv. Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H). Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next. Let hv and hc be two packings for Hv and Hc, respectively. We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv. Example 4. Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c). Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end. Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a). For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }. Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc. For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases. In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp. For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated. Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv). Indeed, if v is a leaf, then v hv = w(hv). Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily). The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c. In the second phase, the tree T is processed starting from the root. Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr. Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5. Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1. Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5.(b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c. Specifically, the choices made during the computation are such that the packing {h2, h3} is computed. In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0. For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1. Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree. Equivalently, the algorithm may have chosen {h5}. As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c). Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4. Let H be a hypergraph and w be a weighting function for it. Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H. Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ). Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅. Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation. By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2. In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2. Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v). Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase. Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv. Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition. Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw. This holds in particular for w = v1. Contradiction with the definition of v1. Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv). Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved. As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most. Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv . These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times. Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c. The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved. Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7]. Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem. As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable. Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation). Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9]. The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL. Theorem 5. Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it. Then, MaxWSP(H, w) is in LLOGCFL . 4. HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality). Surprisingly, we establish this is not the case. The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict. Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H). X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ). A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1]. A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y . A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ). For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}. Definition 2. A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t. Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions. P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem. Theorem 6. Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H). Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 . Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H). In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0. Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k). By definition, strict hypertree decompositions are special hypertree decompositions. In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power. Theorem 7. C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). A Game Theoretic View. We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width. The game is played on a hypergraph H by a robber against k marshals which act in coordination. Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked. Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges. Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not. The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is. Otherwise, the robber wins. Theorem 8. Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H). Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5. CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario. The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3. Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width. For some special, yet relevant cases, a highly parallelizable algorithm is also discussed. Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality). In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]). In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature. As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k . Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem. For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold. Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award. In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford. In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6. REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe. Hypertree-Width and Related Hypergraph Invariants. In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier. Solving Concisely Expressed Combinatorial Auction Problems. In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm. Combinatorial auctions with structured item graphs. In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad. An o(n2 ) algorithm for circular-arc graph recognition. In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham. Taming the computational complexity of combinatorial auctions: Optimal and approximate. In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello. Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width. Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello. Hypertree decompositions and tractable queries. Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier. Solving combinatorial auctions using stochastic local search. In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson. A Catalog of Complexity Classes. In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring. An incremental linear-time algorithm for recognizing interval graphs. SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm. The Winner Determination Problem. In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions. MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham. Truth revelation in approximately efficient 160 combinatorial auctions. J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan. Analyzing the airwaves auction. Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan. Selling spectrum rights. Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan. Bidding and allocation in combinatorial auctions. In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour. Graph minors ii. algorithmic aspects of tree width. Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad. Computationally manageable combinatorial auctions. Management Science, 44:1131-1147, 1998. [18] T. Sandholm. An implementation of the contract net protocol based on marginal cost calculations. In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm. Algorithm for optimal winner determination in combinatorial auctions. Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm. Winner determination algorithms. In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions. MIT Press, 2006. [21] T. Sandholm and S. Suri. Bob: Improved winner determination in combinatorial auctions and generalizations. Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz. Some tractable combinatorial auctions. In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan. An efficient approximate allocation algorithm for combinatorial auctions. In Proc. of EC01, pages 125-136, 2001. 161",
    "original_translation": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. Los algoritmos de tiempo polinómico para encontrar la mejor simplificación del grafo primal solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo. Empaquetamiento de conjuntos ponderado. Cabe destacar que la representación de hipergrafo H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en hipergrafos (por ejemplo, [17]). Formalmente, un empaquetamiento h para un hipergrafo H es un conjunto de hiperarcos de H tal que para cada par h, h ∈ h con h ≠ h, se cumple que h ∩ h = ∅. Si se deja que w sea una función de ponderación para H, es decir, una función computable en tiempo polinómico de E(H) a números racionales, el peso de un empaquetado h es el número racional w(h) = h∈h w(h), donde w({}) = 0. Entonces, el problema de empaquetamiento de conjuntos con peso máximo para H con respecto a w, denotado por MaxWSP(H, w), es el problema de encontrar un empaquetamiento para H que tenga el peso máximo entre todos los empaquetamientos para H. Para ver que MaxWSP es simplemente una formulación diferente para el problema de determinación del ganador, dado una subasta combinatoria I, B, es suficiente definir la función de ponderación w I,B (elemento(Bi)) = pago(Bi). Entonces, el conjunto de soluciones para el problema de empaquetamiento de conjuntos ponderados para H I,B con respecto a w I,B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, B. Ejemplo 2. Considera nuevamente el hipercubo H I0,B0 reportado en la Figura 1.(a). Un ejemplo de empaquetado para H I0, B0 es h = {h1}, que intuitivamente corresponde a un resultado para I0, B0, donde el subastador aceptó la oferta B1. Al asumir que las ofertas B1, B2 y B3 son tales que pay(B1) = pay(B2) = pay(B3), el empaquetado h no es una solución para el problema MaxWSP(H I0,B0 , w I0,B0). De hecho, el empaque h∗ = {h2, h3} es tal que w I0,B0 (h∗ ) > w I0,B0 (h). ¡Contribuciones! El objetivo principal de este artículo es identificar clases grandes y manejables para el problema de determinación del ganador, que además sean reconocibles de forma polinómica. Con este objetivo, primero estudiamos grafos de elementos estructurados y resolvemos el problema abierto en [3]. El resultado es una noticia muy mala: es NP completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado de ancho de árbol 3. De manera más formal, dejando que C(ig, k) denote la clase de todos los hipergrafos que tienen un árbol de ítems con un ancho de árbol limitado por k, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C(ig, 3) es NP-completo. A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que puedan ser verificados en tiempo polinómico y que aún puedan ser utilizados para aislar clases tratables del problema de empaquetamiento de conjuntos con peso máximo o, equivalentemente, el problema de determinación del ganador. Nuestras investigaciones, esta vez, llevaron a noticias muy buenas que se resumen a continuación: Para un hipercubo H, su dual ¯H = (V, E) es tal que los nodos en V están en correspondencia uno a uno con los hiperarcos en H, y para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} está en E. Mostramos que MaxWSP es tratable en la clase de aquellas instancias cuyos hipercubos duales tienen un ancho de hiperárbol[7] limitado por k (abreviado: clase C(hw, k) de hipercubos). Cabe destacar que un problema clave de la tratabilidad es considerar el ancho de hiperárbol del hipergrafo dual ¯H en lugar del hipergrafo de subastas H. De hecho, podemos demostrar que MaxWSP sigue siendo NP-duro incluso cuando H es acíclico (es decir, cuando tiene un ancho de hiperárbol de 1), incluso cuando cada nodo está contenido en un máximo de 3 hiperarcos. Para algunas clases especiales relevantes de hipergrafos en C(hw, k), diseñamos un algoritmo altamente paralelizable para MaxWSP. Específicamente, si las funciones de ponderación se pueden calcular en espacio logarítmico y los pesos son polinomiales (por ejemplo, cuando todos los hiperarcos tienen pesos unitarios y se está interesado en encontrar el empaquetamiento con el máximo número de arcos), demostramos que MaxWSP puede resolverse mediante un algoritmo LOGCFL. Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son reducibles en espacio logarítmico a lenguajes libres de contexto, y que LOGCFL ⊆ NC2 ⊆ P (ver, por ejemplo, [9]). Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la descomposición de hipertree de los hipergrafos duales en lugar de la treewidth de los grafos de elementos. Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados. De hecho, demostramos que clases de instancias estrictamente más grandes son tratables según nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados. De manera intuitiva, la NP-dificultad de reconocer grafos de elementos estructurados de ancho acotado no se debe a su gran generalidad, sino más bien a algunas peculiaridades en su definición. La prueba de los resultados anteriores nos brinda una perspectiva interesante sobre la noción de grafo de elementos estructurados. De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos descomposiciones de hiperárboles estrictas. También se propone una caracterización de juego para la noción de ancho de hiperárbol estricto, que se especializa en el juego de Ladrón y Policías en [6] (propuesto para caracterizar el ancho de hiperárbol), y que aclara los requisitos adicionales sobre las descomposiciones de hiperárboles. El resto del documento está organizado de la siguiente manera. La sección 2 discute la intratabilidad de los grafos de elementos estructurados. La sección 3 presenta el algoritmo de tiempo polinómico para resolver MaxWSP en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hipertree acotado, y discute los casos en los que el algoritmo también es altamente paralelizable. La comparación entre las clases C(ig, k) y C(hw, k) se discute en la Sección 4. Finalmente, en la Sección 5 sacamos nuestras conclusiones también delineando las direcciones para futuras investigaciones. 2. COMPLEJIDAD DE LOS GRAFOS DE ELEMENTOS ESTRUCTURADOS Sea H un hipergrafo. Un grafo G = (V, E) es un grafo de elementos para H si V = N(H) y, para cada h ∈ E(H), el subgrafo de G inducido sobre los nodos en h está conectado. Una clase importante de grafos de elementos es la de grafos de elementos estructurados, es decir, aquellos grafos de elementos que tienen un ancho de árbol acotado como se formaliza a continuación. Una descomposición de árbol [16] de un grafo G = (V, E) es un par T, χ, donde T = (N, F) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjunto de vértices χ(p) ⊆ V, de modo que se satisfacen las siguientes condiciones: (1) para cada vértice b de G, existe un p ∈ N tal que b ∈ χ(p); (2) para cada arista {b, d} ∈ E, existe un p ∈ N tal que {b, d} ⊆ χ(p); (3) para cada vértice b de G, el conjunto {p ∈ N | b ∈ χ(p)} induce un subárbol conectado de T. El ancho de T, χ es el número maxp∈N |χ(p) − 1|. El treewidth de G, denotado por tw(G), es el ancho mínimo sobre todas sus descomposiciones en árboles. El problema de determinación del ganador puede resolverse en tiempo polinómico en grafos de elementos con treewidth acotado [3]. Teorema 1 (cf. [3]). Se tiene una descomposición en árbol de ancho k T, χ de un grafo de elementos para H. Entonces, MaxWSP(H, w) se puede resolver en tiempo O(|T|2 ×(|E(H)|+1)k+1 ). Muchos gráficos de elementos pueden estar asociados con un hipergráfico. Como ejemplo, observe que el grafo de elementos en la Figura 1. (c) tiene un ancho de árbol de 1, mientras que la Figura 1. (d) muestra un grafo de elementos cuyo ancho de árbol es 2. De hecho, era una pregunta abierta si, para una constante k dada, se puede verificar en tiempo polinómico si existe un grafo de ítems de ancho de árbol k, y en caso afirmativo, si dicho grafo de ítems se puede calcular eficientemente. La principal tarea de esta sección es demostrar que la clase C(ig, k) es difícil de reconocer. Teorema 2. Decidir si un hipergrafo H pertenece a C(ig, 3) es NP-difícil. La prueba de este resultado se basa en una reducción elaborada del problema de camino hamiltoniano HP(s, t) que consiste en decidir si hay un camino hamiltoniano desde un nodo s hasta un nodo t en un grafo dirigido G = (N, E). Para ayudar a la intuición, aquí presentamos una descripción general de alto nivel de los principales ingredientes utilizados en la prueba. La idea general es construir un hipercubo HG de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución. Primero, discutimos la forma en que se construye HG. Ver la Figura 2. (a) para una ilustración, donde el grafo G consiste en los nodos s, x, y, y t, y el conjunto de sus aristas es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. De G a HG. Sea G = (N, E) un grafo dirigido. Entonces, el conjunto de nodos en HG es tal que: para cada x ∈ N, N(HG) contiene los nodos bsx, btx, bx, bx, bdx; para cada e = (x, y) ∈ E, N(HG) contiene los nodos nsx, nsx, nty, nty, nsex y ntey. Ningún otro nodo está en N(HG). Los hiperarcos en HG son de tres tipos: 1) para cada x ∈ N, E(HG) contiene los hiperarcos: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, y A3 x = {bx, bx} -nota que estos hiperarcos inducen una clique en los nodos {bx, bx, bdx}; 1 Las pruebas detalladas se pueden encontrar en el Apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf. Figura 2: Prueba del Teorema 2: (a) de G a HG - solo se reportan los hiperarcos en 1) y 2); (b) un esqueleto para una descomposición en árbol TD para HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, y TA3 x = {btx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {btx, bx, bx, bdx}; 2) para cada e = (x, y) ∈ E, E(HG) contiene los hiperarcos: • SHx = {nsx, nsx}; • THy = {nty, nty}; • SEe = {nsx, nse x} y SEe = {nsx, nse x} -nota que estos dos hiperarcos más SHx inducen una clique en los nodos {nsx, nsx, nse x}; • TEe = {nty, nte y} y TEe = {nty, nte y} -nota que estos dos hiperarcos más THy inducen una clique en los nodos {nty, nty, nte y}. Observa que cada uno de los hiperarcos anteriores, excepto aquellos de la forma Sx y Tx, contiene exactamente dos nodos. Como ejemplo de los hiperarcos de tipo 1) y 2), el lector puede referirse a la construcción de ejemplo reportada en la Figura 2. (a), y notar, por ejemplo, que Sx = {bsx, nse2 x, nse3 x} y que Tt = {btt, nte4 t, nte3 t}. 3) finalmente, denotamos por DG al conjunto que contiene los hiperarcos en E(HG) del tercer tipo. En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperarcos que satisfacen las cuatro condiciones que se discuten a continuación. Sea PG el conjunto de los siguientes |PG| ≤ |N| + 3 × |E| pares: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}. Además, sea I(v) el conjunto {h ∈ E(H) | v ∈ h} de los hiperarcos de H que son tocados por v; y, para un conjunto V ⊆ N(H), sea I(V) = v∈V I(v). Entonces, DG tiene que ser un conjunto tal que: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ PG o (β, α) ∈ PG, se cumple: I(α) ∩ DG = ∅; y, (c4) ∀S ⊆ N tal que |S| ≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ PG, se cumple que: I(S) ⊇ DG. De manera intuitiva, el conjunto DG es tal que cada una de sus hiperaristas es tocada exactamente por uno de los dos nodos en cada par de PG, cf. (c1) y (c2). Además, los hiperarcos en DG solo tocan vértices incluidos en al menos un par de PG - cf. (c3); y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se pueden construir a partir de él pertenece a PG - cf. (c4). El lector puede preguntarse ahora si existe un conjunto DG que satisfaga (c1), (c2), (c3) y (c4). En el siguiente lema, respondemos positivamente a esta pregunta y referimos al lector a su demostración para un ejemplo de construcción. Lema 1. Un conjunto DG, con |DG| = 2 × |PG| + 2, que cumple las condiciones (c1), (c2), (c3) y (c4) se puede construir en tiempo O(|PG|2). Ingredientes clave. Ahora estamos en la posición de presentar una visión general de los ingredientes clave de la prueba. Sea G un grafo de elementos arbitrario para HG, y sea TD = T, χ una descomposición de árbol de ancho 3 de G (nota que, debido a las cliques, por ejemplo, en los nodos {bsx, bx, bx, bdx}, cualquier grafo de elementos para HG tiene un ancho de árbol de al menos 3). Hay tres observaciones básicas que sirven para demostrar la corrección de la reducción. Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértices. Específicamente, para cada nodo x ∈ N, TD contiene un vértice bs(x) tal que χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, y un vértice bt(x) tal que χ(bt(x)) ⊇ {btx, bx, bx, bdx}. Y, para cada arista e = (x, y) ∈ E, TD contiene un vértice ns(x,e) tal que χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, y un vértice nt(y,e) tal que χ(nt(y,e)) ⊇ {nte y, nty, nty}. Intuitivamente, se requiere que estos vértices cubran los cliques de HG asociados con los hiperarcos de tipo 1) y 2). Cada uno de estos vértices desempeña un papel específico en la reducción. De hecho, cada arista dirigida e = (x, y) ∈ E está codificada en TD mediante los vértices: ns(x,e), que representan precisamente que e comienza en x; y nt(y,e), que representan precisamente que e termina en y. Además, cada nodo x ∈ N está codificado en TD mediante los vértices: bs(x), que representa el punto de inicio de las aristas que se originan en x; y, bt(x), que representa el punto de terminación de las aristas que terminan en x. Como ejemplo, la Figura 2. (b) muestra el esqueleto de una descomposición de árbol TD. El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el hipercubo HG en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación. La conexión entre bloques y la unicidad de las conexiones: La segunda observación crucial es que en el camino que conecta un vértice de la forma bs(x) (resp., bt(y)) con un vértice de la forma ns(x,e) (resp., nt(y,e)) hay un vértice especial de la forma w(x,y) tal que: χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E. Garantizar la existencia de un vértice así es precisamente el papel que desempeñan los hiperarcos en DG. Los argumentos para la prueba son los siguientes. Primero, observamos que I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} e I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}. Luego, mostramos una propiedad que establece que para un par de vértices consecutivos p y q en el camino que conecta bs(x) y ns(x,e) (resp., bt(y) y nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))). Por lo tanto, tenemos: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (o bien, I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}). Basándose en esta observación, y al explotar las propiedades de los hiperarcos en DG, no es difícil demostrar que cualquier par de vértices consecutivos p y q deben compartir dos nodos de HG formando un par en PG, y ambos deben tocar Sx (resp., Ty). Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w(x,y), en este camino es tal que χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E - para ello, note que nse x ∈ Sx, nte t ∈ Ty, e I(χ(w(x,y))) ⊇ DG. En particular, w(x,y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay otro vértice de la forma w(x,z), para z = y (o bien, w(z,y), para z = x). Para ayudar a la intuición, observamos que tener un vértice de la forma w(x,y) en TD corresponde a la selección de un borde desde el nodo x hasta el nodo y en el camino hamiltoniano. De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de un camino hamiltoniano para G y los vértices de la forma w(x,y). Como ejemplo, en la Figura 2. (b), los vértices de la forma w(s,x), w(x,y) y w(y,t) están en TD, y GT D muestra el camino hamiltoniano correspondiente. Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w(x, y), para una arista e = (x, y) ∈ E no está en TD (es decir, si la arista (x, y) no pertenece al camino hamiltoniano), entonces el bloque correspondiente ns(x, e) (resp., nt(y, e)) puede ser agregado arbitrariamente en el subárbol enraizado en el bloque ns(x, e) (resp., nt(y, e)), donde e es la arista de la forma e = (x, z) (resp., e = (z, y)) tal que w(x, z) (resp., w(z, y)) está en TD. Por ejemplo, la Figura 2. (a) muestra w(x,t), que no se utiliza en TD, y la Figura 2. (b) muestra cómo los bloques ns(x,e3) y nt(t,e3) pueden ser dispuestos en TD para garantizar la condición de conectividad. CASOS TRACTABLES MEDIANTE DESCOMPOSICIONES DE HIPERÁRBOLES Dado que construir grafos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden ser utilizadas para identificar clases de instancias de MaxWSP tratables. Con este fin, nos enfocamos en la noción de descomposición de hiperárboles [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros. Un hypertree para un hipercubo H es un triple T, χ, λ, donde T = (N, E) es un árbol raíz, y χ y λ son funciones de etiquetado que asocian a cada vértice p ∈ N con dos conjuntos χ(p) ⊆ N(H) y λ(p) ⊆ E(H). Si T = (N, E) es un subárbol de T, definimos χ(T) = v∈N χ(v). Denotamos el conjunto de vértices N de T como vertices(T). Además, para cualquier p ∈ N, Tp denota el subárbol de T con raíz en p. Definición 1. Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p). El ancho de una descomposición de hipertree T, χ, λ es maxp∈vertices(T )|λ(p)|. El ancho de HYPERTREE hw(H) de H es el ancho mínimo sobre todas sus descomposiciones hypertree. Un hipergrafo H es acíclico si hw(H) = 1. Ejemplo 3. El hipergrafo H I0,B0 reportado en la Figura 1. (a) es un ejemplo de hipergrafo acíclico. En cambio, tanto los hipergráficos H1 y ¯H1 mostrados en la Figura 3. (a) y la Figura 3. (b), respectivamente, no son acíclicos ya que su anchura de hipertiempo es 2. Se reporta una descomposición de hipertree de ancho 2 para ¯H1 en la Figura 3.(c). En particular, observe que H1 se ha obtenido agregando los dos hiperarcos h4 y h5 a H I0,B0 para modelar, por ejemplo, que dos nuevas ofertas, B4 y B5, respectivamente, han sido propuestas al subastador. En lo siguiente, en lugar de trabajar en el hipercampo H asociado con un problema de MaxWSP, trataremos con su dual ¯H, es decir, con el hipercampo tal que sus nodos están en correspondencia uno a uno con los hiperarcos de H, y donde para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} está en E( ¯H). Como ejemplo, el lector puede querer revisar nuevamente el hipercubo H1 en la Figura 3 (a) y notar que el hipercubo en la Figura 3 (b) es de hecho su dual. La razón de esta elección es que imponer restricciones en el hipercubo original garantiza la tratabilidad solo en escenarios muy simples. Teorema 3. En la clase de hipergrafos acíclicos, MaxWSP está (1) en P si cada nodo ocurre en un máximo de dos hiperarcos; y, (2) NP-duro, incluso si cada nodo está contenido en un máximo de tres hiperarcos. 3.1 Descomposición de hiperárboles en el hipergrafo dual y problemas de empaquetamiento tratables Para una constante fija k, sea C(hw, k) la clase de todos los hipergrafos cuyos hipergrafos duales tienen un ancho de hiperárbol limitado por k. El problema de empaquetamiento de conjuntos con peso máximo se puede resolver en tiempo polinómico en la clase C(hw, k) mediante el algoritmo ComputeSetPackingk, mostrado en la Figura 4. El algoritmo recibe como entrada un hipercubo H, una función de ponderación w, y una descomposición de hipertree de ancho k HD = T=(N, E), χ, λ de ¯H. Para cada vértice v ∈ N, sea Hv el hipergrafo cuyo conjunto de nodos N(Hv) ⊆ N(H) coincide con λ(v), y cuyo conjunto de aristas E(Hv) ⊆ E(H) coincide con χ(v). En un paso de inicialización, el algoritmo equipa a cada vértice v con todos los empaquetamientos posibles para Hv, los cuales se almacenan en el conjunto Hv. Se debe tener en cuenta que el tamaño de Hv está limitado por (|E(H)| + 1)k, ya que cada nodo en λ(v) está sin cubrir en un empaquetamiento o está cubierto precisamente por una de las hiperaristas en χ(v) ⊆ E(H). Entonces, ComputeSetPackingk está diseñado para filtrar estos empaquetamientos conservando solo aquellos que se ajusten a algún empaquetamiento para Hc, para cada hijo c de v en T, como se formaliza a continuación. Dejen que hv y hc sean dos empaquetados para Hv y Hc, respectivamente. Decimos que hv se ajusta a hc, indicado por hv ≈ hc si: para cada h ∈ hc ∩ E(Hv), h está en hv; y, para cada h ∈ (E(Hc) − hc), h no está en hv. Ejemplo 4. Considera nuevamente la descomposición de hipertree de ¯H1 reportada en la Figura 3.(c). Luego, el conjunto de todos los empaquetados posibles (que se construyen en el paso de inicialización de ComputeSetPackingk), para cada uno de sus vértices, se reFigure 5: Ejemplo de aplicación del Algoritmo ComputeSetPackingk. 157 Entrada: H, w, y una descomposición de hipertree de ancho k HD = T = (N, E), χ, λ de ¯H; Salida: Una solución para MaxWSP(H, w); var Hv: conjunto de empaquetados para Hv, para cada v ∈ N; h∗: empaquetado para H; v hv: número racional, para cada empaquetado parcial hv para Hv; hhv,c: empaquetado parcial para Hc, para cada empaquetado parcial hv para Hv, y para cada (v, c) ∈ E; -------------------------------------------Procedimiento BottomUp; begin Done := el conjunto de todas las hojas de T; mientras ∃v ∈ T tal que (i) v ∈ Done, y (ii) {c | c es hijo de v} ⊆ Done hacer para cada c tal que (v, c) ∈ E hacer Hv := Hv - {hv | ∃hc ∈ Hc tal que hv ≈ hc}; para cada hv ∈ Hv hacer v hv := w(hv); para cada c tal que (v, c) ∈ E hacer ¯hc := arg maxhc∈Hc|hv≈ hc c hc - w(hc ∩ hv); hhv,c := ¯hc; (* establecer mejor empaquetado *) v hv := v hv + c ¯hc - w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end mientras end; -------------------------------------------begin (* PRINCIPAL *) para cada vértice v en T hacer Hv := {hv empaquetado para Hv}; BottomUp; sea r la raíz de T; ¯hr := arg maxhr∈Hr r hr; h∗ := ¯hr; (* incluir empaquetado *) T opDown(r, hr); return h∗; end. Procedimiento TopDown(v: vértice de N, ¯hv ∈ Hv); comenzar para cada c ∈ N tal que (v, c) ∈ E hacer ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* incluir empaquetado *) TopDown(c, ¯hc); fin para fin; Figura 4: Algoritmo ComputeSetPackingk. representado en la Figura 5.(a). Por ejemplo, la raíz v1 es tal que Hv1 = { {}, {h1}, {h3}, {h5} }. Además, una flecha de un empaque hc a hv indica que hv cumple con hc. Por ejemplo, el lector puede comprobar que el empaquetado {h3} ∈ Hv1 se ajusta al empaquetado {h2, h3} ∈ Hv3, pero no se ajusta a {h1} ∈ Hv3. ¡ComputeSetPackingk construye una solución recorriendo T en dos fases. En la primera fase, los vértices de T se procesan desde las hojas hasta la raíz r, mediante el procedimiento BottomUp. Para cada nodo v que se está procesando, el conjunto Hv se actualiza preliminarmente eliminando todos los empaquetados hv que no cumplen con ningún empaquetado para algunos de los hijos de v. Después de realizar este filtrado, se actualiza el peso hv. De manera intuitiva, v hv almacena el peso del mejor empaquetado parcial para H calculado utilizando solo los hiperarcos que ocurren en χ(Tv). De hecho, si v es una hoja, entonces v hv = w(hv). De lo contrario, para cada hijo c de v en T, v hv se actualiza con el máximo de c hc - w(hc ∩ hv) sobre todos los empaquetados hc que se ajustan a hv (resolviendo empates de forma arbitraria). El empaque ¯hc para el cual se logra este máximo se almacena en la variable hhv,c. En la segunda fase, el árbol T se procesa comenzando desde la raíz. En primer lugar, se selecciona el empaque h∗ que maximiza el peso equipado con los empaques en Hr. Luego, el procedimiento TopDown se utiliza para extender h∗ a todos los otros empaquetamientos parciales para los vértices de T. En particular, en cada vértice v, h∗ se extiende con el empaquetamiento hhv,c, para cada hijo c de v. Ejemplo 5. Supongamos que, en nuestro ejemplo en curso, w(h1) = w(h2) = w(h3) = w(h4) = 1. Luego, una ejecución de ComputeSetPackingk se representa gráficamente en la Figura 5. (b), donde una flecha de un empaquetado hc a un empaquetado hv se utiliza para denotar que hc = hhv,c. Específicamente, las elecciones realizadas durante el cálculo son tales que se calcula el empaquetamiento {h2, h3}. En particular, durante la fase de abajo hacia arriba, tenemos que: (1) se procesa v4 y establecemos v4 {h2} = v4 {h4} = 1 y v4 {} = 0; (2) se procesa v3 y establecemos v3 {h1} = v3 {h3} = 1 y v3 {} = 0; (3) se procesa v2 y establecemos v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 y v3 {} = 0; (4) se procesa v1 y establecemos v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 y v1 {} = 0. Por ejemplo, observe que v1 {h5} = 2 ya que {h5} se ajusta al empaquetado {h4} de Hv2 de tal manera que v2 {h4} = 1. Entonces, al comienzo de la fase de arriba hacia abajo, ComputeSetPackingk selecciona {h3} como un empaquetado para Hv1 y propaga esta elección en el árbol. De manera equivalente, el algoritmo pudo haber elegido {h5}. Como ejemplo adicional, se informa en la Figura 5.(c) la forma en que se obtiene la solución {h1} mediante el algoritmo cuando w(h1) = 5 y w(h2) = w(h3) = w(h4) = 1. Observa que, en esta ocasión, en la fase de arriba hacia abajo, ComputeSetPackingk comienza a seleccionar {h1} como el mejor empaquetado para Hv1. ¡Teorema 4. Sea H un hipergrafo y w una función de ponderación para él. Sea HD = T, χ, λ una descomposición de hipertree completa de ancho k de ¯H. Entonces, ComputeSetPackingk en la entrada H, w y HD produce correctamente una solución para MaxWSP(H, w) en tiempo O(|T| × (|E(H)| + 1)2k. Prueba. [Bosquejo] Observamos que h∗ (calculado por ComputeSetPackingk) es un empaquetamiento para H. De hecho, consideremos un par de hiperarcos h1 y h2 en h∗, y supongamos, para efectos de contradicción, que h1 ∩ h2 = ∅. Sea v1 (resp., v2) un vértice arbitrario de T, para el cual ComputeSetPackingk incluyó h1 (resp., h2) en h∗ en el cálculo de abajo hacia arriba. Por construcción, tenemos h1 ∈ χ(v1) y h2 ∈ χ(v2). Sea I un elemento en h1 ∩ h2. En el hipergrafo dual H, I es un hiperborde en E(¯H) que cubre tanto los nodos h1 como h2. Por lo tanto, por la condición (1) en la Definición 1, existe un vértice v ∈ vértices(T) tal que {h1, h2} ⊆ χ(v). Se debe tener en cuenta que, debido a la condición de conectividad en la Definición 1, también podemos asumir, sin pérdida de generalidad, que v está en el camino que conecta v1 y v2 en T. Sea hv ∈ Hv el elemento añadido por ComputeSetPackingk en h∗ durante la fase de abajo hacia arriba. Dado que los elementos en Hv son empaquetamientos para Hv, se cumple que o bien h1 ∈ hv o h2 ∈ hv. Supongamos, sin pérdida de generalidad, que h1 ∈ hv, y notemos que cada vértice w en T en el camino que conecta v con v1 es tal que h1 ∈ χ(w), debido a la condición de conectividad. Por lo tanto, debido a la definición de conformidad, el empaque hw seleccionado por ComputeSetPackingk para ser agregado en el vértice w en h∗ debe ser tal que h1 ∈ hw. Esto se cumple en particular para w = v1. Contradicción con la definición de v1. Por lo tanto, h∗ es un empaquetamiento para H. Queda entonces por demostrar que tiene el peso máximo sobre todos los empaquetamientos para H. Con este fin, podemos utilizar la inducción estructural en T para demostrar que, en la fase de abajo hacia arriba, la variable v hv se actualiza para contener el peso del empaquetamiento en las aristas en χ(Tv), que contiene hv y que tiene el peso máximo sobre todos los empaquetamientos para las aristas en χ(Tv). Entonces, el resultado sigue, ya que en la fase de arriba hacia abajo, el empaquetado hr que da el peso máximo sobre χ(Tr) = E(H) se incluye primero en h∗, y luego se extiende en cada nodo c con el empaquetado hhv,c de forma conforme con hv y de manera que se alcance el valor máximo de v hv. En cuanto a la complejidad, observe que el paso de inicialización requiere la construcción del conjunto Hv, para cada vértice v, y cada conjunto tiene un tamaño de (|E(H)| + 1)k como máximo. Luego, la función BottomUp verifica la conformidad entre las estrategias en Hv con las estrategias en Hc, para cada par (v, c) ∈ E, y actualiza el peso v hv. Estas tareas pueden llevarse a cabo en tiempo O((|E(H)| + 1)2k) y deben repetirse para cada arista en T, es decir, O(|T|) veces. Finalmente, la función TopDown puede implementarse en tiempo lineal en el tamaño de T, ya que solo requiere actualizar h∗ accediendo a la variable hhv,c. El resultado anterior muestra que si se proporciona una descomposición de hipertree de ancho k, el problema MaxWSP se puede resolver de manera eficiente. Además, a diferencia del caso de los grafos de elementos estructurados, es bien sabido que decidir la existencia de una descomposición de hipertree acotada por k y calcular una (si existe alguna) son problemas que pueden resolverse eficientemente en tiempo polinómico [7]. Por lo tanto, el Teorema 4 confirma que la clase C(hw, k) constituye en realidad una clase manejable para el problema de determinación del ganador. Como muestra el siguiente teorema, para subclases grandes (que dependen solo de cómo se especifica la función de peso), MaxWSP(H, w) es altamente paralelizable. Llamemos a una función de ponderación suave si es computable en espacio logarítmico y si todos los pesos son polinomiales (y por lo tanto solo requieren O(log n) bits para su representación). Recuerde que LOGCFL es una clase de complejidad paralela contenida en NC2, cf. [9]. La versión funcional de LOGCFL es LLOGCFL, la cual se obtiene equipando un transductor de espacio logarítmico con un oráculo en LOGCFL. Teorema 5. Sea H un hipergrafo en C(hw, k), y sea w una función de ponderación suave para él. Entonces, MaxWSP(H, w) está en LLOGCFL. 4. Dadas las descomposiciones de hipertree frente a los grafos de elementos estructurados, y considerando que se ha demostrado que la clase C(hw, k) es una isla de tratabilidad para el problema de determinación del ganador, y dado que se ha demostrado que la clase C(ig, k) no es reconocible eficientemente, uno podría inclinarse a pensar que existen instancias con ancho de hipertree ilimitado, pero que admiten un grafo de elementos de ancho de árbol acotado (por lo que la intratabilidad de los grafos de elementos estructurados residiría en su generalidad). Sorprendentemente, establecemos que este no es el caso. La clave de la prueba es primero demostrar que los grafos de elementos estructurados están en correspondencia uno a uno con un tipo especial de descomposiciones de hiperárboles del hipergrafo dual, al que llamaremos estricto. Entonces, el resultado seguirá al demostrar que las descomposiciones estrictas de hipertree de ancho k son menos potentes que las descomposiciones de hipertree de ancho k. 4.1 Descomposiciones estrictas de hipertree Deje que H sea un hipergrafo, y V ⊆ N(H) sea un conjunto de nodos y X, Y ∈ N(H). X es [V]-adyacente a Y si existe un borde h ∈ E(H) tal que {X, Y} ⊆ (h - V). Un camino [V] π de X a Y es una secuencia X = X0, . . . , X = Y de variables tal que: Xi es [V]-adyacente a Xi+1, para cada i ∈ [0... -1]. Un conjunto W ⊆ N(H) de nodos está [V]-conectado si ∀X, Y ∈ W hay un [V]-camino de X a Y. Un componente [V ] es un conjunto maximal no vacío de nodos W ⊆ (N(H) − V ) que está [V ]-conectado. Para cualquier componente [V] C, sea E(C) = {h ∈ E(H) | h ∩ C = ∅}. Definición 2. Una descomposición de hipertree HD = T, χ, λ de H es estricta si se cumplen las siguientes condiciones: 1. para cada par de vértices r y s en los vértices de T tal que s es un hijo de r, y para cada componente [χ(r)]-Cr. La intersección de Cr con χ(Ts) es vacía, Cr es un componente de [χ(r) ∩ N(λ(r) ∩ λ(s))]; 2. para cada arista h ∈ E(H), hay un vértice p tal que h ∈ λ(p) y h ⊆ χ(p) (decimos que p cubre fuertemente a h); 3. para cada arista h ∈ E(H), el conjunto {p ∈ vértices(T) | h ∈ λ(p)} induce un subárbol (conectado) de T. La anchura estricta de hipertree shw(H) de H es la anchura mínima sobre todas sus descomposiciones estrictas de hipertree. La relación básica entre las descomposiciones de hipertree agradables y los grafos de elementos estructurados se muestra en el siguiente teorema. Teorema 6. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, una k-anchura descomposición en árbol de un grafo de elementos para H existe si y solo si ¯H tiene una (k + 1)-anchura descomposición estricta en hiperárbol. Se debe tener en cuenta que, en lo que respecta al problema de empaquetamiento de conjuntos ponderados máximo, dado un hipercubo H, siempre podemos asumir que para cada nodo v ∈ N(H), {v} está en E(H). De hecho, si esta hiperarista no está en el hipercubo, entonces se puede agregar sin pérdida de generalidad, estableciendo w({v}) = 0. Por lo tanto, dejando que C(shw, k) denote la clase de todos los hipergrafos cuyos hipergrafos duales (asociados con un máximo de 2 términos +1) solo juegan el papel técnico de ocuparse de la diferente definición de ancho para las descomposiciones de árboles y las descomposiciones de hiperárboles. 159 problemas de empaquetamiento de conjuntos ponderados) tienen un ancho de hiperárbol estricto limitado por k, tenemos que C(shw, k + 1) = C(ig, k). Por definición, las descomposiciones de hipertree estrictas son descomposiciones de hipertree especiales. De hecho, podemos demostrar que las condiciones adicionales en la Definición 2 inducen una restricción real en el poder de descomposición. Teorema 7. C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). \n\nC(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). Una vista desde la teoría de juegos. Arrojamos más luz sobre las descomposiciones estrictas de hypertrees al discutir una interesante caracterización basada en el juego estricto de Robber y Marshals, definido adaptando el juego de Robber y Marshals definido en [6], que caracteriza el ancho de hypertree. El juego se juega en un hipercubo H por un ladrón contra k marshals que actúan en coordinación. Los alguaciles se mueven en los hiperarcos de H, mientras que el ladrón se mueve en los nodos de H. El ladrón ve hacia dónde los alguaciles tienen la intención de moverse, y reacciona moviéndose a otro nodo que esté conectado con su posición actual y a través de un camino en G(H) que no utilice ningún nodo contenido en un hiperarco que esté ocupado por los alguaciles antes y después de su movimiento; decimos que estos hiperarcos están bloqueados. Ten en cuenta que en el juego básico definido en [6], al ladrón no se le permite moverse en vértices ocupados por los marshals antes y después de su movimiento, incluso si no pertenecen a hiperarcos bloqueados. Es importante que los marshals jueguen de manera monótona, es decir, no pueden ocupar un borde que haya sido ocupado previamente en el juego y que actualmente no lo esté. Los alguaciles ganan el juego si capturan al ladrón, ocupando un borde que cubra un nodo donde se encuentre el ladrón. De lo contrario, el ladrón gana. Teorema 8. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, ¯H tiene una descomposición estricta de hipertree de k-anchura si y solo si k marshals pueden ganar el Juego estricto de Robber y Marshals en ¯H, sin importar los movimientos de los ladrones. 5. CONCLUSIONES Hemos resuelto la pregunta abierta de determinar la complejidad de calcular un grafo de elementos estructurado asociado con un escenario de subasta combinatoria. El resultado es una mala noticia, ya que resultó que es NP-completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado, incluso para un ancho de árbol de 3. Motivados por este resultado, investigamos el uso de la descomposición de hiperárboles (en el hipergrafo dual asociado con el escenario) y demostramos que el problema es tratable en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hiperárbol acotado. Para algunos casos especiales y relevantes, también se discute un algoritmo altamente paralelizable. Curiosamente, también se descubrió que la clase de grafos de elementos estructurados está adecuadamente contenida en la clase de instancias con ancho de hiperárbol acotado (por lo tanto, la razón de su intratabilidad no es su generalidad). En particular, este último resultado se establece mostrando una relación precisa entre los grafos de elementos estructurados y formas restringidas de descomposiciones de hiperárboles (en el hipergrafo dual), llamadas descomposiciones de consultas (ver, por ejemplo, [7]). A la luz de esta observación, notamos que demostrar algunos resultados de aproximabilidad para grafos de elementos estructurados requiere una comprensión profunda de la aproximabilidad de las descomposiciones de consultas, la cual actualmente no se encuentra en la literatura. Como una vía adicional de investigación, sería relevante mejorar el algoritmo ComputeSetPackingk, por ejemplo, mediante el uso de estructuras de datos especializadas, con el fin de evitar la dependencia cuadrática de (|E(H)| + 1)k. Finalmente, otra pregunta interesante es evaluar si las técnicas de descomposición estructural discutidas en el artículo pueden ser utilizadas para abordar eficientemente generalizaciones del problema de determinación del ganador. Por ejemplo, podría ser relevante en varios escenarios de aplicación diseñar algoritmos que puedan encontrar una estrategia de venta cuando hay varias copias del mismo artículo disponibles para la venta, y además cuando el subastador está satisfecho cuando se venden al menos un número dado de copias. El trabajo de G. Gottlob fue apoyado por el EC3 - Centro de Competencia en Comercio Electrónico (Viena) y por un Premio de Mérito de Investigación Wolfson de la Royal Society. En particular, este premio permitió a Gottlob invitar a G. Greco para una visita de investigación a Oxford. Además, G. Greco cuenta con el apoyo de ICAR-CNR y del M.I.U.R. en el marco del proyecto TOCAI.IT. 6. REFERENCIAS [1] I. Adler, G. Gottlob y M. Grohe. Anchura de hipertree y invariantes de hipergrafo relacionados. En Proc. de EUROCOMB05, páginas 5-10, 2005. [2] C. Boutilier. Resolviendo problemas de subasta combinatoria expresados de manera concisa. En Proc. de AAAI02, páginas 359-366, 2002. [3] V. Conitzer, J. Derryberry y T. Sandholm. Subastas combinatorias con grafos de elementos estructurados. En Proc. de AAAI04, páginas 212-218, 2004. [4] E. M. Eschen y J. P. Sinrad. Un algoritmo O(n2) para el reconocimiento de grafos de arco circular. En Proc. de SODA93, páginas 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Óptimo y aproximado. En Proc. de IJCAI99, páginas 548-553, 1999. [6] G. Gottlob, N. Leone y F. Scarcello. Ladrones, marshals y guardias: caracterizaciones lógicas y teóricas de la amplitud de hiperárboles. Revista de Ciencias de la Computación y de Sistemas, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone y S. Scarcello. Descomposiciones de hiperárboles y consultas tratables. Revista de Ciencias de la Computación y de Sistemas, 63(3):579-627, 2002. [8] H. H. Hoos y C. Boutilier. Resolviendo subastas combinatorias utilizando búsqueda local estocástica. En Proc. de AAAI00, páginas 22-29, 2000. [9] D. Johnson. Un catálogo de clases de complejidad. En P. Cramton, Y. Shoham y R. Steinberg, editores, Manual de Ciencias de la Computación Teórica, Volumen A: Algoritmos y Complejidad, páginas 67-161. 1990. [10] N. Korte y R. H. Mohring. Un algoritmo incremental de tiempo lineal para reconocer grafos de intervalo. Revista SIAM sobre Computación, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller y T. Sandholm. El Problema de Determinación del Ganador. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, y Y. Shoham. Revelación de la verdad en aproximadamente 160 subastas combinatorias eficientes. J. ACM, 49(5):577-602, 2002. [13] R. McAfee y J. McMillan. Analizando la subasta de las ondas aéreas. Revista de Perspectivas Económicas, 10(1):159-175, 1996. [14] J. McMillan. Vendiendo derechos de espectro. Revista de Perspectivas Económicas, 8(3):145-62, 1994. [15] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. de EC00, páginas 1-12, 2000. [16] N. Robertson y P. Seymour. Menores de grafos ii. Aspectos algorítmicos del ancho de árbol. Revista de Algoritmos, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias computacionalmente manejables. Ciencia de la Gestión, 44:1131-1147, 1998. [18] T. Sandholm. Una implementación del protocolo de red de contratos basada en cálculos de costos marginales. En Proc. de AAAI93, páginas 256-262, 1993. [19] T. Sandholm. Algoritmo para la determinación óptima del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, 2002. [20] T. Sandholm. Algoritmos de determinación de ganadores. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [21] T. Sandholm y S. Suri. Bob: Mejora en la determinación de ganadores en subastas combinatorias y generalizaciones. Inteligencia Artificial, 7:33-58, 2003. [22] M. Tennenholtz. Algunas subastas combinatorias manejables. En Proc. de AAAI00, páginas 98-103, 2000. [23] E. Zurel y N. Nisan. Un algoritmo de asignación aproximada eficiente para subastas combinatorias. En Proc. de EC01, páginas 125-136, 2001. 161",
    "original_sentences": [
        "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
        "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
        "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
        "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
        "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
        "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
        "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
        "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
        "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
        "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
        "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
        "INTRODUCTION Combinatorial auctions.",
        "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
        "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
        "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
        "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
        "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
        "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
        "The winner determination problem.",
        "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
        "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
        "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
        "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
        "Item graphs.",
        "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
        "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
        "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
        "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
        "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
        "Example 1.",
        "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
        "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
        "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
        "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
        "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
        "Weighted Set Packing.",
        "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
        "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
        "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
        "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
        "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
        "Example 2.",
        "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
        "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
        "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
        "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
        "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
        "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
        "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
        "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
        "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
        "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
        "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
        "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
        "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
        "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
        "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
        "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
        "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
        "The proof of the above results give us some interesting insight into the notion of structured item graph.",
        "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
        "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
        "The rest of the paper is organized as follows.",
        "Section 2 discusses the intractability of structured item graphs.",
        "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
        "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
        "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
        "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
        "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
        "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
        "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
        "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
        "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
        "Theorem 1 (cf. [3]).",
        "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
        "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
        "Many item graphs can be associated with a hypergraph.",
        "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
        "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
        "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
        "Theorem 2.",
        "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
        "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
        "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
        "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
        "First, we discuss the way HG is constructed.",
        "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
        "From G to HG.",
        "Let G = (N, E) be a directed graph.",
        "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
        "No other node is in N(HG).",
        "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
        "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
        "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
        "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
        "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
        "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
        "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
        "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
        "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
        "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
        "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
        "Lemma 1.",
        "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
        "Key Ingredients.",
        "We are now in the position of presenting an overview of the key ingredients of the proof.",
        "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
        "There are three basic observations serving the purpose of proving the correctness of the reduction.",
        "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
        "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
        "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
        "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
        "Each of these vertices plays a specific role in the reduction.",
        "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
        "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
        "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
        "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
        "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
        "The arguments for the proof are as follows.",
        "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
        "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
        "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
        "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
        "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
        "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
        "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
        "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
        "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
        "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
        "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
        "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
        "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
        "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
        "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
        "We denote the set of vertices N of T by vertices(T).",
        "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
        "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
        "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
        "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
        "A hypergraph H is acyclic if hw(H) = 1.",
        "P Example 3.",
        "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
        "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
        "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
        "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
        "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
        "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
        "Theorem 3.",
        "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
        "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
        "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
        "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
        "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
        "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
        "Let hv and hc be two packings for Hv and Hc, respectively.",
        "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
        "Example 4.",
        "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
        "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
        "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
        "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
        "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
        "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
        "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
        "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
        "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
        "Indeed, if v is a leaf, then v hv = w(hv).",
        "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
        "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
        "In the second phase, the tree T is processed starting from the root.",
        "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
        "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
        "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
        "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
        "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
        "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
        "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
        "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
        "Equivalently, the algorithm may have chosen {h5}.",
        "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
        "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
        "Let H be a hypergraph and w be a weighting function for it.",
        "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
        "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
        "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
        "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
        "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
        "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
        "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
        "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
        "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
        "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
        "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
        "This holds in particular for w = v1.",
        "Contradiction with the definition of v1.",
        "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
        "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
        "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
        "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
        "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
        "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
        "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
        "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
        "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
        "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
        "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
        "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
        "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
        "Theorem 5.",
        "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
        "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
        "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
        "Surprisingly, we establish this is not the case.",
        "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
        "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
        "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
        "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
        "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
        "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
        "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
        "Definition 2.",
        "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
        "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
        "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
        "Theorem 6.",
        "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
        "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
        "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
        "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
        "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
        "By definition, strict hypertree decompositions are special hypertree decompositions.",
        "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
        "Theorem 7.",
        "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
        "A Game Theoretic View.",
        "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
        "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
        "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
        "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
        "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
        "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
        "Otherwise, the robber wins.",
        "Theorem 8.",
        "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
        "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
        "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
        "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
        "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
        "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
        "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
        "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
        "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
        "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
        "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
        "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
        "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
        "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
        "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
        "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
        "Hypertree-Width and Related Hypergraph Invariants.",
        "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
        "Solving Concisely Expressed Combinatorial Auction Problems.",
        "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
        "Combinatorial auctions with structured item graphs.",
        "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
        "An o(n2 ) algorithm for circular-arc graph recognition.",
        "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
        "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
        "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
        "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
        "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
        "Hypertree decompositions and tractable queries.",
        "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
        "Solving combinatorial auctions using stochastic local search.",
        "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
        "A Catalog of Complexity Classes.",
        "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
        "An incremental linear-time algorithm for recognizing interval graphs.",
        "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
        "The Winner Determination Problem.",
        "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
        "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
        "Truth revelation in approximately efficient 160 combinatorial auctions.",
        "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
        "Analyzing the airwaves auction.",
        "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
        "Selling spectrum rights.",
        "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
        "Bidding and allocation in combinatorial auctions.",
        "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
        "Graph minors ii. algorithmic aspects of tree width.",
        "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
        "Computationally manageable combinatorial auctions.",
        "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
        "An implementation of the contract net protocol based on marginal cost calculations.",
        "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
        "Algorithm for optimal winner determination in combinatorial auctions.",
        "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
        "Winner determination algorithms.",
        "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
        "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
        "Bob: Improved winner determination in combinatorial auctions and generalizations.",
        "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
        "Some tractable combinatorial auctions.",
        "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
        "An efficient approximate allocation algorithm for combinatorial auctions.",
        "In Proc. of EC01, pages 125-136, 2001. 161"
    ],
    "translated_text_sentences": [
        "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas.",
        "Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados).",
        "Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado.",
        "Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad.",
        "De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial.",
        "En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3.",
        "Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias.",
        "Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí.",
        "De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado.",
        "Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado.",
        "Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1.",
        "INTRODUCCIÓN Subastas combinatorias.",
        "Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos.",
        "Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales.",
        "Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18].",
        "Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I.",
        "Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I.",
        "Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j.",
        "El problema de determinación del ganador.",
        "Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles.",
        "Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19].",
        "Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]).",
        "De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables.",
        "Gráficos de ítems.",
        "Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado.",
        "De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16].",
        "Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}.",
        "Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B.",
        "Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista.",
        "Ejemplo 1.",
        "El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3.",
        "El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados.",
        "El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente.",
        "Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado.",
        "Los algoritmos de tiempo polinómico para encontrar la mejor simplificación del grafo primal solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo.",
        "Empaquetamiento de conjuntos ponderado.",
        "Cabe destacar que la representación de hipergrafo H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en hipergrafos (por ejemplo, [17]).",
        "Formalmente, un empaquetamiento h para un hipergrafo H es un conjunto de hiperarcos de H tal que para cada par h, h ∈ h con h ≠ h, se cumple que h ∩ h = ∅.",
        "Si se deja que w sea una función de ponderación para H, es decir, una función computable en tiempo polinómico de E(H) a números racionales, el peso de un empaquetado h es el número racional w(h) = h∈h w(h), donde w({}) = 0.",
        "Entonces, el problema de empaquetamiento de conjuntos con peso máximo para H con respecto a w, denotado por MaxWSP(H, w), es el problema de encontrar un empaquetamiento para H que tenga el peso máximo entre todos los empaquetamientos para H. Para ver que MaxWSP es simplemente una formulación diferente para el problema de determinación del ganador, dado una subasta combinatoria I, B, es suficiente definir la función de ponderación w I,B (elemento(Bi)) = pago(Bi).",
        "Entonces, el conjunto de soluciones para el problema de empaquetamiento de conjuntos ponderados para H I,B con respecto a w I,B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, B.",
        "Ejemplo 2.",
        "Considera nuevamente el hipercubo H I0,B0 reportado en la Figura 1.(a).",
        "Un ejemplo de empaquetado para H I0, B0 es h = {h1}, que intuitivamente corresponde a un resultado para I0, B0, donde el subastador aceptó la oferta B1.",
        "Al asumir que las ofertas B1, B2 y B3 son tales que pay(B1) = pay(B2) = pay(B3), el empaquetado h no es una solución para el problema MaxWSP(H I0,B0 , w I0,B0).",
        "De hecho, el empaque h∗ = {h2, h3} es tal que w I0,B0 (h∗ ) > w I0,B0 (h). ¡Contribuciones! El objetivo principal de este artículo es identificar clases grandes y manejables para el problema de determinación del ganador, que además sean reconocibles de forma polinómica.",
        "Con este objetivo, primero estudiamos grafos de elementos estructurados y resolvemos el problema abierto en [3].",
        "El resultado es una noticia muy mala: es NP completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado de ancho de árbol 3.",
        "De manera más formal, dejando que C(ig, k) denote la clase de todos los hipergrafos que tienen un árbol de ítems con un ancho de árbol limitado por k, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C(ig, 3) es NP-completo.",
        "A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que puedan ser verificados en tiempo polinómico y que aún puedan ser utilizados para aislar clases tratables del problema de empaquetamiento de conjuntos con peso máximo o, equivalentemente, el problema de determinación del ganador.",
        "Nuestras investigaciones, esta vez, llevaron a noticias muy buenas que se resumen a continuación: Para un hipercubo H, su dual ¯H = (V, E) es tal que los nodos en V están en correspondencia uno a uno con los hiperarcos en H, y para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} está en E. Mostramos que MaxWSP es tratable en la clase de aquellas instancias cuyos hipercubos duales tienen un ancho de hiperárbol[7] limitado por k (abreviado: clase C(hw, k) de hipercubos).",
        "Cabe destacar que un problema clave de la tratabilidad es considerar el ancho de hiperárbol del hipergrafo dual ¯H en lugar del hipergrafo de subastas H. De hecho, podemos demostrar que MaxWSP sigue siendo NP-duro incluso cuando H es acíclico (es decir, cuando tiene un ancho de hiperárbol de 1), incluso cuando cada nodo está contenido en un máximo de 3 hiperarcos.",
        "Para algunas clases especiales relevantes de hipergrafos en C(hw, k), diseñamos un algoritmo altamente paralelizable para MaxWSP.",
        "Específicamente, si las funciones de ponderación se pueden calcular en espacio logarítmico y los pesos son polinomiales (por ejemplo, cuando todos los hiperarcos tienen pesos unitarios y se está interesado en encontrar el empaquetamiento con el máximo número de arcos), demostramos que MaxWSP puede resolverse mediante un algoritmo LOGCFL.",
        "Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son reducibles en espacio logarítmico a lenguajes libres de contexto, y que LOGCFL ⊆ NC2 ⊆ P (ver, por ejemplo, [9]).",
        "Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la descomposición de hipertree de los hipergrafos duales en lugar de la treewidth de los grafos de elementos.",
        "Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados.",
        "De hecho, demostramos que clases de instancias estrictamente más grandes son tratables según nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados.",
        "De manera intuitiva, la NP-dificultad de reconocer grafos de elementos estructurados de ancho acotado no se debe a su gran generalidad, sino más bien a algunas peculiaridades en su definición.",
        "La prueba de los resultados anteriores nos brinda una perspectiva interesante sobre la noción de grafo de elementos estructurados.",
        "De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos descomposiciones de hiperárboles estrictas.",
        "También se propone una caracterización de juego para la noción de ancho de hiperárbol estricto, que se especializa en el juego de Ladrón y Policías en [6] (propuesto para caracterizar el ancho de hiperárbol), y que aclara los requisitos adicionales sobre las descomposiciones de hiperárboles.",
        "El resto del documento está organizado de la siguiente manera.",
        "La sección 2 discute la intratabilidad de los grafos de elementos estructurados.",
        "La sección 3 presenta el algoritmo de tiempo polinómico para resolver MaxWSP en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hipertree acotado, y discute los casos en los que el algoritmo también es altamente paralelizable.",
        "La comparación entre las clases C(ig, k) y C(hw, k) se discute en la Sección 4.",
        "Finalmente, en la Sección 5 sacamos nuestras conclusiones también delineando las direcciones para futuras investigaciones. 2.",
        "COMPLEJIDAD DE LOS GRAFOS DE ELEMENTOS ESTRUCTURADOS Sea H un hipergrafo.",
        "Un grafo G = (V, E) es un grafo de elementos para H si V = N(H) y, para cada h ∈ E(H), el subgrafo de G inducido sobre los nodos en h está conectado.",
        "Una clase importante de grafos de elementos es la de grafos de elementos estructurados, es decir, aquellos grafos de elementos que tienen un ancho de árbol acotado como se formaliza a continuación.",
        "Una descomposición de árbol [16] de un grafo G = (V, E) es un par T, χ, donde T = (N, F) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjunto de vértices χ(p) ⊆ V, de modo que se satisfacen las siguientes condiciones: (1) para cada vértice b de G, existe un p ∈ N tal que b ∈ χ(p); (2) para cada arista {b, d} ∈ E, existe un p ∈ N tal que {b, d} ⊆ χ(p); (3) para cada vértice b de G, el conjunto {p ∈ N | b ∈ χ(p)} induce un subárbol conectado de T. El ancho de T, χ es el número maxp∈N |χ(p) − 1|.",
        "El treewidth de G, denotado por tw(G), es el ancho mínimo sobre todas sus descomposiciones en árboles.",
        "El problema de determinación del ganador puede resolverse en tiempo polinómico en grafos de elementos con treewidth acotado [3].",
        "Teorema 1 (cf. [3]).",
        "Se tiene una descomposición en árbol de ancho k T, χ de un grafo de elementos para H.",
        "Entonces, MaxWSP(H, w) se puede resolver en tiempo O(|T|2 ×(|E(H)|+1)k+1 ).",
        "Muchos gráficos de elementos pueden estar asociados con un hipergráfico.",
        "Como ejemplo, observe que el grafo de elementos en la Figura 1. (c) tiene un ancho de árbol de 1, mientras que la Figura 1. (d) muestra un grafo de elementos cuyo ancho de árbol es 2.",
        "De hecho, era una pregunta abierta si, para una constante k dada, se puede verificar en tiempo polinómico si existe un grafo de ítems de ancho de árbol k, y en caso afirmativo, si dicho grafo de ítems se puede calcular eficientemente.",
        "La principal tarea de esta sección es demostrar que la clase C(ig, k) es difícil de reconocer.",
        "Teorema 2.",
        "Decidir si un hipergrafo H pertenece a C(ig, 3) es NP-difícil.",
        "La prueba de este resultado se basa en una reducción elaborada del problema de camino hamiltoniano HP(s, t) que consiste en decidir si hay un camino hamiltoniano desde un nodo s hasta un nodo t en un grafo dirigido G = (N, E).",
        "Para ayudar a la intuición, aquí presentamos una descripción general de alto nivel de los principales ingredientes utilizados en la prueba.",
        "La idea general es construir un hipercubo HG de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución.",
        "Primero, discutimos la forma en que se construye HG.",
        "Ver la Figura 2. (a) para una ilustración, donde el grafo G consiste en los nodos s, x, y, y t, y el conjunto de sus aristas es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
        "De G a HG.",
        "Sea G = (N, E) un grafo dirigido.",
        "Entonces, el conjunto de nodos en HG es tal que: para cada x ∈ N, N(HG) contiene los nodos bsx, btx, bx, bx, bdx; para cada e = (x, y) ∈ E, N(HG) contiene los nodos nsx, nsx, nty, nty, nsex y ntey.",
        "Ningún otro nodo está en N(HG).",
        "Los hiperarcos en HG son de tres tipos: 1) para cada x ∈ N, E(HG) contiene los hiperarcos: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, y A3 x = {bx, bx} -nota que estos hiperarcos inducen una clique en los nodos {bx, bx, bdx}; 1 Las pruebas detalladas se pueden encontrar en el Apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf. Figura 2: Prueba del Teorema 2: (a) de G a HG - solo se reportan los hiperarcos en 1) y 2); (b) un esqueleto para una descomposición en árbol TD para HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, y TA3 x = {btx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {btx, bx, bx, bdx}; 2) para cada e = (x, y) ∈ E, E(HG) contiene los hiperarcos: • SHx = {nsx, nsx}; • THy = {nty, nty}; • SEe = {nsx, nse x} y SEe = {nsx, nse x} -nota que estos dos hiperarcos más SHx inducen una clique en los nodos {nsx, nsx, nse x}; • TEe = {nty, nte y} y TEe = {nty, nte y} -nota que estos dos hiperarcos más THy inducen una clique en los nodos {nty, nty, nte y}.",
        "Observa que cada uno de los hiperarcos anteriores, excepto aquellos de la forma Sx y Tx, contiene exactamente dos nodos.",
        "Como ejemplo de los hiperarcos de tipo 1) y 2), el lector puede referirse a la construcción de ejemplo reportada en la Figura 2. (a), y notar, por ejemplo, que Sx = {bsx, nse2 x, nse3 x} y que Tt = {btt, nte4 t, nte3 t}. 3) finalmente, denotamos por DG al conjunto que contiene los hiperarcos en E(HG) del tercer tipo.",
        "En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperarcos que satisfacen las cuatro condiciones que se discuten a continuación.",
        "Sea PG el conjunto de los siguientes |PG| ≤ |N| + 3 × |E| pares: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
        "Además, sea I(v) el conjunto {h ∈ E(H) | v ∈ h} de los hiperarcos de H que son tocados por v; y, para un conjunto V ⊆ N(H), sea I(V) = v∈V I(v).",
        "Entonces, DG tiene que ser un conjunto tal que: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ PG o (β, α) ∈ PG, se cumple: I(α) ∩ DG = ∅; y, (c4) ∀S ⊆ N tal que |S| ≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ PG, se cumple que: I(S) ⊇ DG.",
        "De manera intuitiva, el conjunto DG es tal que cada una de sus hiperaristas es tocada exactamente por uno de los dos nodos en cada par de PG, cf. (c1) y (c2).",
        "Además, los hiperarcos en DG solo tocan vértices incluidos en al menos un par de PG - cf. (c3); y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se pueden construir a partir de él pertenece a PG - cf. (c4).",
        "El lector puede preguntarse ahora si existe un conjunto DG que satisfaga (c1), (c2), (c3) y (c4).",
        "En el siguiente lema, respondemos positivamente a esta pregunta y referimos al lector a su demostración para un ejemplo de construcción.",
        "Lema 1.",
        "Un conjunto DG, con |DG| = 2 × |PG| + 2, que cumple las condiciones (c1), (c2), (c3) y (c4) se puede construir en tiempo O(|PG|2).",
        "Ingredientes clave.",
        "Ahora estamos en la posición de presentar una visión general de los ingredientes clave de la prueba.",
        "Sea G un grafo de elementos arbitrario para HG, y sea TD = T, χ una descomposición de árbol de ancho 3 de G (nota que, debido a las cliques, por ejemplo, en los nodos {bsx, bx, bx, bdx}, cualquier grafo de elementos para HG tiene un ancho de árbol de al menos 3).",
        "Hay tres observaciones básicas que sirven para demostrar la corrección de la reducción.",
        "Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértices.",
        "Específicamente, para cada nodo x ∈ N, TD contiene un vértice bs(x) tal que χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, y un vértice bt(x) tal que χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
        "Y, para cada arista e = (x, y) ∈ E, TD contiene un vértice ns(x,e) tal que χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, y un vértice nt(y,e) tal que χ(nt(y,e)) ⊇ {nte y, nty, nty}.",
        "Intuitivamente, se requiere que estos vértices cubran los cliques de HG asociados con los hiperarcos de tipo 1) y 2).",
        "Cada uno de estos vértices desempeña un papel específico en la reducción.",
        "De hecho, cada arista dirigida e = (x, y) ∈ E está codificada en TD mediante los vértices: ns(x,e), que representan precisamente que e comienza en x; y nt(y,e), que representan precisamente que e termina en y.",
        "Además, cada nodo x ∈ N está codificado en TD mediante los vértices: bs(x), que representa el punto de inicio de las aristas que se originan en x; y, bt(x), que representa el punto de terminación de las aristas que terminan en x.",
        "Como ejemplo, la Figura 2. (b) muestra el esqueleto de una descomposición de árbol TD.",
        "El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el hipercubo HG en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación.",
        "La conexión entre bloques y la unicidad de las conexiones: La segunda observación crucial es que en el camino que conecta un vértice de la forma bs(x) (resp., bt(y)) con un vértice de la forma ns(x,e) (resp., nt(y,e)) hay un vértice especial de la forma w(x,y) tal que: χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E. Garantizar la existencia de un vértice así es precisamente el papel que desempeñan los hiperarcos en DG.",
        "Los argumentos para la prueba son los siguientes.",
        "Primero, observamos que I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} e I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
        "Luego, mostramos una propiedad que establece que para un par de vértices consecutivos p y q en el camino que conecta bs(x) y ns(x,e) (resp., bt(y) y nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
        "Por lo tanto, tenemos: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (o bien, I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
        "Basándose en esta observación, y al explotar las propiedades de los hiperarcos en DG, no es difícil demostrar que cualquier par de vértices consecutivos p y q deben compartir dos nodos de HG formando un par en PG, y ambos deben tocar Sx (resp., Ty).",
        "Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w(x,y), en este camino es tal que χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E - para ello, note que nse x ∈ Sx, nte t ∈ Ty, e I(χ(w(x,y))) ⊇ DG.",
        "En particular, w(x,y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay otro vértice de la forma w(x,z), para z = y (o bien, w(z,y), para z = x).",
        "Para ayudar a la intuición, observamos que tener un vértice de la forma w(x,y) en TD corresponde a la selección de un borde desde el nodo x hasta el nodo y en el camino hamiltoniano.",
        "De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de un camino hamiltoniano para G y los vértices de la forma w(x,y).",
        "Como ejemplo, en la Figura 2. (b), los vértices de la forma w(s,x), w(x,y) y w(y,t) están en TD, y GT D muestra el camino hamiltoniano correspondiente.",
        "Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w(x, y), para una arista e = (x, y) ∈ E no está en TD (es decir, si la arista (x, y) no pertenece al camino hamiltoniano), entonces el bloque correspondiente ns(x, e) (resp., nt(y, e)) puede ser agregado arbitrariamente en el subárbol enraizado en el bloque ns(x, e) (resp., nt(y, e)), donde e es la arista de la forma e = (x, z) (resp., e = (z, y)) tal que w(x, z) (resp., w(z, y)) está en TD.",
        "Por ejemplo, la Figura 2. (a) muestra w(x,t), que no se utiliza en TD, y la Figura 2. (b) muestra cómo los bloques ns(x,e3) y nt(t,e3) pueden ser dispuestos en TD para garantizar la condición de conectividad.",
        "CASOS TRACTABLES MEDIANTE DESCOMPOSICIONES DE HIPERÁRBOLES Dado que construir grafos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden ser utilizadas para identificar clases de instancias de MaxWSP tratables.",
        "Con este fin, nos enfocamos en la noción de descomposición de hiperárboles [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros.",
        "Un hypertree para un hipercubo H es un triple T, χ, λ, donde T = (N, E) es un árbol raíz, y χ y λ son funciones de etiquetado que asocian a cada vértice p ∈ N con dos conjuntos χ(p) ⊆ N(H) y λ(p) ⊆ E(H).",
        "Si T = (N, E) es un subárbol de T, definimos χ(T) = v∈N χ(v).",
        "Denotamos el conjunto de vértices N de T como vertices(T).",
        "Además, para cualquier p ∈ N, Tp denota el subárbol de T con raíz en p. Definición 1.",
        "Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
        "El ancho de una descomposición de hipertree T, χ, λ es maxp∈vertices(T )|λ(p)|.",
        "El ancho de HYPERTREE hw(H) de H es el ancho mínimo sobre todas sus descomposiciones hypertree.",
        "Un hipergrafo H es acíclico si hw(H) = 1.",
        "Ejemplo 3.",
        "El hipergrafo H I0,B0 reportado en la Figura 1. (a) es un ejemplo de hipergrafo acíclico.",
        "En cambio, tanto los hipergráficos H1 y ¯H1 mostrados en la Figura 3. (a) y la Figura 3. (b), respectivamente, no son acíclicos ya que su anchura de hipertiempo es 2.",
        "Se reporta una descomposición de hipertree de ancho 2 para ¯H1 en la Figura 3.(c).",
        "En particular, observe que H1 se ha obtenido agregando los dos hiperarcos h4 y h5 a H I0,B0 para modelar, por ejemplo, que dos nuevas ofertas, B4 y B5, respectivamente, han sido propuestas al subastador. En lo siguiente, en lugar de trabajar en el hipercampo H asociado con un problema de MaxWSP, trataremos con su dual ¯H, es decir, con el hipercampo tal que sus nodos están en correspondencia uno a uno con los hiperarcos de H, y donde para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} está en E( ¯H).",
        "Como ejemplo, el lector puede querer revisar nuevamente el hipercubo H1 en la Figura 3 (a) y notar que el hipercubo en la Figura 3 (b) es de hecho su dual.",
        "La razón de esta elección es que imponer restricciones en el hipercubo original garantiza la tratabilidad solo en escenarios muy simples.",
        "Teorema 3.",
        "En la clase de hipergrafos acíclicos, MaxWSP está (1) en P si cada nodo ocurre en un máximo de dos hiperarcos; y, (2) NP-duro, incluso si cada nodo está contenido en un máximo de tres hiperarcos. 3.1 Descomposición de hiperárboles en el hipergrafo dual y problemas de empaquetamiento tratables Para una constante fija k, sea C(hw, k) la clase de todos los hipergrafos cuyos hipergrafos duales tienen un ancho de hiperárbol limitado por k. El problema de empaquetamiento de conjuntos con peso máximo se puede resolver en tiempo polinómico en la clase C(hw, k) mediante el algoritmo ComputeSetPackingk, mostrado en la Figura 4.",
        "El algoritmo recibe como entrada un hipercubo H, una función de ponderación w, y una descomposición de hipertree de ancho k HD = T=(N, E), χ, λ de ¯H.",
        "Para cada vértice v ∈ N, sea Hv el hipergrafo cuyo conjunto de nodos N(Hv) ⊆ N(H) coincide con λ(v), y cuyo conjunto de aristas E(Hv) ⊆ E(H) coincide con χ(v).",
        "En un paso de inicialización, el algoritmo equipa a cada vértice v con todos los empaquetamientos posibles para Hv, los cuales se almacenan en el conjunto Hv.",
        "Se debe tener en cuenta que el tamaño de Hv está limitado por (|E(H)| + 1)k, ya que cada nodo en λ(v) está sin cubrir en un empaquetamiento o está cubierto precisamente por una de las hiperaristas en χ(v) ⊆ E(H).",
        "Entonces, ComputeSetPackingk está diseñado para filtrar estos empaquetamientos conservando solo aquellos que se ajusten a algún empaquetamiento para Hc, para cada hijo c de v en T, como se formaliza a continuación.",
        "Dejen que hv y hc sean dos empaquetados para Hv y Hc, respectivamente.",
        "Decimos que hv se ajusta a hc, indicado por hv ≈ hc si: para cada h ∈ hc ∩ E(Hv), h está en hv; y, para cada h ∈ (E(Hc) − hc), h no está en hv.",
        "Ejemplo 4.",
        "Considera nuevamente la descomposición de hipertree de ¯H1 reportada en la Figura 3.(c).",
        "Luego, el conjunto de todos los empaquetados posibles (que se construyen en el paso de inicialización de ComputeSetPackingk), para cada uno de sus vértices, se reFigure 5: Ejemplo de aplicación del Algoritmo ComputeSetPackingk. 157 Entrada: H, w, y una descomposición de hipertree de ancho k HD = T = (N, E), χ, λ de ¯H; Salida: Una solución para MaxWSP(H, w); var Hv: conjunto de empaquetados para Hv, para cada v ∈ N; h∗: empaquetado para H; v hv: número racional, para cada empaquetado parcial hv para Hv; hhv,c: empaquetado parcial para Hc, para cada empaquetado parcial hv para Hv, y para cada (v, c) ∈ E; -------------------------------------------Procedimiento BottomUp; begin Done := el conjunto de todas las hojas de T; mientras ∃v ∈ T tal que (i) v ∈ Done, y (ii) {c | c es hijo de v} ⊆ Done hacer para cada c tal que (v, c) ∈ E hacer Hv := Hv - {hv | ∃hc ∈ Hc tal que hv ≈ hc}; para cada hv ∈ Hv hacer v hv := w(hv); para cada c tal que (v, c) ∈ E hacer ¯hc := arg maxhc∈Hc|hv≈ hc c hc - w(hc ∩ hv); hhv,c := ¯hc; (* establecer mejor empaquetado *) v hv := v hv + c ¯hc - w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end mientras end; -------------------------------------------begin (* PRINCIPAL *) para cada vértice v en T hacer Hv := {hv empaquetado para Hv}; BottomUp; sea r la raíz de T; ¯hr := arg maxhr∈Hr r hr; h∗ := ¯hr; (* incluir empaquetado *) T opDown(r, hr); return h∗; end.",
        "Procedimiento TopDown(v: vértice de N, ¯hv ∈ Hv); comenzar para cada c ∈ N tal que (v, c) ∈ E hacer ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* incluir empaquetado *) TopDown(c, ¯hc); fin para fin; Figura 4: Algoritmo ComputeSetPackingk. representado en la Figura 5.(a).",
        "Por ejemplo, la raíz v1 es tal que Hv1 = { {}, {h1}, {h3}, {h5} }.",
        "Además, una flecha de un empaque hc a hv indica que hv cumple con hc.",
        "Por ejemplo, el lector puede comprobar que el empaquetado {h3} ∈ Hv1 se ajusta al empaquetado {h2, h3} ∈ Hv3, pero no se ajusta a {h1} ∈ Hv3. ¡ComputeSetPackingk construye una solución recorriendo T en dos fases.",
        "En la primera fase, los vértices de T se procesan desde las hojas hasta la raíz r, mediante el procedimiento BottomUp.",
        "Para cada nodo v que se está procesando, el conjunto Hv se actualiza preliminarmente eliminando todos los empaquetados hv que no cumplen con ningún empaquetado para algunos de los hijos de v. Después de realizar este filtrado, se actualiza el peso hv.",
        "De manera intuitiva, v hv almacena el peso del mejor empaquetado parcial para H calculado utilizando solo los hiperarcos que ocurren en χ(Tv).",
        "De hecho, si v es una hoja, entonces v hv = w(hv).",
        "De lo contrario, para cada hijo c de v en T, v hv se actualiza con el máximo de c hc - w(hc ∩ hv) sobre todos los empaquetados hc que se ajustan a hv (resolviendo empates de forma arbitraria).",
        "El empaque ¯hc para el cual se logra este máximo se almacena en la variable hhv,c.",
        "En la segunda fase, el árbol T se procesa comenzando desde la raíz.",
        "En primer lugar, se selecciona el empaque h∗ que maximiza el peso equipado con los empaques en Hr.",
        "Luego, el procedimiento TopDown se utiliza para extender h∗ a todos los otros empaquetamientos parciales para los vértices de T. En particular, en cada vértice v, h∗ se extiende con el empaquetamiento hhv,c, para cada hijo c de v. Ejemplo 5.",
        "Supongamos que, en nuestro ejemplo en curso, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
        "Luego, una ejecución de ComputeSetPackingk se representa gráficamente en la Figura 5. (b), donde una flecha de un empaquetado hc a un empaquetado hv se utiliza para denotar que hc = hhv,c.",
        "Específicamente, las elecciones realizadas durante el cálculo son tales que se calcula el empaquetamiento {h2, h3}.",
        "En particular, durante la fase de abajo hacia arriba, tenemos que: (1) se procesa v4 y establecemos v4 {h2} = v4 {h4} = 1 y v4 {} = 0; (2) se procesa v3 y establecemos v3 {h1} = v3 {h3} = 1 y v3 {} = 0; (3) se procesa v2 y establecemos v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 y v3 {} = 0; (4) se procesa v1 y establecemos v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 y v1 {} = 0.",
        "Por ejemplo, observe que v1 {h5} = 2 ya que {h5} se ajusta al empaquetado {h4} de Hv2 de tal manera que v2 {h4} = 1.",
        "Entonces, al comienzo de la fase de arriba hacia abajo, ComputeSetPackingk selecciona {h3} como un empaquetado para Hv1 y propaga esta elección en el árbol.",
        "De manera equivalente, el algoritmo pudo haber elegido {h5}.",
        "Como ejemplo adicional, se informa en la Figura 5.(c) la forma en que se obtiene la solución {h1} mediante el algoritmo cuando w(h1) = 5 y w(h2) = w(h3) = w(h4) = 1.",
        "Observa que, en esta ocasión, en la fase de arriba hacia abajo, ComputeSetPackingk comienza a seleccionar {h1} como el mejor empaquetado para Hv1. ¡Teorema 4.",
        "Sea H un hipergrafo y w una función de ponderación para él.",
        "Sea HD = T, χ, λ una descomposición de hipertree completa de ancho k de ¯H.",
        "Entonces, ComputeSetPackingk en la entrada H, w y HD produce correctamente una solución para MaxWSP(H, w) en tiempo O(|T| × (|E(H)| + 1)2k.",
        "Prueba. [Bosquejo] Observamos que h∗ (calculado por ComputeSetPackingk) es un empaquetamiento para H. De hecho, consideremos un par de hiperarcos h1 y h2 en h∗, y supongamos, para efectos de contradicción, que h1 ∩ h2 = ∅.",
        "Sea v1 (resp., v2) un vértice arbitrario de T, para el cual ComputeSetPackingk incluyó h1 (resp., h2) en h∗ en el cálculo de abajo hacia arriba.",
        "Por construcción, tenemos h1 ∈ χ(v1) y h2 ∈ χ(v2). Sea I un elemento en h1 ∩ h2.",
        "En el hipergrafo dual H, I es un hiperborde en E(¯H) que cubre tanto los nodos h1 como h2.",
        "Por lo tanto, por la condición (1) en la Definición 1, existe un vértice v ∈ vértices(T) tal que {h1, h2} ⊆ χ(v).",
        "Se debe tener en cuenta que, debido a la condición de conectividad en la Definición 1, también podemos asumir, sin pérdida de generalidad, que v está en el camino que conecta v1 y v2 en T. Sea hv ∈ Hv el elemento añadido por ComputeSetPackingk en h∗ durante la fase de abajo hacia arriba.",
        "Dado que los elementos en Hv son empaquetamientos para Hv, se cumple que o bien h1 ∈ hv o h2 ∈ hv.",
        "Supongamos, sin pérdida de generalidad, que h1 ∈ hv, y notemos que cada vértice w en T en el camino que conecta v con v1 es tal que h1 ∈ χ(w), debido a la condición de conectividad.",
        "Por lo tanto, debido a la definición de conformidad, el empaque hw seleccionado por ComputeSetPackingk para ser agregado en el vértice w en h∗ debe ser tal que h1 ∈ hw.",
        "Esto se cumple en particular para w = v1.",
        "Contradicción con la definición de v1.",
        "Por lo tanto, h∗ es un empaquetamiento para H. Queda entonces por demostrar que tiene el peso máximo sobre todos los empaquetamientos para H. Con este fin, podemos utilizar la inducción estructural en T para demostrar que, en la fase de abajo hacia arriba, la variable v hv se actualiza para contener el peso del empaquetamiento en las aristas en χ(Tv), que contiene hv y que tiene el peso máximo sobre todos los empaquetamientos para las aristas en χ(Tv).",
        "Entonces, el resultado sigue, ya que en la fase de arriba hacia abajo, el empaquetado hr que da el peso máximo sobre χ(Tr) = E(H) se incluye primero en h∗, y luego se extiende en cada nodo c con el empaquetado hhv,c de forma conforme con hv y de manera que se alcance el valor máximo de v hv.",
        "En cuanto a la complejidad, observe que el paso de inicialización requiere la construcción del conjunto Hv, para cada vértice v, y cada conjunto tiene un tamaño de (|E(H)| + 1)k como máximo.",
        "Luego, la función BottomUp verifica la conformidad entre las estrategias en Hv con las estrategias en Hc, para cada par (v, c) ∈ E, y actualiza el peso v hv.",
        "Estas tareas pueden llevarse a cabo en tiempo O((|E(H)| + 1)2k) y deben repetirse para cada arista en T, es decir, O(|T|) veces.",
        "Finalmente, la función TopDown puede implementarse en tiempo lineal en el tamaño de T, ya que solo requiere actualizar h∗ accediendo a la variable hhv,c.",
        "El resultado anterior muestra que si se proporciona una descomposición de hipertree de ancho k, el problema MaxWSP se puede resolver de manera eficiente.",
        "Además, a diferencia del caso de los grafos de elementos estructurados, es bien sabido que decidir la existencia de una descomposición de hipertree acotada por k y calcular una (si existe alguna) son problemas que pueden resolverse eficientemente en tiempo polinómico [7].",
        "Por lo tanto, el Teorema 4 confirma que la clase C(hw, k) constituye en realidad una clase manejable para el problema de determinación del ganador.",
        "Como muestra el siguiente teorema, para subclases grandes (que dependen solo de cómo se especifica la función de peso), MaxWSP(H, w) es altamente paralelizable.",
        "Llamemos a una función de ponderación suave si es computable en espacio logarítmico y si todos los pesos son polinomiales (y por lo tanto solo requieren O(log n) bits para su representación).",
        "Recuerde que LOGCFL es una clase de complejidad paralela contenida en NC2, cf. [9].",
        "La versión funcional de LOGCFL es LLOGCFL, la cual se obtiene equipando un transductor de espacio logarítmico con un oráculo en LOGCFL.",
        "Teorema 5.",
        "Sea H un hipergrafo en C(hw, k), y sea w una función de ponderación suave para él.",
        "Entonces, MaxWSP(H, w) está en LLOGCFL. 4.",
        "Dadas las descomposiciones de hipertree frente a los grafos de elementos estructurados, y considerando que se ha demostrado que la clase C(hw, k) es una isla de tratabilidad para el problema de determinación del ganador, y dado que se ha demostrado que la clase C(ig, k) no es reconocible eficientemente, uno podría inclinarse a pensar que existen instancias con ancho de hipertree ilimitado, pero que admiten un grafo de elementos de ancho de árbol acotado (por lo que la intratabilidad de los grafos de elementos estructurados residiría en su generalidad).",
        "Sorprendentemente, establecemos que este no es el caso.",
        "La clave de la prueba es primero demostrar que los grafos de elementos estructurados están en correspondencia uno a uno con un tipo especial de descomposiciones de hiperárboles del hipergrafo dual, al que llamaremos estricto.",
        "Entonces, el resultado seguirá al demostrar que las descomposiciones estrictas de hipertree de ancho k son menos potentes que las descomposiciones de hipertree de ancho k. 4.1 Descomposiciones estrictas de hipertree Deje que H sea un hipergrafo, y V ⊆ N(H) sea un conjunto de nodos y X, Y ∈ N(H).",
        "X es [V]-adyacente a Y si existe un borde h ∈ E(H) tal que {X, Y} ⊆ (h - V).",
        "Un camino [V] π de X a Y es una secuencia X = X0, . . . , X = Y de variables tal que: Xi es [V]-adyacente a Xi+1, para cada i ∈ [0... -1].",
        "Un conjunto W ⊆ N(H) de nodos está [V]-conectado si ∀X, Y ∈ W hay un [V]-camino de X a Y.",
        "Un componente [V ] es un conjunto maximal no vacío de nodos W ⊆ (N(H) − V ) que está [V ]-conectado.",
        "Para cualquier componente [V] C, sea E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
        "Definición 2.",
        "Una descomposición de hipertree HD = T, χ, λ de H es estricta si se cumplen las siguientes condiciones: 1. para cada par de vértices r y s en los vértices de T tal que s es un hijo de r, y para cada componente [χ(r)]-Cr.",
        "La intersección de Cr con χ(Ts) es vacía, Cr es un componente de [χ(r) ∩ N(λ(r) ∩ λ(s))]; 2. para cada arista h ∈ E(H), hay un vértice p tal que h ∈ λ(p) y h ⊆ χ(p) (decimos que p cubre fuertemente a h); 3. para cada arista h ∈ E(H), el conjunto {p ∈ vértices(T) | h ∈ λ(p)} induce un subárbol (conectado) de T. La anchura estricta de hipertree shw(H) de H es la anchura mínima sobre todas sus descomposiciones estrictas de hipertree.",
        "La relación básica entre las descomposiciones de hipertree agradables y los grafos de elementos estructurados se muestra en el siguiente teorema.",
        "Teorema 6.",
        "Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H).",
        "Entonces, una k-anchura descomposición en árbol de un grafo de elementos para H existe si y solo si ¯H tiene una (k + 1)-anchura descomposición estricta en hiperárbol.",
        "Se debe tener en cuenta que, en lo que respecta al problema de empaquetamiento de conjuntos ponderados máximo, dado un hipercubo H, siempre podemos asumir que para cada nodo v ∈ N(H), {v} está en E(H).",
        "De hecho, si esta hiperarista no está en el hipercubo, entonces se puede agregar sin pérdida de generalidad, estableciendo w({v}) = 0.",
        "Por lo tanto, dejando que C(shw, k) denote la clase de todos los hipergrafos cuyos hipergrafos duales (asociados con un máximo de 2 términos +1) solo juegan el papel técnico de ocuparse de la diferente definición de ancho para las descomposiciones de árboles y las descomposiciones de hiperárboles. 159 problemas de empaquetamiento de conjuntos ponderados) tienen un ancho de hiperárbol estricto limitado por k, tenemos que C(shw, k + 1) = C(ig, k).",
        "Por definición, las descomposiciones de hipertree estrictas son descomposiciones de hipertree especiales.",
        "De hecho, podemos demostrar que las condiciones adicionales en la Definición 2 inducen una restricción real en el poder de descomposición.",
        "Teorema 7.",
        "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). \n\nC(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
        "Una vista desde la teoría de juegos.",
        "Arrojamos más luz sobre las descomposiciones estrictas de hypertrees al discutir una interesante caracterización basada en el juego estricto de Robber y Marshals, definido adaptando el juego de Robber y Marshals definido en [6], que caracteriza el ancho de hypertree.",
        "El juego se juega en un hipercubo H por un ladrón contra k marshals que actúan en coordinación.",
        "Los alguaciles se mueven en los hiperarcos de H, mientras que el ladrón se mueve en los nodos de H. El ladrón ve hacia dónde los alguaciles tienen la intención de moverse, y reacciona moviéndose a otro nodo que esté conectado con su posición actual y a través de un camino en G(H) que no utilice ningún nodo contenido en un hiperarco que esté ocupado por los alguaciles antes y después de su movimiento; decimos que estos hiperarcos están bloqueados.",
        "Ten en cuenta que en el juego básico definido en [6], al ladrón no se le permite moverse en vértices ocupados por los marshals antes y después de su movimiento, incluso si no pertenecen a hiperarcos bloqueados.",
        "Es importante que los marshals jueguen de manera monótona, es decir, no pueden ocupar un borde que haya sido ocupado previamente en el juego y que actualmente no lo esté.",
        "Los alguaciles ganan el juego si capturan al ladrón, ocupando un borde que cubra un nodo donde se encuentre el ladrón.",
        "De lo contrario, el ladrón gana.",
        "Teorema 8.",
        "Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H).",
        "Entonces, ¯H tiene una descomposición estricta de hipertree de k-anchura si y solo si k marshals pueden ganar el Juego estricto de Robber y Marshals en ¯H, sin importar los movimientos de los ladrones. 5.",
        "CONCLUSIONES Hemos resuelto la pregunta abierta de determinar la complejidad de calcular un grafo de elementos estructurado asociado con un escenario de subasta combinatoria.",
        "El resultado es una mala noticia, ya que resultó que es NP-completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado, incluso para un ancho de árbol de 3.",
        "Motivados por este resultado, investigamos el uso de la descomposición de hiperárboles (en el hipergrafo dual asociado con el escenario) y demostramos que el problema es tratable en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hiperárbol acotado.",
        "Para algunos casos especiales y relevantes, también se discute un algoritmo altamente paralelizable.",
        "Curiosamente, también se descubrió que la clase de grafos de elementos estructurados está adecuadamente contenida en la clase de instancias con ancho de hiperárbol acotado (por lo tanto, la razón de su intratabilidad no es su generalidad).",
        "En particular, este último resultado se establece mostrando una relación precisa entre los grafos de elementos estructurados y formas restringidas de descomposiciones de hiperárboles (en el hipergrafo dual), llamadas descomposiciones de consultas (ver, por ejemplo, [7]).",
        "A la luz de esta observación, notamos que demostrar algunos resultados de aproximabilidad para grafos de elementos estructurados requiere una comprensión profunda de la aproximabilidad de las descomposiciones de consultas, la cual actualmente no se encuentra en la literatura.",
        "Como una vía adicional de investigación, sería relevante mejorar el algoritmo ComputeSetPackingk, por ejemplo, mediante el uso de estructuras de datos especializadas, con el fin de evitar la dependencia cuadrática de (|E(H)| + 1)k.",
        "Finalmente, otra pregunta interesante es evaluar si las técnicas de descomposición estructural discutidas en el artículo pueden ser utilizadas para abordar eficientemente generalizaciones del problema de determinación del ganador.",
        "Por ejemplo, podría ser relevante en varios escenarios de aplicación diseñar algoritmos que puedan encontrar una estrategia de venta cuando hay varias copias del mismo artículo disponibles para la venta, y además cuando el subastador está satisfecho cuando se venden al menos un número dado de copias.",
        "El trabajo de G. Gottlob fue apoyado por el EC3 - Centro de Competencia en Comercio Electrónico (Viena) y por un Premio de Mérito de Investigación Wolfson de la Royal Society.",
        "En particular, este premio permitió a Gottlob invitar a G. Greco para una visita de investigación a Oxford.",
        "Además, G. Greco cuenta con el apoyo de ICAR-CNR y del M.I.U.R. en el marco del proyecto TOCAI.IT. 6.",
        "REFERENCIAS [1] I. Adler, G. Gottlob y M. Grohe.",
        "Anchura de hipertree y invariantes de hipergrafo relacionados.",
        "En Proc. de EUROCOMB05, páginas 5-10, 2005. [2] C. Boutilier.",
        "Resolviendo problemas de subasta combinatoria expresados de manera concisa.",
        "En Proc. de AAAI02, páginas 359-366, 2002. [3] V. Conitzer, J. Derryberry y T. Sandholm.",
        "Subastas combinatorias con grafos de elementos estructurados.",
        "En Proc. de AAAI04, páginas 212-218, 2004. [4] E. M. Eschen y J. P. Sinrad.",
        "Un algoritmo O(n2) para el reconocimiento de grafos de arco circular.",
        "En Proc. de SODA93, páginas 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham.",
        "Domando la complejidad computacional de las subastas combinatorias: Óptimo y aproximado.",
        "En Proc. de IJCAI99, páginas 548-553, 1999. [6] G. Gottlob, N. Leone y F. Scarcello.",
        "Ladrones, marshals y guardias: caracterizaciones lógicas y teóricas de la amplitud de hiperárboles.",
        "Revista de Ciencias de la Computación y de Sistemas, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone y S. Scarcello.",
        "Descomposiciones de hiperárboles y consultas tratables.",
        "Revista de Ciencias de la Computación y de Sistemas, 63(3):579-627, 2002. [8] H. H. Hoos y C. Boutilier.",
        "Resolviendo subastas combinatorias utilizando búsqueda local estocástica.",
        "En Proc. de AAAI00, páginas 22-29, 2000. [9] D. Johnson.",
        "Un catálogo de clases de complejidad.",
        "En P. Cramton, Y. Shoham y R. Steinberg, editores, Manual de Ciencias de la Computación Teórica, Volumen A: Algoritmos y Complejidad, páginas 67-161. 1990. [10] N. Korte y R. H. Mohring.",
        "Un algoritmo incremental de tiempo lineal para reconocer grafos de intervalo.",
        "Revista SIAM sobre Computación, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller y T. Sandholm.",
        "El Problema de Determinación del Ganador.",
        "En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias.",
        "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, y Y. Shoham.",
        "Revelación de la verdad en aproximadamente 160 subastas combinatorias eficientes.",
        "J. ACM, 49(5):577-602, 2002. [13] R. McAfee y J. McMillan.",
        "Analizando la subasta de las ondas aéreas.",
        "Revista de Perspectivas Económicas, 10(1):159-175, 1996. [14] J. McMillan.",
        "Vendiendo derechos de espectro.",
        "Revista de Perspectivas Económicas, 8(3):145-62, 1994. [15] N. Nisan.",
        "Subasta y asignación en subastas combinatorias.",
        "En Proc. de EC00, páginas 1-12, 2000. [16] N. Robertson y P. Seymour.",
        "Menores de grafos ii. Aspectos algorítmicos del ancho de árbol.",
        "Revista de Algoritmos, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec y R. M. Harstad.",
        "Subastas combinatorias computacionalmente manejables.",
        "Ciencia de la Gestión, 44:1131-1147, 1998. [18] T. Sandholm.",
        "Una implementación del protocolo de red de contratos basada en cálculos de costos marginales.",
        "En Proc. de AAAI93, páginas 256-262, 1993. [19] T. Sandholm.",
        "Algoritmo para la determinación óptima del ganador en subastas combinatorias.",
        "Inteligencia Artificial, 135(1-2):1-54, 2002. [20] T. Sandholm.",
        "Algoritmos de determinación de ganadores.",
        "En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias.",
        "MIT Press, 2006. [21] T. Sandholm y S. Suri.",
        "Bob: Mejora en la determinación de ganadores en subastas combinatorias y generalizaciones.",
        "Inteligencia Artificial, 7:33-58, 2003. [22] M. Tennenholtz.",
        "Algunas subastas combinatorias manejables.",
        "En Proc. de AAAI00, páginas 98-103, 2000. [23] E. Zurel y N. Nisan.",
        "Un algoritmo de asignación aproximada eficiente para subastas combinatorias.",
        "En Proc. de EC01, páginas 125-136, 2001. 161"
    ],
    "error_count": 8,
    "keys": {
        "hypergraph": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of <br>hypergraph</br> cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) <br>hypergraph</br> H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a <br>hypergraph</br> H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The <br>hypergraph</br> H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the <br>hypergraph</br> representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a <br>hypergraph</br> H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the <br>hypergraph</br> H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a <br>hypergraph</br> (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a <br>hypergraph</br> H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual <br>hypergraph</br> ¯H instead of the auction <br>hypergraph</br> H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual <br>hypergraph</br>, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a <br>hypergraph</br>.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a <br>hypergraph</br>.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a <br>hypergraph</br> H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a <br>hypergraph</br> HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the <br>hypergraph</br> HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of <br>hypergraph</br> acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a <br>hypergraph</br> H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a <br>hypergraph</br> H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) <br>hypergraph</br> H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A <br>hypergraph</br> H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The <br>hypergraph</br> H I0,B0 reported in Figure 1. (a) is an example acyclic <br>hypergraph</br>.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the <br>hypergraph</br> H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the <br>hypergraph</br> such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the <br>hypergraph</br> H1 in Figure 3. (a) and notice that the <br>hypergraph</br> in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original <br>hypergraph</br> is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual <br>hypergraph</br> and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a <br>hypergraph</br> H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the <br>hypergraph</br> whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a <br>hypergraph</br> and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual <br>hypergraph</br> H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a <br>hypergraph</br> in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual <br>hypergraph</br>, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a <br>hypergraph</br>, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a <br>hypergraph</br> such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a <br>hypergraph</br> H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the <br>hypergraph</br>, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a <br>hypergraph</br> H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a <br>hypergraph</br> such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual <br>hypergraph</br> associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual <br>hypergraph</br>), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related <br>hypergraph</br> Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "We show that the notion of hypertree decomposition, a recently introduced measure of <br>hypergraph</br> cyclicity, turns out to be most useful here.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) <br>hypergraph</br> H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a <br>hypergraph</br> H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "The <br>hypergraph</br> H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "Let us note that the <br>hypergraph</br> representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17])."
            ],
            "translated_annotated_samples": [
                "Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de <br>hipergrafos</br>, resulta ser muy útil aquí.",
                "Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado.",
                "Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un <br>hipergrafo</br> H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}.",
                "El <br>hipercubo</br> H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3.",
                "Cabe destacar que la representación de <br>hipergrafo</br> H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en <br>hipergrafo</br>s (por ejemplo, [17])."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de <br>hipergrafos</br>, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un <br>hipergrafo</br> H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El <br>hipercubo</br> H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. Los algoritmos de tiempo polinómico para encontrar la mejor simplificación del grafo primal solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo. Empaquetamiento de conjuntos ponderado. Cabe destacar que la representación de <br>hipergrafo</br> H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en <br>hipergrafo</br>s (por ejemplo, [17]). ",
            "candidates": [],
            "error": [
                [
                    "hipergrafos",
                    "hipergrafo",
                    "hipercubo",
                    "hipergrafo",
                    "hipergrafo"
                ]
            ]
        },
        "combinatorial auction": {
            "translated_key": "subasta combinatoria",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given <br>combinatorial auction</br>, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a <br>combinatorial auction</br> is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a <br>combinatorial auction</br> I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a <br>combinatorial auction</br> I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a <br>combinatorial auction</br>, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a <br>combinatorial auction</br>, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a <br>combinatorial auction</br> I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a <br>combinatorial auction</br> I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a <br>combinatorial auction</br> has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a <br>combinatorial auction</br> problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a <br>combinatorial auction</br> scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a <br>combinatorial auction</br> has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed <br>combinatorial auction</br> Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "Note that many item graphs might be associated with a given <br>combinatorial auction</br>, depending on the edges selected for guaranteeing the connectedness.",
                "Formally, a <br>combinatorial auction</br> is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a <br>combinatorial auction</br> I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a <br>combinatorial auction</br> I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "However, exponentially many item graphs might be associated with a <br>combinatorial auction</br>, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently."
            ],
            "translated_annotated_samples": [
                "Ten en cuenta que muchos grafos de elementos pueden estar asociados con una <br>subasta combinatoria</br> dada, dependiendo de las aristas seleccionadas para garantizar la conectividad.",
                "Formalmente, una <br>subasta combinatoria</br> es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I.",
                "Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una <br>subasta combinatoria</br> I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}.",
                "El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una <br>subasta combinatoria</br> I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3.",
                "Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una <br>subasta combinatoria</br>, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una <br>subasta combinatoria</br> dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una <br>subasta combinatoria</br> es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una <br>subasta combinatoria</br> I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una <br>subasta combinatoria</br> I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una <br>subasta combinatoria</br>, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "hypertree decomposition": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of <br>hypertree decomposition</br>, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the <br>hypertree decomposition</br> of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of <br>hypertree decomposition</br> of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of <br>hypertree decomposition</br> [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A <br>hypertree decomposition</br> of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width <br>hypertree decomposition</br> of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a <br>hypertree decomposition</br> T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width <br>hypertree decomposition</br> for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 <br>hypertree decomposition</br> on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width <br>hypertree decomposition</br> HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the <br>hypertree decomposition</br> of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width <br>hypertree decomposition</br> HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width <br>hypertree decomposition</br> of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a <br>hypertree decomposition</br> of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded <br>hypertree decomposition</br> and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A <br>hypertree decomposition</br> HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict <br>hypertree decomposition</br> if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of <br>hypertree decomposition</br> (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "We show that the notion of <br>hypertree decomposition</br>, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the <br>hypertree decomposition</br> of dual hypergraphs instead of the treewidth of item graphs.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of <br>hypertree decomposition</br> of the dual hypergraph, which we call strict hypertree decompositions.",
                "To this end, we focus on the notion of <br>hypertree decomposition</br> [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A <br>hypertree decomposition</br> of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width <br>hypertree decomposition</br> of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p)."
            ],
            "translated_annotated_samples": [
                "Mostramos que la noción de <br>descomposición de hiperárboles</br>, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí.",
                "Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la <br>descomposición de hipertree</br> de los hipergrafos duales en lugar de la treewidth de los grafos de elementos.",
                "De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos <br>descomposiciones de hiperárboles</br> estrictas.",
                "Con este fin, nos enfocamos en la noción de <br>descomposición de hiperárboles</br> [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros.",
                "Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p)."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de <br>descomposición de hiperárboles</br>, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. Los algoritmos de tiempo polinómico para encontrar la mejor simplificación del grafo primal solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo. Empaquetamiento de conjuntos ponderado. Cabe destacar que la representación de hipergrafo H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en hipergrafos (por ejemplo, [17]). Formalmente, un empaquetamiento h para un hipergrafo H es un conjunto de hiperarcos de H tal que para cada par h, h ∈ h con h ≠ h, se cumple que h ∩ h = ∅. Si se deja que w sea una función de ponderación para H, es decir, una función computable en tiempo polinómico de E(H) a números racionales, el peso de un empaquetado h es el número racional w(h) = h∈h w(h), donde w({}) = 0. Entonces, el problema de empaquetamiento de conjuntos con peso máximo para H con respecto a w, denotado por MaxWSP(H, w), es el problema de encontrar un empaquetamiento para H que tenga el peso máximo entre todos los empaquetamientos para H. Para ver que MaxWSP es simplemente una formulación diferente para el problema de determinación del ganador, dado una subasta combinatoria I, B, es suficiente definir la función de ponderación w I,B (elemento(Bi)) = pago(Bi). Entonces, el conjunto de soluciones para el problema de empaquetamiento de conjuntos ponderados para H I,B con respecto a w I,B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, B. Ejemplo 2. Considera nuevamente el hipercubo H I0,B0 reportado en la Figura 1.(a). Un ejemplo de empaquetado para H I0, B0 es h = {h1}, que intuitivamente corresponde a un resultado para I0, B0, donde el subastador aceptó la oferta B1. Al asumir que las ofertas B1, B2 y B3 son tales que pay(B1) = pay(B2) = pay(B3), el empaquetado h no es una solución para el problema MaxWSP(H I0,B0 , w I0,B0). De hecho, el empaque h∗ = {h2, h3} es tal que w I0,B0 (h∗ ) > w I0,B0 (h). ¡Contribuciones! El objetivo principal de este artículo es identificar clases grandes y manejables para el problema de determinación del ganador, que además sean reconocibles de forma polinómica. Con este objetivo, primero estudiamos grafos de elementos estructurados y resolvemos el problema abierto en [3]. El resultado es una noticia muy mala: es NP completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado de ancho de árbol 3. De manera más formal, dejando que C(ig, k) denote la clase de todos los hipergrafos que tienen un árbol de ítems con un ancho de árbol limitado por k, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C(ig, 3) es NP-completo. A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que puedan ser verificados en tiempo polinómico y que aún puedan ser utilizados para aislar clases tratables del problema de empaquetamiento de conjuntos con peso máximo o, equivalentemente, el problema de determinación del ganador. Nuestras investigaciones, esta vez, llevaron a noticias muy buenas que se resumen a continuación: Para un hipercubo H, su dual ¯H = (V, E) es tal que los nodos en V están en correspondencia uno a uno con los hiperarcos en H, y para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} está en E. Mostramos que MaxWSP es tratable en la clase de aquellas instancias cuyos hipercubos duales tienen un ancho de hiperárbol[7] limitado por k (abreviado: clase C(hw, k) de hipercubos). Cabe destacar que un problema clave de la tratabilidad es considerar el ancho de hiperárbol del hipergrafo dual ¯H en lugar del hipergrafo de subastas H. De hecho, podemos demostrar que MaxWSP sigue siendo NP-duro incluso cuando H es acíclico (es decir, cuando tiene un ancho de hiperárbol de 1), incluso cuando cada nodo está contenido en un máximo de 3 hiperarcos. Para algunas clases especiales relevantes de hipergrafos en C(hw, k), diseñamos un algoritmo altamente paralelizable para MaxWSP. Específicamente, si las funciones de ponderación se pueden calcular en espacio logarítmico y los pesos son polinomiales (por ejemplo, cuando todos los hiperarcos tienen pesos unitarios y se está interesado en encontrar el empaquetamiento con el máximo número de arcos), demostramos que MaxWSP puede resolverse mediante un algoritmo LOGCFL. Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son reducibles en espacio logarítmico a lenguajes libres de contexto, y que LOGCFL ⊆ NC2 ⊆ P (ver, por ejemplo, [9]). Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la <br>descomposición de hipertree</br> de los hipergrafos duales en lugar de la treewidth de los grafos de elementos. Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados. De hecho, demostramos que clases de instancias estrictamente más grandes son tratables según nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados. De manera intuitiva, la NP-dificultad de reconocer grafos de elementos estructurados de ancho acotado no se debe a su gran generalidad, sino más bien a algunas peculiaridades en su definición. La prueba de los resultados anteriores nos brinda una perspectiva interesante sobre la noción de grafo de elementos estructurados. De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos <br>descomposiciones de hiperárboles</br> estrictas. También se propone una caracterización de juego para la noción de ancho de hiperárbol estricto, que se especializa en el juego de Ladrón y Policías en [6] (propuesto para caracterizar el ancho de hiperárbol), y que aclara los requisitos adicionales sobre las descomposiciones de hiperárboles. El resto del documento está organizado de la siguiente manera. La sección 2 discute la intratabilidad de los grafos de elementos estructurados. La sección 3 presenta el algoritmo de tiempo polinómico para resolver MaxWSP en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hipertree acotado, y discute los casos en los que el algoritmo también es altamente paralelizable. La comparación entre las clases C(ig, k) y C(hw, k) se discute en la Sección 4. Finalmente, en la Sección 5 sacamos nuestras conclusiones también delineando las direcciones para futuras investigaciones. 2. COMPLEJIDAD DE LOS GRAFOS DE ELEMENTOS ESTRUCTURADOS Sea H un hipergrafo. Un grafo G = (V, E) es un grafo de elementos para H si V = N(H) y, para cada h ∈ E(H), el subgrafo de G inducido sobre los nodos en h está conectado. Una clase importante de grafos de elementos es la de grafos de elementos estructurados, es decir, aquellos grafos de elementos que tienen un ancho de árbol acotado como se formaliza a continuación. Una descomposición de árbol [16] de un grafo G = (V, E) es un par T, χ, donde T = (N, F) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjunto de vértices χ(p) ⊆ V, de modo que se satisfacen las siguientes condiciones: (1) para cada vértice b de G, existe un p ∈ N tal que b ∈ χ(p); (2) para cada arista {b, d} ∈ E, existe un p ∈ N tal que {b, d} ⊆ χ(p); (3) para cada vértice b de G, el conjunto {p ∈ N | b ∈ χ(p)} induce un subárbol conectado de T. El ancho de T, χ es el número maxp∈N |χ(p) − 1|. El treewidth de G, denotado por tw(G), es el ancho mínimo sobre todas sus descomposiciones en árboles. El problema de determinación del ganador puede resolverse en tiempo polinómico en grafos de elementos con treewidth acotado [3]. Teorema 1 (cf. [3]). Se tiene una descomposición en árbol de ancho k T, χ de un grafo de elementos para H. Entonces, MaxWSP(H, w) se puede resolver en tiempo O(|T|2 ×(|E(H)|+1)k+1 ). Muchos gráficos de elementos pueden estar asociados con un hipergráfico. Como ejemplo, observe que el grafo de elementos en la Figura 1. (c) tiene un ancho de árbol de 1, mientras que la Figura 1. (d) muestra un grafo de elementos cuyo ancho de árbol es 2. De hecho, era una pregunta abierta si, para una constante k dada, se puede verificar en tiempo polinómico si existe un grafo de ítems de ancho de árbol k, y en caso afirmativo, si dicho grafo de ítems se puede calcular eficientemente. La principal tarea de esta sección es demostrar que la clase C(ig, k) es difícil de reconocer. Teorema 2. Decidir si un hipergrafo H pertenece a C(ig, 3) es NP-difícil. La prueba de este resultado se basa en una reducción elaborada del problema de camino hamiltoniano HP(s, t) que consiste en decidir si hay un camino hamiltoniano desde un nodo s hasta un nodo t en un grafo dirigido G = (N, E). Para ayudar a la intuición, aquí presentamos una descripción general de alto nivel de los principales ingredientes utilizados en la prueba. La idea general es construir un hipercubo HG de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución. Primero, discutimos la forma en que se construye HG. Ver la Figura 2. (a) para una ilustración, donde el grafo G consiste en los nodos s, x, y, y t, y el conjunto de sus aristas es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. De G a HG. Sea G = (N, E) un grafo dirigido. Entonces, el conjunto de nodos en HG es tal que: para cada x ∈ N, N(HG) contiene los nodos bsx, btx, bx, bx, bdx; para cada e = (x, y) ∈ E, N(HG) contiene los nodos nsx, nsx, nty, nty, nsex y ntey. Ningún otro nodo está en N(HG). Los hiperarcos en HG son de tres tipos: 1) para cada x ∈ N, E(HG) contiene los hiperarcos: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, y A3 x = {bx, bx} -nota que estos hiperarcos inducen una clique en los nodos {bx, bx, bdx}; 1 Las pruebas detalladas se pueden encontrar en el Apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf. Figura 2: Prueba del Teorema 2: (a) de G a HG - solo se reportan los hiperarcos en 1) y 2); (b) un esqueleto para una descomposición en árbol TD para HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, y TA3 x = {btx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {btx, bx, bx, bdx}; 2) para cada e = (x, y) ∈ E, E(HG) contiene los hiperarcos: • SHx = {nsx, nsx}; • THy = {nty, nty}; • SEe = {nsx, nse x} y SEe = {nsx, nse x} -nota que estos dos hiperarcos más SHx inducen una clique en los nodos {nsx, nsx, nse x}; • TEe = {nty, nte y} y TEe = {nty, nte y} -nota que estos dos hiperarcos más THy inducen una clique en los nodos {nty, nty, nte y}. Observa que cada uno de los hiperarcos anteriores, excepto aquellos de la forma Sx y Tx, contiene exactamente dos nodos. Como ejemplo de los hiperarcos de tipo 1) y 2), el lector puede referirse a la construcción de ejemplo reportada en la Figura 2. (a), y notar, por ejemplo, que Sx = {bsx, nse2 x, nse3 x} y que Tt = {btt, nte4 t, nte3 t}. 3) finalmente, denotamos por DG al conjunto que contiene los hiperarcos en E(HG) del tercer tipo. En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperarcos que satisfacen las cuatro condiciones que se discuten a continuación. Sea PG el conjunto de los siguientes |PG| ≤ |N| + 3 × |E| pares: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}. Además, sea I(v) el conjunto {h ∈ E(H) | v ∈ h} de los hiperarcos de H que son tocados por v; y, para un conjunto V ⊆ N(H), sea I(V) = v∈V I(v). Entonces, DG tiene que ser un conjunto tal que: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ PG o (β, α) ∈ PG, se cumple: I(α) ∩ DG = ∅; y, (c4) ∀S ⊆ N tal que |S| ≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ PG, se cumple que: I(S) ⊇ DG. De manera intuitiva, el conjunto DG es tal que cada una de sus hiperaristas es tocada exactamente por uno de los dos nodos en cada par de PG, cf. (c1) y (c2). Además, los hiperarcos en DG solo tocan vértices incluidos en al menos un par de PG - cf. (c3); y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se pueden construir a partir de él pertenece a PG - cf. (c4). El lector puede preguntarse ahora si existe un conjunto DG que satisfaga (c1), (c2), (c3) y (c4). En el siguiente lema, respondemos positivamente a esta pregunta y referimos al lector a su demostración para un ejemplo de construcción. Lema 1. Un conjunto DG, con |DG| = 2 × |PG| + 2, que cumple las condiciones (c1), (c2), (c3) y (c4) se puede construir en tiempo O(|PG|2). Ingredientes clave. Ahora estamos en la posición de presentar una visión general de los ingredientes clave de la prueba. Sea G un grafo de elementos arbitrario para HG, y sea TD = T, χ una descomposición de árbol de ancho 3 de G (nota que, debido a las cliques, por ejemplo, en los nodos {bsx, bx, bx, bdx}, cualquier grafo de elementos para HG tiene un ancho de árbol de al menos 3). Hay tres observaciones básicas que sirven para demostrar la corrección de la reducción. Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértices. Específicamente, para cada nodo x ∈ N, TD contiene un vértice bs(x) tal que χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, y un vértice bt(x) tal que χ(bt(x)) ⊇ {btx, bx, bx, bdx}. Y, para cada arista e = (x, y) ∈ E, TD contiene un vértice ns(x,e) tal que χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, y un vértice nt(y,e) tal que χ(nt(y,e)) ⊇ {nte y, nty, nty}. Intuitivamente, se requiere que estos vértices cubran los cliques de HG asociados con los hiperarcos de tipo 1) y 2). Cada uno de estos vértices desempeña un papel específico en la reducción. De hecho, cada arista dirigida e = (x, y) ∈ E está codificada en TD mediante los vértices: ns(x,e), que representan precisamente que e comienza en x; y nt(y,e), que representan precisamente que e termina en y. Además, cada nodo x ∈ N está codificado en TD mediante los vértices: bs(x), que representa el punto de inicio de las aristas que se originan en x; y, bt(x), que representa el punto de terminación de las aristas que terminan en x. Como ejemplo, la Figura 2. (b) muestra el esqueleto de una descomposición de árbol TD. El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el hipercubo HG en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación. La conexión entre bloques y la unicidad de las conexiones: La segunda observación crucial es que en el camino que conecta un vértice de la forma bs(x) (resp., bt(y)) con un vértice de la forma ns(x,e) (resp., nt(y,e)) hay un vértice especial de la forma w(x,y) tal que: χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E. Garantizar la existencia de un vértice así es precisamente el papel que desempeñan los hiperarcos en DG. Los argumentos para la prueba son los siguientes. Primero, observamos que I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} e I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}. Luego, mostramos una propiedad que establece que para un par de vértices consecutivos p y q en el camino que conecta bs(x) y ns(x,e) (resp., bt(y) y nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))). Por lo tanto, tenemos: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (o bien, I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}). Basándose en esta observación, y al explotar las propiedades de los hiperarcos en DG, no es difícil demostrar que cualquier par de vértices consecutivos p y q deben compartir dos nodos de HG formando un par en PG, y ambos deben tocar Sx (resp., Ty). Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w(x,y), en este camino es tal que χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E - para ello, note que nse x ∈ Sx, nte t ∈ Ty, e I(χ(w(x,y))) ⊇ DG. En particular, w(x,y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay otro vértice de la forma w(x,z), para z = y (o bien, w(z,y), para z = x). Para ayudar a la intuición, observamos que tener un vértice de la forma w(x,y) en TD corresponde a la selección de un borde desde el nodo x hasta el nodo y en el camino hamiltoniano. De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de un camino hamiltoniano para G y los vértices de la forma w(x,y). Como ejemplo, en la Figura 2. (b), los vértices de la forma w(s,x), w(x,y) y w(y,t) están en TD, y GT D muestra el camino hamiltoniano correspondiente. Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w(x, y), para una arista e = (x, y) ∈ E no está en TD (es decir, si la arista (x, y) no pertenece al camino hamiltoniano), entonces el bloque correspondiente ns(x, e) (resp., nt(y, e)) puede ser agregado arbitrariamente en el subárbol enraizado en el bloque ns(x, e) (resp., nt(y, e)), donde e es la arista de la forma e = (x, z) (resp., e = (z, y)) tal que w(x, z) (resp., w(z, y)) está en TD. Por ejemplo, la Figura 2. (a) muestra w(x,t), que no se utiliza en TD, y la Figura 2. (b) muestra cómo los bloques ns(x,e3) y nt(t,e3) pueden ser dispuestos en TD para garantizar la condición de conectividad. CASOS TRACTABLES MEDIANTE DESCOMPOSICIONES DE HIPERÁRBOLES Dado que construir grafos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden ser utilizadas para identificar clases de instancias de MaxWSP tratables. Con este fin, nos enfocamos en la noción de <br>descomposición de hiperárboles</br> [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros. Un hypertree para un hipercubo H es un triple T, χ, λ, donde T = (N, E) es un árbol raíz, y χ y λ son funciones de etiquetado que asocian a cada vértice p ∈ N con dos conjuntos χ(p) ⊆ N(H) y λ(p) ⊆ E(H). Si T = (N, E) es un subárbol de T, definimos χ(T) = v∈N χ(v). Denotamos el conjunto de vértices N de T como vertices(T). Además, para cualquier p ∈ N, Tp denota el subárbol de T con raíz en p. Definición 1. Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p). ",
            "candidates": [],
            "error": [
                [
                    "descomposición de hiperárboles",
                    "descomposición de hipertree",
                    "descomposiciones de hiperárboles",
                    "descomposición de hiperárboles"
                ]
            ]
        },
        "well-known mechanisms for resource and task allocation": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are <br>well-known mechanisms for resource and task allocation</br> where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "Combinatorial auctions are <br>well-known mechanisms for resource and task allocation</br> where bidders are allowed to simultaneously bid on combinations of items."
            ],
            "translated_annotated_samples": [
                "Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. Los algoritmos de tiempo polinómico para encontrar la mejor simplificación del grafo primal solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo. Empaquetamiento de conjuntos ponderado. Cabe destacar que la representación de hipergrafo H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en hipergrafos (por ejemplo, [17]). Formalmente, un empaquetamiento h para un hipergrafo H es un conjunto de hiperarcos de H tal que para cada par h, h ∈ h con h ≠ h, se cumple que h ∩ h = ∅. Si se deja que w sea una función de ponderación para H, es decir, una función computable en tiempo polinómico de E(H) a números racionales, el peso de un empaquetado h es el número racional w(h) = h∈h w(h), donde w({}) = 0. Entonces, el problema de empaquetamiento de conjuntos con peso máximo para H con respecto a w, denotado por MaxWSP(H, w), es el problema de encontrar un empaquetamiento para H que tenga el peso máximo entre todos los empaquetamientos para H. Para ver que MaxWSP es simplemente una formulación diferente para el problema de determinación del ganador, dado una subasta combinatoria I, B, es suficiente definir la función de ponderación w I,B (elemento(Bi)) = pago(Bi). Entonces, el conjunto de soluciones para el problema de empaquetamiento de conjuntos ponderados para H I,B con respecto a w I,B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, B. Ejemplo 2. Considera nuevamente el hipercubo H I0,B0 reportado en la Figura 1.(a). Un ejemplo de empaquetado para H I0, B0 es h = {h1}, que intuitivamente corresponde a un resultado para I0, B0, donde el subastador aceptó la oferta B1. Al asumir que las ofertas B1, B2 y B3 son tales que pay(B1) = pay(B2) = pay(B3), el empaquetado h no es una solución para el problema MaxWSP(H I0,B0 , w I0,B0). De hecho, el empaque h∗ = {h2, h3} es tal que w I0,B0 (h∗ ) > w I0,B0 (h). ¡Contribuciones! El objetivo principal de este artículo es identificar clases grandes y manejables para el problema de determinación del ganador, que además sean reconocibles de forma polinómica. Con este objetivo, primero estudiamos grafos de elementos estructurados y resolvemos el problema abierto en [3]. El resultado es una noticia muy mala: es NP completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado de ancho de árbol 3. De manera más formal, dejando que C(ig, k) denote la clase de todos los hipergrafos que tienen un árbol de ítems con un ancho de árbol limitado por k, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C(ig, 3) es NP-completo. A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que puedan ser verificados en tiempo polinómico y que aún puedan ser utilizados para aislar clases tratables del problema de empaquetamiento de conjuntos con peso máximo o, equivalentemente, el problema de determinación del ganador. Nuestras investigaciones, esta vez, llevaron a noticias muy buenas que se resumen a continuación: Para un hipercubo H, su dual ¯H = (V, E) es tal que los nodos en V están en correspondencia uno a uno con los hiperarcos en H, y para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} está en E. Mostramos que MaxWSP es tratable en la clase de aquellas instancias cuyos hipercubos duales tienen un ancho de hiperárbol[7] limitado por k (abreviado: clase C(hw, k) de hipercubos). Cabe destacar que un problema clave de la tratabilidad es considerar el ancho de hiperárbol del hipergrafo dual ¯H en lugar del hipergrafo de subastas H. De hecho, podemos demostrar que MaxWSP sigue siendo NP-duro incluso cuando H es acíclico (es decir, cuando tiene un ancho de hiperárbol de 1), incluso cuando cada nodo está contenido en un máximo de 3 hiperarcos. Para algunas clases especiales relevantes de hipergrafos en C(hw, k), diseñamos un algoritmo altamente paralelizable para MaxWSP. Específicamente, si las funciones de ponderación se pueden calcular en espacio logarítmico y los pesos son polinomiales (por ejemplo, cuando todos los hiperarcos tienen pesos unitarios y se está interesado en encontrar el empaquetamiento con el máximo número de arcos), demostramos que MaxWSP puede resolverse mediante un algoritmo LOGCFL. Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son reducibles en espacio logarítmico a lenguajes libres de contexto, y que LOGCFL ⊆ NC2 ⊆ P (ver, por ejemplo, [9]). Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la descomposición de hipertree de los hipergrafos duales en lugar de la treewidth de los grafos de elementos. Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados. De hecho, demostramos que clases de instancias estrictamente más grandes son tratables según nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados. De manera intuitiva, la NP-dificultad de reconocer grafos de elementos estructurados de ancho acotado no se debe a su gran generalidad, sino más bien a algunas peculiaridades en su definición. La prueba de los resultados anteriores nos brinda una perspectiva interesante sobre la noción de grafo de elementos estructurados. De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos descomposiciones de hiperárboles estrictas. También se propone una caracterización de juego para la noción de ancho de hiperárbol estricto, que se especializa en el juego de Ladrón y Policías en [6] (propuesto para caracterizar el ancho de hiperárbol), y que aclara los requisitos adicionales sobre las descomposiciones de hiperárboles. El resto del documento está organizado de la siguiente manera. La sección 2 discute la intratabilidad de los grafos de elementos estructurados. La sección 3 presenta el algoritmo de tiempo polinómico para resolver MaxWSP en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hipertree acotado, y discute los casos en los que el algoritmo también es altamente paralelizable. La comparación entre las clases C(ig, k) y C(hw, k) se discute en la Sección 4. Finalmente, en la Sección 5 sacamos nuestras conclusiones también delineando las direcciones para futuras investigaciones. 2. COMPLEJIDAD DE LOS GRAFOS DE ELEMENTOS ESTRUCTURADOS Sea H un hipergrafo. Un grafo G = (V, E) es un grafo de elementos para H si V = N(H) y, para cada h ∈ E(H), el subgrafo de G inducido sobre los nodos en h está conectado. Una clase importante de grafos de elementos es la de grafos de elementos estructurados, es decir, aquellos grafos de elementos que tienen un ancho de árbol acotado como se formaliza a continuación. Una descomposición de árbol [16] de un grafo G = (V, E) es un par T, χ, donde T = (N, F) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjunto de vértices χ(p) ⊆ V, de modo que se satisfacen las siguientes condiciones: (1) para cada vértice b de G, existe un p ∈ N tal que b ∈ χ(p); (2) para cada arista {b, d} ∈ E, existe un p ∈ N tal que {b, d} ⊆ χ(p); (3) para cada vértice b de G, el conjunto {p ∈ N | b ∈ χ(p)} induce un subárbol conectado de T. El ancho de T, χ es el número maxp∈N |χ(p) − 1|. El treewidth de G, denotado por tw(G), es el ancho mínimo sobre todas sus descomposiciones en árboles. El problema de determinación del ganador puede resolverse en tiempo polinómico en grafos de elementos con treewidth acotado [3]. Teorema 1 (cf. [3]). Se tiene una descomposición en árbol de ancho k T, χ de un grafo de elementos para H. Entonces, MaxWSP(H, w) se puede resolver en tiempo O(|T|2 ×(|E(H)|+1)k+1 ). Muchos gráficos de elementos pueden estar asociados con un hipergráfico. Como ejemplo, observe que el grafo de elementos en la Figura 1. (c) tiene un ancho de árbol de 1, mientras que la Figura 1. (d) muestra un grafo de elementos cuyo ancho de árbol es 2. De hecho, era una pregunta abierta si, para una constante k dada, se puede verificar en tiempo polinómico si existe un grafo de ítems de ancho de árbol k, y en caso afirmativo, si dicho grafo de ítems se puede calcular eficientemente. La principal tarea de esta sección es demostrar que la clase C(ig, k) es difícil de reconocer. Teorema 2. Decidir si un hipergrafo H pertenece a C(ig, 3) es NP-difícil. La prueba de este resultado se basa en una reducción elaborada del problema de camino hamiltoniano HP(s, t) que consiste en decidir si hay un camino hamiltoniano desde un nodo s hasta un nodo t en un grafo dirigido G = (N, E). Para ayudar a la intuición, aquí presentamos una descripción general de alto nivel de los principales ingredientes utilizados en la prueba. La idea general es construir un hipercubo HG de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución. Primero, discutimos la forma en que se construye HG. Ver la Figura 2. (a) para una ilustración, donde el grafo G consiste en los nodos s, x, y, y t, y el conjunto de sus aristas es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. De G a HG. Sea G = (N, E) un grafo dirigido. Entonces, el conjunto de nodos en HG es tal que: para cada x ∈ N, N(HG) contiene los nodos bsx, btx, bx, bx, bdx; para cada e = (x, y) ∈ E, N(HG) contiene los nodos nsx, nsx, nty, nty, nsex y ntey. Ningún otro nodo está en N(HG). Los hiperarcos en HG son de tres tipos: 1) para cada x ∈ N, E(HG) contiene los hiperarcos: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, y A3 x = {bx, bx} -nota que estos hiperarcos inducen una clique en los nodos {bx, bx, bdx}; 1 Las pruebas detalladas se pueden encontrar en el Apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf. Figura 2: Prueba del Teorema 2: (a) de G a HG - solo se reportan los hiperarcos en 1) y 2); (b) un esqueleto para una descomposición en árbol TD para HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, y TA3 x = {btx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {btx, bx, bx, bdx}; 2) para cada e = (x, y) ∈ E, E(HG) contiene los hiperarcos: • SHx = {nsx, nsx}; • THy = {nty, nty}; • SEe = {nsx, nse x} y SEe = {nsx, nse x} -nota que estos dos hiperarcos más SHx inducen una clique en los nodos {nsx, nsx, nse x}; • TEe = {nty, nte y} y TEe = {nty, nte y} -nota que estos dos hiperarcos más THy inducen una clique en los nodos {nty, nty, nte y}. Observa que cada uno de los hiperarcos anteriores, excepto aquellos de la forma Sx y Tx, contiene exactamente dos nodos. Como ejemplo de los hiperarcos de tipo 1) y 2), el lector puede referirse a la construcción de ejemplo reportada en la Figura 2. (a), y notar, por ejemplo, que Sx = {bsx, nse2 x, nse3 x} y que Tt = {btt, nte4 t, nte3 t}. 3) finalmente, denotamos por DG al conjunto que contiene los hiperarcos en E(HG) del tercer tipo. En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperarcos que satisfacen las cuatro condiciones que se discuten a continuación. Sea PG el conjunto de los siguientes |PG| ≤ |N| + 3 × |E| pares: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}. Además, sea I(v) el conjunto {h ∈ E(H) | v ∈ h} de los hiperarcos de H que son tocados por v; y, para un conjunto V ⊆ N(H), sea I(V) = v∈V I(v). Entonces, DG tiene que ser un conjunto tal que: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ PG o (β, α) ∈ PG, se cumple: I(α) ∩ DG = ∅; y, (c4) ∀S ⊆ N tal que |S| ≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ PG, se cumple que: I(S) ⊇ DG. De manera intuitiva, el conjunto DG es tal que cada una de sus hiperaristas es tocada exactamente por uno de los dos nodos en cada par de PG, cf. (c1) y (c2). Además, los hiperarcos en DG solo tocan vértices incluidos en al menos un par de PG - cf. (c3); y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se pueden construir a partir de él pertenece a PG - cf. (c4). El lector puede preguntarse ahora si existe un conjunto DG que satisfaga (c1), (c2), (c3) y (c4). En el siguiente lema, respondemos positivamente a esta pregunta y referimos al lector a su demostración para un ejemplo de construcción. Lema 1. Un conjunto DG, con |DG| = 2 × |PG| + 2, que cumple las condiciones (c1), (c2), (c3) y (c4) se puede construir en tiempo O(|PG|2). Ingredientes clave. Ahora estamos en la posición de presentar una visión general de los ingredientes clave de la prueba. Sea G un grafo de elementos arbitrario para HG, y sea TD = T, χ una descomposición de árbol de ancho 3 de G (nota que, debido a las cliques, por ejemplo, en los nodos {bsx, bx, bx, bdx}, cualquier grafo de elementos para HG tiene un ancho de árbol de al menos 3). Hay tres observaciones básicas que sirven para demostrar la corrección de la reducción. Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértices. Específicamente, para cada nodo x ∈ N, TD contiene un vértice bs(x) tal que χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, y un vértice bt(x) tal que χ(bt(x)) ⊇ {btx, bx, bx, bdx}. Y, para cada arista e = (x, y) ∈ E, TD contiene un vértice ns(x,e) tal que χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, y un vértice nt(y,e) tal que χ(nt(y,e)) ⊇ {nte y, nty, nty}. Intuitivamente, se requiere que estos vértices cubran los cliques de HG asociados con los hiperarcos de tipo 1) y 2). Cada uno de estos vértices desempeña un papel específico en la reducción. De hecho, cada arista dirigida e = (x, y) ∈ E está codificada en TD mediante los vértices: ns(x,e), que representan precisamente que e comienza en x; y nt(y,e), que representan precisamente que e termina en y. Además, cada nodo x ∈ N está codificado en TD mediante los vértices: bs(x), que representa el punto de inicio de las aristas que se originan en x; y, bt(x), que representa el punto de terminación de las aristas que terminan en x. Como ejemplo, la Figura 2. (b) muestra el esqueleto de una descomposición de árbol TD. El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el hipercubo HG en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación. La conexión entre bloques y la unicidad de las conexiones: La segunda observación crucial es que en el camino que conecta un vértice de la forma bs(x) (resp., bt(y)) con un vértice de la forma ns(x,e) (resp., nt(y,e)) hay un vértice especial de la forma w(x,y) tal que: χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E. Garantizar la existencia de un vértice así es precisamente el papel que desempeñan los hiperarcos en DG. Los argumentos para la prueba son los siguientes. Primero, observamos que I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} e I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}. Luego, mostramos una propiedad que establece que para un par de vértices consecutivos p y q en el camino que conecta bs(x) y ns(x,e) (resp., bt(y) y nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))). Por lo tanto, tenemos: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (o bien, I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}). Basándose en esta observación, y al explotar las propiedades de los hiperarcos en DG, no es difícil demostrar que cualquier par de vértices consecutivos p y q deben compartir dos nodos de HG formando un par en PG, y ambos deben tocar Sx (resp., Ty). Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w(x,y), en este camino es tal que χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E - para ello, note que nse x ∈ Sx, nte t ∈ Ty, e I(χ(w(x,y))) ⊇ DG. En particular, w(x,y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay otro vértice de la forma w(x,z), para z = y (o bien, w(z,y), para z = x). Para ayudar a la intuición, observamos que tener un vértice de la forma w(x,y) en TD corresponde a la selección de un borde desde el nodo x hasta el nodo y en el camino hamiltoniano. De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de un camino hamiltoniano para G y los vértices de la forma w(x,y). Como ejemplo, en la Figura 2. (b), los vértices de la forma w(s,x), w(x,y) y w(y,t) están en TD, y GT D muestra el camino hamiltoniano correspondiente. Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w(x, y), para una arista e = (x, y) ∈ E no está en TD (es decir, si la arista (x, y) no pertenece al camino hamiltoniano), entonces el bloque correspondiente ns(x, e) (resp., nt(y, e)) puede ser agregado arbitrariamente en el subárbol enraizado en el bloque ns(x, e) (resp., nt(y, e)), donde e es la arista de la forma e = (x, z) (resp., e = (z, y)) tal que w(x, z) (resp., w(z, y)) está en TD. Por ejemplo, la Figura 2. (a) muestra w(x,t), que no se utiliza en TD, y la Figura 2. (b) muestra cómo los bloques ns(x,e3) y nt(t,e3) pueden ser dispuestos en TD para garantizar la condición de conectividad. CASOS TRACTABLES MEDIANTE DESCOMPOSICIONES DE HIPERÁRBOLES Dado que construir grafos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden ser utilizadas para identificar clases de instancias de MaxWSP tratables. Con este fin, nos enfocamos en la noción de descomposición de hiperárboles [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros. Un hypertree para un hipercubo H es un triple T, χ, λ, donde T = (N, E) es un árbol raíz, y χ y λ son funciones de etiquetado que asocian a cada vértice p ∈ N con dos conjuntos χ(p) ⊆ N(H) y λ(p) ⊆ E(H). Si T = (N, E) es un subárbol de T, definimos χ(T) = v∈N χ(v). Denotamos el conjunto de vértices N de T como vertices(T). Además, para cualquier p ∈ N, Tp denota el subárbol de T con raíz en p. Definición 1. Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p). El ancho de una descomposición de hipertree T, χ, λ es maxp∈vertices(T )|λ(p)|. El ancho de HYPERTREE hw(H) de H es el ancho mínimo sobre todas sus descomposiciones hypertree. Un hipergrafo H es acíclico si hw(H) = 1. Ejemplo 3. El hipergrafo H I0,B0 reportado en la Figura 1. (a) es un ejemplo de hipergrafo acíclico. En cambio, tanto los hipergráficos H1 y ¯H1 mostrados en la Figura 3. (a) y la Figura 3. (b), respectivamente, no son acíclicos ya que su anchura de hipertiempo es 2. Se reporta una descomposición de hipertree de ancho 2 para ¯H1 en la Figura 3.(c). En particular, observe que H1 se ha obtenido agregando los dos hiperarcos h4 y h5 a H I0,B0 para modelar, por ejemplo, que dos nuevas ofertas, B4 y B5, respectivamente, han sido propuestas al subastador. En lo siguiente, en lugar de trabajar en el hipercampo H asociado con un problema de MaxWSP, trataremos con su dual ¯H, es decir, con el hipercampo tal que sus nodos están en correspondencia uno a uno con los hiperarcos de H, y donde para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} está en E( ¯H). Como ejemplo, el lector puede querer revisar nuevamente el hipercubo H1 en la Figura 3 (a) y notar que el hipercubo en la Figura 3 (b) es de hecho su dual. La razón de esta elección es que imponer restricciones en el hipercubo original garantiza la tratabilidad solo en escenarios muy simples. Teorema 3. En la clase de hipergrafos acíclicos, MaxWSP está (1) en P si cada nodo ocurre en un máximo de dos hiperarcos; y, (2) NP-duro, incluso si cada nodo está contenido en un máximo de tres hiperarcos. 3.1 Descomposición de hiperárboles en el hipergrafo dual y problemas de empaquetamiento tratables Para una constante fija k, sea C(hw, k) la clase de todos los hipergrafos cuyos hipergrafos duales tienen un ancho de hiperárbol limitado por k. El problema de empaquetamiento de conjuntos con peso máximo se puede resolver en tiempo polinómico en la clase C(hw, k) mediante el algoritmo ComputeSetPackingk, mostrado en la Figura 4. El algoritmo recibe como entrada un hipercubo H, una función de ponderación w, y una descomposición de hipertree de ancho k HD = T=(N, E), χ, λ de ¯H. Para cada vértice v ∈ N, sea Hv el hipergrafo cuyo conjunto de nodos N(Hv) ⊆ N(H) coincide con λ(v), y cuyo conjunto de aristas E(Hv) ⊆ E(H) coincide con χ(v). En un paso de inicialización, el algoritmo equipa a cada vértice v con todos los empaquetamientos posibles para Hv, los cuales se almacenan en el conjunto Hv. Se debe tener en cuenta que el tamaño de Hv está limitado por (|E(H)| + 1)k, ya que cada nodo en λ(v) está sin cubrir en un empaquetamiento o está cubierto precisamente por una de las hiperaristas en χ(v) ⊆ E(H). Entonces, ComputeSetPackingk está diseñado para filtrar estos empaquetamientos conservando solo aquellos que se ajusten a algún empaquetamiento para Hc, para cada hijo c de v en T, como se formaliza a continuación. Dejen que hv y hc sean dos empaquetados para Hv y Hc, respectivamente. Decimos que hv se ajusta a hc, indicado por hv ≈ hc si: para cada h ∈ hc ∩ E(Hv), h está en hv; y, para cada h ∈ (E(Hc) − hc), h no está en hv. Ejemplo 4. Considera nuevamente la descomposición de hipertree de ¯H1 reportada en la Figura 3.(c). Luego, el conjunto de todos los empaquetados posibles (que se construyen en el paso de inicialización de ComputeSetPackingk), para cada uno de sus vértices, se reFigure 5: Ejemplo de aplicación del Algoritmo ComputeSetPackingk. 157 Entrada: H, w, y una descomposición de hipertree de ancho k HD = T = (N, E), χ, λ de ¯H; Salida: Una solución para MaxWSP(H, w); var Hv: conjunto de empaquetados para Hv, para cada v ∈ N; h∗: empaquetado para H; v hv: número racional, para cada empaquetado parcial hv para Hv; hhv,c: empaquetado parcial para Hc, para cada empaquetado parcial hv para Hv, y para cada (v, c) ∈ E; -------------------------------------------Procedimiento BottomUp; begin Done := el conjunto de todas las hojas de T; mientras ∃v ∈ T tal que (i) v ∈ Done, y (ii) {c | c es hijo de v} ⊆ Done hacer para cada c tal que (v, c) ∈ E hacer Hv := Hv - {hv | ∃hc ∈ Hc tal que hv ≈ hc}; para cada hv ∈ Hv hacer v hv := w(hv); para cada c tal que (v, c) ∈ E hacer ¯hc := arg maxhc∈Hc|hv≈ hc c hc - w(hc ∩ hv); hhv,c := ¯hc; (* establecer mejor empaquetado *) v hv := v hv + c ¯hc - w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end mientras end; -------------------------------------------begin (* PRINCIPAL *) para cada vértice v en T hacer Hv := {hv empaquetado para Hv}; BottomUp; sea r la raíz de T; ¯hr := arg maxhr∈Hr r hr; h∗ := ¯hr; (* incluir empaquetado *) T opDown(r, hr); return h∗; end. Procedimiento TopDown(v: vértice de N, ¯hv ∈ Hv); comenzar para cada c ∈ N tal que (v, c) ∈ E hacer ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* incluir empaquetado *) TopDown(c, ¯hc); fin para fin; Figura 4: Algoritmo ComputeSetPackingk. representado en la Figura 5.(a). Por ejemplo, la raíz v1 es tal que Hv1 = { {}, {h1}, {h3}, {h5} }. Además, una flecha de un empaque hc a hv indica que hv cumple con hc. Por ejemplo, el lector puede comprobar que el empaquetado {h3} ∈ Hv1 se ajusta al empaquetado {h2, h3} ∈ Hv3, pero no se ajusta a {h1} ∈ Hv3. ¡ComputeSetPackingk construye una solución recorriendo T en dos fases. En la primera fase, los vértices de T se procesan desde las hojas hasta la raíz r, mediante el procedimiento BottomUp. Para cada nodo v que se está procesando, el conjunto Hv se actualiza preliminarmente eliminando todos los empaquetados hv que no cumplen con ningún empaquetado para algunos de los hijos de v. Después de realizar este filtrado, se actualiza el peso hv. De manera intuitiva, v hv almacena el peso del mejor empaquetado parcial para H calculado utilizando solo los hiperarcos que ocurren en χ(Tv). De hecho, si v es una hoja, entonces v hv = w(hv). De lo contrario, para cada hijo c de v en T, v hv se actualiza con el máximo de c hc - w(hc ∩ hv) sobre todos los empaquetados hc que se ajustan a hv (resolviendo empates de forma arbitraria). El empaque ¯hc para el cual se logra este máximo se almacena en la variable hhv,c. En la segunda fase, el árbol T se procesa comenzando desde la raíz. En primer lugar, se selecciona el empaque h∗ que maximiza el peso equipado con los empaques en Hr. Luego, el procedimiento TopDown se utiliza para extender h∗ a todos los otros empaquetamientos parciales para los vértices de T. En particular, en cada vértice v, h∗ se extiende con el empaquetamiento hhv,c, para cada hijo c de v. Ejemplo 5. Supongamos que, en nuestro ejemplo en curso, w(h1) = w(h2) = w(h3) = w(h4) = 1. Luego, una ejecución de ComputeSetPackingk se representa gráficamente en la Figura 5. (b), donde una flecha de un empaquetado hc a un empaquetado hv se utiliza para denotar que hc = hhv,c. Específicamente, las elecciones realizadas durante el cálculo son tales que se calcula el empaquetamiento {h2, h3}. En particular, durante la fase de abajo hacia arriba, tenemos que: (1) se procesa v4 y establecemos v4 {h2} = v4 {h4} = 1 y v4 {} = 0; (2) se procesa v3 y establecemos v3 {h1} = v3 {h3} = 1 y v3 {} = 0; (3) se procesa v2 y establecemos v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 y v3 {} = 0; (4) se procesa v1 y establecemos v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 y v1 {} = 0. Por ejemplo, observe que v1 {h5} = 2 ya que {h5} se ajusta al empaquetado {h4} de Hv2 de tal manera que v2 {h4} = 1. Entonces, al comienzo de la fase de arriba hacia abajo, ComputeSetPackingk selecciona {h3} como un empaquetado para Hv1 y propaga esta elección en el árbol. De manera equivalente, el algoritmo pudo haber elegido {h5}. Como ejemplo adicional, se informa en la Figura 5.(c) la forma en que se obtiene la solución {h1} mediante el algoritmo cuando w(h1) = 5 y w(h2) = w(h3) = w(h4) = 1. Observa que, en esta ocasión, en la fase de arriba hacia abajo, ComputeSetPackingk comienza a seleccionar {h1} como el mejor empaquetado para Hv1. ¡Teorema 4. Sea H un hipergrafo y w una función de ponderación para él. Sea HD = T, χ, λ una descomposición de hipertree completa de ancho k de ¯H. Entonces, ComputeSetPackingk en la entrada H, w y HD produce correctamente una solución para MaxWSP(H, w) en tiempo O(|T| × (|E(H)| + 1)2k. Prueba. [Bosquejo] Observamos que h∗ (calculado por ComputeSetPackingk) es un empaquetamiento para H. De hecho, consideremos un par de hiperarcos h1 y h2 en h∗, y supongamos, para efectos de contradicción, que h1 ∩ h2 = ∅. Sea v1 (resp., v2) un vértice arbitrario de T, para el cual ComputeSetPackingk incluyó h1 (resp., h2) en h∗ en el cálculo de abajo hacia arriba. Por construcción, tenemos h1 ∈ χ(v1) y h2 ∈ χ(v2). Sea I un elemento en h1 ∩ h2. En el hipergrafo dual H, I es un hiperborde en E(¯H) que cubre tanto los nodos h1 como h2. Por lo tanto, por la condición (1) en la Definición 1, existe un vértice v ∈ vértices(T) tal que {h1, h2} ⊆ χ(v). Se debe tener en cuenta que, debido a la condición de conectividad en la Definición 1, también podemos asumir, sin pérdida de generalidad, que v está en el camino que conecta v1 y v2 en T. Sea hv ∈ Hv el elemento añadido por ComputeSetPackingk en h∗ durante la fase de abajo hacia arriba. Dado que los elementos en Hv son empaquetamientos para Hv, se cumple que o bien h1 ∈ hv o h2 ∈ hv. Supongamos, sin pérdida de generalidad, que h1 ∈ hv, y notemos que cada vértice w en T en el camino que conecta v con v1 es tal que h1 ∈ χ(w), debido a la condición de conectividad. Por lo tanto, debido a la definición de conformidad, el empaque hw seleccionado por ComputeSetPackingk para ser agregado en el vértice w en h∗ debe ser tal que h1 ∈ hw. Esto se cumple en particular para w = v1. Contradicción con la definición de v1. Por lo tanto, h∗ es un empaquetamiento para H. Queda entonces por demostrar que tiene el peso máximo sobre todos los empaquetamientos para H. Con este fin, podemos utilizar la inducción estructural en T para demostrar que, en la fase de abajo hacia arriba, la variable v hv se actualiza para contener el peso del empaquetamiento en las aristas en χ(Tv), que contiene hv y que tiene el peso máximo sobre todos los empaquetamientos para las aristas en χ(Tv). Entonces, el resultado sigue, ya que en la fase de arriba hacia abajo, el empaquetado hr que da el peso máximo sobre χ(Tr) = E(H) se incluye primero en h∗, y luego se extiende en cada nodo c con el empaquetado hhv,c de forma conforme con hv y de manera que se alcance el valor máximo de v hv. En cuanto a la complejidad, observe que el paso de inicialización requiere la construcción del conjunto Hv, para cada vértice v, y cada conjunto tiene un tamaño de (|E(H)| + 1)k como máximo. Luego, la función BottomUp verifica la conformidad entre las estrategias en Hv con las estrategias en Hc, para cada par (v, c) ∈ E, y actualiza el peso v hv. Estas tareas pueden llevarse a cabo en tiempo O((|E(H)| + 1)2k) y deben repetirse para cada arista en T, es decir, O(|T|) veces. Finalmente, la función TopDown puede implementarse en tiempo lineal en el tamaño de T, ya que solo requiere actualizar h∗ accediendo a la variable hhv,c. El resultado anterior muestra que si se proporciona una descomposición de hipertree de ancho k, el problema MaxWSP se puede resolver de manera eficiente. Además, a diferencia del caso de los grafos de elementos estructurados, es bien sabido que decidir la existencia de una descomposición de hipertree acotada por k y calcular una (si existe alguna) son problemas que pueden resolverse eficientemente en tiempo polinómico [7]. Por lo tanto, el Teorema 4 confirma que la clase C(hw, k) constituye en realidad una clase manejable para el problema de determinación del ganador. Como muestra el siguiente teorema, para subclases grandes (que dependen solo de cómo se especifica la función de peso), MaxWSP(H, w) es altamente paralelizable. Llamemos a una función de ponderación suave si es computable en espacio logarítmico y si todos los pesos son polinomiales (y por lo tanto solo requieren O(log n) bits para su representación). Recuerde que LOGCFL es una clase de complejidad paralela contenida en NC2, cf. [9]. La versión funcional de LOGCFL es LLOGCFL, la cual se obtiene equipando un transductor de espacio logarítmico con un oráculo en LOGCFL. Teorema 5. Sea H un hipergrafo en C(hw, k), y sea w una función de ponderación suave para él. Entonces, MaxWSP(H, w) está en LLOGCFL. 4. Dadas las descomposiciones de hipertree frente a los grafos de elementos estructurados, y considerando que se ha demostrado que la clase C(hw, k) es una isla de tratabilidad para el problema de determinación del ganador, y dado que se ha demostrado que la clase C(ig, k) no es reconocible eficientemente, uno podría inclinarse a pensar que existen instancias con ancho de hipertree ilimitado, pero que admiten un grafo de elementos de ancho de árbol acotado (por lo que la intratabilidad de los grafos de elementos estructurados residiría en su generalidad). Sorprendentemente, establecemos que este no es el caso. La clave de la prueba es primero demostrar que los grafos de elementos estructurados están en correspondencia uno a uno con un tipo especial de descomposiciones de hiperárboles del hipergrafo dual, al que llamaremos estricto. Entonces, el resultado seguirá al demostrar que las descomposiciones estrictas de hipertree de ancho k son menos potentes que las descomposiciones de hipertree de ancho k. 4.1 Descomposiciones estrictas de hipertree Deje que H sea un hipergrafo, y V ⊆ N(H) sea un conjunto de nodos y X, Y ∈ N(H). X es [V]-adyacente a Y si existe un borde h ∈ E(H) tal que {X, Y} ⊆ (h - V). Un camino [V] π de X a Y es una secuencia X = X0, . . . , X = Y de variables tal que: Xi es [V]-adyacente a Xi+1, para cada i ∈ [0... -1]. Un conjunto W ⊆ N(H) de nodos está [V]-conectado si ∀X, Y ∈ W hay un [V]-camino de X a Y. Un componente [V ] es un conjunto maximal no vacío de nodos W ⊆ (N(H) − V ) que está [V ]-conectado. Para cualquier componente [V] C, sea E(C) = {h ∈ E(H) | h ∩ C = ∅}. Definición 2. Una descomposición de hipertree HD = T, χ, λ de H es estricta si se cumplen las siguientes condiciones: 1. para cada par de vértices r y s en los vértices de T tal que s es un hijo de r, y para cada componente [χ(r)]-Cr. La intersección de Cr con χ(Ts) es vacía, Cr es un componente de [χ(r) ∩ N(λ(r) ∩ λ(s))]; 2. para cada arista h ∈ E(H), hay un vértice p tal que h ∈ λ(p) y h ⊆ χ(p) (decimos que p cubre fuertemente a h); 3. para cada arista h ∈ E(H), el conjunto {p ∈ vértices(T) | h ∈ λ(p)} induce un subárbol (conectado) de T. La anchura estricta de hipertree shw(H) de H es la anchura mínima sobre todas sus descomposiciones estrictas de hipertree. La relación básica entre las descomposiciones de hipertree agradables y los grafos de elementos estructurados se muestra en el siguiente teorema. Teorema 6. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, una k-anchura descomposición en árbol de un grafo de elementos para H existe si y solo si ¯H tiene una (k + 1)-anchura descomposición estricta en hiperárbol. Se debe tener en cuenta que, en lo que respecta al problema de empaquetamiento de conjuntos ponderados máximo, dado un hipercubo H, siempre podemos asumir que para cada nodo v ∈ N(H), {v} está en E(H). De hecho, si esta hiperarista no está en el hipercubo, entonces se puede agregar sin pérdida de generalidad, estableciendo w({v}) = 0. Por lo tanto, dejando que C(shw, k) denote la clase de todos los hipergrafos cuyos hipergrafos duales (asociados con un máximo de 2 términos +1) solo juegan el papel técnico de ocuparse de la diferente definición de ancho para las descomposiciones de árboles y las descomposiciones de hiperárboles. 159 problemas de empaquetamiento de conjuntos ponderados) tienen un ancho de hiperárbol estricto limitado por k, tenemos que C(shw, k + 1) = C(ig, k). Por definición, las descomposiciones de hipertree estrictas son descomposiciones de hipertree especiales. De hecho, podemos demostrar que las condiciones adicionales en la Definición 2 inducen una restricción real en el poder de descomposición. Teorema 7. C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). \n\nC(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). Una vista desde la teoría de juegos. Arrojamos más luz sobre las descomposiciones estrictas de hypertrees al discutir una interesante caracterización basada en el juego estricto de Robber y Marshals, definido adaptando el juego de Robber y Marshals definido en [6], que caracteriza el ancho de hypertree. El juego se juega en un hipercubo H por un ladrón contra k marshals que actúan en coordinación. Los alguaciles se mueven en los hiperarcos de H, mientras que el ladrón se mueve en los nodos de H. El ladrón ve hacia dónde los alguaciles tienen la intención de moverse, y reacciona moviéndose a otro nodo que esté conectado con su posición actual y a través de un camino en G(H) que no utilice ningún nodo contenido en un hiperarco que esté ocupado por los alguaciles antes y después de su movimiento; decimos que estos hiperarcos están bloqueados. Ten en cuenta que en el juego básico definido en [6], al ladrón no se le permite moverse en vértices ocupados por los marshals antes y después de su movimiento, incluso si no pertenecen a hiperarcos bloqueados. Es importante que los marshals jueguen de manera monótona, es decir, no pueden ocupar un borde que haya sido ocupado previamente en el juego y que actualmente no lo esté. Los alguaciles ganan el juego si capturan al ladrón, ocupando un borde que cubra un nodo donde se encuentre el ladrón. De lo contrario, el ladrón gana. Teorema 8. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, ¯H tiene una descomposición estricta de hipertree de k-anchura si y solo si k marshals pueden ganar el Juego estricto de Robber y Marshals en ¯H, sin importar los movimientos de los ladrones. 5. CONCLUSIONES Hemos resuelto la pregunta abierta de determinar la complejidad de calcular un grafo de elementos estructurado asociado con un escenario de subasta combinatoria. El resultado es una mala noticia, ya que resultó que es NP-completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado, incluso para un ancho de árbol de 3. Motivados por este resultado, investigamos el uso de la descomposición de hiperárboles (en el hipergrafo dual asociado con el escenario) y demostramos que el problema es tratable en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hiperárbol acotado. Para algunos casos especiales y relevantes, también se discute un algoritmo altamente paralelizable. Curiosamente, también se descubrió que la clase de grafos de elementos estructurados está adecuadamente contenida en la clase de instancias con ancho de hiperárbol acotado (por lo tanto, la razón de su intratabilidad no es su generalidad). En particular, este último resultado se establece mostrando una relación precisa entre los grafos de elementos estructurados y formas restringidas de descomposiciones de hiperárboles (en el hipergrafo dual), llamadas descomposiciones de consultas (ver, por ejemplo, [7]). A la luz de esta observación, notamos que demostrar algunos resultados de aproximabilidad para grafos de elementos estructurados requiere una comprensión profunda de la aproximabilidad de las descomposiciones de consultas, la cual actualmente no se encuentra en la literatura. Como una vía adicional de investigación, sería relevante mejorar el algoritmo ComputeSetPackingk, por ejemplo, mediante el uso de estructuras de datos especializadas, con el fin de evitar la dependencia cuadrática de (|E(H)| + 1)k. Finalmente, otra pregunta interesante es evaluar si las técnicas de descomposición estructural discutidas en el artículo pueden ser utilizadas para abordar eficientemente generalizaciones del problema de determinación del ganador. Por ejemplo, podría ser relevante en varios escenarios de aplicación diseñar algoritmos que puedan encontrar una estrategia de venta cuando hay varias copias del mismo artículo disponibles para la venta, y además cuando el subastador está satisfecho cuando se venden al menos un número dado de copias. El trabajo de G. Gottlob fue apoyado por el EC3 - Centro de Competencia en Comercio Electrónico (Viena) y por un Premio de Mérito de Investigación Wolfson de la Royal Society. En particular, este premio permitió a Gottlob invitar a G. Greco para una visita de investigación a Oxford. Además, G. Greco cuenta con el apoyo de ICAR-CNR y del M.I.U.R. en el marco del proyecto TOCAI.IT. 6. REFERENCIAS [1] I. Adler, G. Gottlob y M. Grohe. Anchura de hipertree y invariantes de hipergrafo relacionados. En Proc. de EUROCOMB05, páginas 5-10, 2005. [2] C. Boutilier. Resolviendo problemas de subasta combinatoria expresados de manera concisa. En Proc. de AAAI02, páginas 359-366, 2002. [3] V. Conitzer, J. Derryberry y T. Sandholm. Subastas combinatorias con grafos de elementos estructurados. En Proc. de AAAI04, páginas 212-218, 2004. [4] E. M. Eschen y J. P. Sinrad. Un algoritmo O(n2) para el reconocimiento de grafos de arco circular. En Proc. de SODA93, páginas 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Óptimo y aproximado. En Proc. de IJCAI99, páginas 548-553, 1999. [6] G. Gottlob, N. Leone y F. Scarcello. Ladrones, marshals y guardias: caracterizaciones lógicas y teóricas de la amplitud de hiperárboles. Revista de Ciencias de la Computación y de Sistemas, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone y S. Scarcello. Descomposiciones de hiperárboles y consultas tratables. Revista de Ciencias de la Computación y de Sistemas, 63(3):579-627, 2002. [8] H. H. Hoos y C. Boutilier. Resolviendo subastas combinatorias utilizando búsqueda local estocástica. En Proc. de AAAI00, páginas 22-29, 2000. [9] D. Johnson. Un catálogo de clases de complejidad. En P. Cramton, Y. Shoham y R. Steinberg, editores, Manual de Ciencias de la Computación Teórica, Volumen A: Algoritmos y Complejidad, páginas 67-161. 1990. [10] N. Korte y R. H. Mohring. Un algoritmo incremental de tiempo lineal para reconocer grafos de intervalo. Revista SIAM sobre Computación, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller y T. Sandholm. El Problema de Determinación del Ganador. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, y Y. Shoham. Revelación de la verdad en aproximadamente 160 subastas combinatorias eficientes. J. ACM, 49(5):577-602, 2002. [13] R. McAfee y J. McMillan. Analizando la subasta de las ondas aéreas. Revista de Perspectivas Económicas, 10(1):159-175, 1996. [14] J. McMillan. Vendiendo derechos de espectro. Revista de Perspectivas Económicas, 8(3):145-62, 1994. [15] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. de EC00, páginas 1-12, 2000. [16] N. Robertson y P. Seymour. Menores de grafos ii. Aspectos algorítmicos del ancho de árbol. Revista de Algoritmos, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias computacionalmente manejables. Ciencia de la Gestión, 44:1131-1147, 1998. [18] T. Sandholm. Una implementación del protocolo de red de contratos basada en cálculos de costos marginales. En Proc. de AAAI93, páginas 256-262, 1993. [19] T. Sandholm. Algoritmo para la determinación óptima del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, 2002. [20] T. Sandholm. Algoritmos de determinación de ganadores. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [21] T. Sandholm y S. Suri. Bob: Mejora en la determinación de ganadores en subastas combinatorias y generalizaciones. Inteligencia Artificial, 7:33-58, 2003. [22] M. Tennenholtz. Algunas subastas combinatorias manejables. En Proc. de AAAI00, páginas 98-103, 2000. [23] E. Zurel y N. Nisan. Un algoritmo de asignación aproximada eficiente para subastas combinatorias. En Proc. de EC01, páginas 125-136, 2001. 161 ",
            "candidates": [],
            "error": [
                []
            ]
        },
        "hypertree-based decomposition method": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed <br>hypertree-based decomposition method</br> is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "To the contrary, the proposed <br>hypertree-based decomposition method</br> is strictly more general than the method of structured item graphs."
            ],
            "translated_annotated_samples": [
                "Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. Los algoritmos de tiempo polinómico para encontrar la mejor simplificación del grafo primal solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo. Empaquetamiento de conjuntos ponderado. Cabe destacar que la representación de hipergrafo H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en hipergrafos (por ejemplo, [17]). Formalmente, un empaquetamiento h para un hipergrafo H es un conjunto de hiperarcos de H tal que para cada par h, h ∈ h con h ≠ h, se cumple que h ∩ h = ∅. Si se deja que w sea una función de ponderación para H, es decir, una función computable en tiempo polinómico de E(H) a números racionales, el peso de un empaquetado h es el número racional w(h) = h∈h w(h), donde w({}) = 0. Entonces, el problema de empaquetamiento de conjuntos con peso máximo para H con respecto a w, denotado por MaxWSP(H, w), es el problema de encontrar un empaquetamiento para H que tenga el peso máximo entre todos los empaquetamientos para H. Para ver que MaxWSP es simplemente una formulación diferente para el problema de determinación del ganador, dado una subasta combinatoria I, B, es suficiente definir la función de ponderación w I,B (elemento(Bi)) = pago(Bi). Entonces, el conjunto de soluciones para el problema de empaquetamiento de conjuntos ponderados para H I,B con respecto a w I,B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, B. Ejemplo 2. Considera nuevamente el hipercubo H I0,B0 reportado en la Figura 1.(a). Un ejemplo de empaquetado para H I0, B0 es h = {h1}, que intuitivamente corresponde a un resultado para I0, B0, donde el subastador aceptó la oferta B1. Al asumir que las ofertas B1, B2 y B3 son tales que pay(B1) = pay(B2) = pay(B3), el empaquetado h no es una solución para el problema MaxWSP(H I0,B0 , w I0,B0). De hecho, el empaque h∗ = {h2, h3} es tal que w I0,B0 (h∗ ) > w I0,B0 (h). ¡Contribuciones! El objetivo principal de este artículo es identificar clases grandes y manejables para el problema de determinación del ganador, que además sean reconocibles de forma polinómica. Con este objetivo, primero estudiamos grafos de elementos estructurados y resolvemos el problema abierto en [3]. El resultado es una noticia muy mala: es NP completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado de ancho de árbol 3. De manera más formal, dejando que C(ig, k) denote la clase de todos los hipergrafos que tienen un árbol de ítems con un ancho de árbol limitado por k, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C(ig, 3) es NP-completo. A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que puedan ser verificados en tiempo polinómico y que aún puedan ser utilizados para aislar clases tratables del problema de empaquetamiento de conjuntos con peso máximo o, equivalentemente, el problema de determinación del ganador. Nuestras investigaciones, esta vez, llevaron a noticias muy buenas que se resumen a continuación: Para un hipercubo H, su dual ¯H = (V, E) es tal que los nodos en V están en correspondencia uno a uno con los hiperarcos en H, y para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} está en E. Mostramos que MaxWSP es tratable en la clase de aquellas instancias cuyos hipercubos duales tienen un ancho de hiperárbol[7] limitado por k (abreviado: clase C(hw, k) de hipercubos). Cabe destacar que un problema clave de la tratabilidad es considerar el ancho de hiperárbol del hipergrafo dual ¯H en lugar del hipergrafo de subastas H. De hecho, podemos demostrar que MaxWSP sigue siendo NP-duro incluso cuando H es acíclico (es decir, cuando tiene un ancho de hiperárbol de 1), incluso cuando cada nodo está contenido en un máximo de 3 hiperarcos. Para algunas clases especiales relevantes de hipergrafos en C(hw, k), diseñamos un algoritmo altamente paralelizable para MaxWSP. Específicamente, si las funciones de ponderación se pueden calcular en espacio logarítmico y los pesos son polinomiales (por ejemplo, cuando todos los hiperarcos tienen pesos unitarios y se está interesado en encontrar el empaquetamiento con el máximo número de arcos), demostramos que MaxWSP puede resolverse mediante un algoritmo LOGCFL. Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son reducibles en espacio logarítmico a lenguajes libres de contexto, y que LOGCFL ⊆ NC2 ⊆ P (ver, por ejemplo, [9]). Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la descomposición de hipertree de los hipergrafos duales en lugar de la treewidth de los grafos de elementos. Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados. De hecho, demostramos que clases de instancias estrictamente más grandes son tratables según nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados. De manera intuitiva, la NP-dificultad de reconocer grafos de elementos estructurados de ancho acotado no se debe a su gran generalidad, sino más bien a algunas peculiaridades en su definición. La prueba de los resultados anteriores nos brinda una perspectiva interesante sobre la noción de grafo de elementos estructurados. De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos descomposiciones de hiperárboles estrictas. También se propone una caracterización de juego para la noción de ancho de hiperárbol estricto, que se especializa en el juego de Ladrón y Policías en [6] (propuesto para caracterizar el ancho de hiperárbol), y que aclara los requisitos adicionales sobre las descomposiciones de hiperárboles. El resto del documento está organizado de la siguiente manera. La sección 2 discute la intratabilidad de los grafos de elementos estructurados. La sección 3 presenta el algoritmo de tiempo polinómico para resolver MaxWSP en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hipertree acotado, y discute los casos en los que el algoritmo también es altamente paralelizable. La comparación entre las clases C(ig, k) y C(hw, k) se discute en la Sección 4. Finalmente, en la Sección 5 sacamos nuestras conclusiones también delineando las direcciones para futuras investigaciones. 2. COMPLEJIDAD DE LOS GRAFOS DE ELEMENTOS ESTRUCTURADOS Sea H un hipergrafo. Un grafo G = (V, E) es un grafo de elementos para H si V = N(H) y, para cada h ∈ E(H), el subgrafo de G inducido sobre los nodos en h está conectado. Una clase importante de grafos de elementos es la de grafos de elementos estructurados, es decir, aquellos grafos de elementos que tienen un ancho de árbol acotado como se formaliza a continuación. Una descomposición de árbol [16] de un grafo G = (V, E) es un par T, χ, donde T = (N, F) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjunto de vértices χ(p) ⊆ V, de modo que se satisfacen las siguientes condiciones: (1) para cada vértice b de G, existe un p ∈ N tal que b ∈ χ(p); (2) para cada arista {b, d} ∈ E, existe un p ∈ N tal que {b, d} ⊆ χ(p); (3) para cada vértice b de G, el conjunto {p ∈ N | b ∈ χ(p)} induce un subárbol conectado de T. El ancho de T, χ es el número maxp∈N |χ(p) − 1|. El treewidth de G, denotado por tw(G), es el ancho mínimo sobre todas sus descomposiciones en árboles. El problema de determinación del ganador puede resolverse en tiempo polinómico en grafos de elementos con treewidth acotado [3]. Teorema 1 (cf. [3]). Se tiene una descomposición en árbol de ancho k T, χ de un grafo de elementos para H. Entonces, MaxWSP(H, w) se puede resolver en tiempo O(|T|2 ×(|E(H)|+1)k+1 ). Muchos gráficos de elementos pueden estar asociados con un hipergráfico. Como ejemplo, observe que el grafo de elementos en la Figura 1. (c) tiene un ancho de árbol de 1, mientras que la Figura 1. (d) muestra un grafo de elementos cuyo ancho de árbol es 2. De hecho, era una pregunta abierta si, para una constante k dada, se puede verificar en tiempo polinómico si existe un grafo de ítems de ancho de árbol k, y en caso afirmativo, si dicho grafo de ítems se puede calcular eficientemente. La principal tarea de esta sección es demostrar que la clase C(ig, k) es difícil de reconocer. Teorema 2. Decidir si un hipergrafo H pertenece a C(ig, 3) es NP-difícil. La prueba de este resultado se basa en una reducción elaborada del problema de camino hamiltoniano HP(s, t) que consiste en decidir si hay un camino hamiltoniano desde un nodo s hasta un nodo t en un grafo dirigido G = (N, E). Para ayudar a la intuición, aquí presentamos una descripción general de alto nivel de los principales ingredientes utilizados en la prueba. La idea general es construir un hipercubo HG de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución. Primero, discutimos la forma en que se construye HG. Ver la Figura 2. (a) para una ilustración, donde el grafo G consiste en los nodos s, x, y, y t, y el conjunto de sus aristas es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. De G a HG. Sea G = (N, E) un grafo dirigido. Entonces, el conjunto de nodos en HG es tal que: para cada x ∈ N, N(HG) contiene los nodos bsx, btx, bx, bx, bdx; para cada e = (x, y) ∈ E, N(HG) contiene los nodos nsx, nsx, nty, nty, nsex y ntey. Ningún otro nodo está en N(HG). Los hiperarcos en HG son de tres tipos: 1) para cada x ∈ N, E(HG) contiene los hiperarcos: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, y A3 x = {bx, bx} -nota que estos hiperarcos inducen una clique en los nodos {bx, bx, bdx}; 1 Las pruebas detalladas se pueden encontrar en el Apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf. Figura 2: Prueba del Teorema 2: (a) de G a HG - solo se reportan los hiperarcos en 1) y 2); (b) un esqueleto para una descomposición en árbol TD para HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, y TA3 x = {btx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {btx, bx, bx, bdx}; 2) para cada e = (x, y) ∈ E, E(HG) contiene los hiperarcos: • SHx = {nsx, nsx}; • THy = {nty, nty}; • SEe = {nsx, nse x} y SEe = {nsx, nse x} -nota que estos dos hiperarcos más SHx inducen una clique en los nodos {nsx, nsx, nse x}; • TEe = {nty, nte y} y TEe = {nty, nte y} -nota que estos dos hiperarcos más THy inducen una clique en los nodos {nty, nty, nte y}. Observa que cada uno de los hiperarcos anteriores, excepto aquellos de la forma Sx y Tx, contiene exactamente dos nodos. Como ejemplo de los hiperarcos de tipo 1) y 2), el lector puede referirse a la construcción de ejemplo reportada en la Figura 2. (a), y notar, por ejemplo, que Sx = {bsx, nse2 x, nse3 x} y que Tt = {btt, nte4 t, nte3 t}. 3) finalmente, denotamos por DG al conjunto que contiene los hiperarcos en E(HG) del tercer tipo. En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperarcos que satisfacen las cuatro condiciones que se discuten a continuación. Sea PG el conjunto de los siguientes |PG| ≤ |N| + 3 × |E| pares: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}. Además, sea I(v) el conjunto {h ∈ E(H) | v ∈ h} de los hiperarcos de H que son tocados por v; y, para un conjunto V ⊆ N(H), sea I(V) = v∈V I(v). Entonces, DG tiene que ser un conjunto tal que: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ PG o (β, α) ∈ PG, se cumple: I(α) ∩ DG = ∅; y, (c4) ∀S ⊆ N tal que |S| ≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ PG, se cumple que: I(S) ⊇ DG. De manera intuitiva, el conjunto DG es tal que cada una de sus hiperaristas es tocada exactamente por uno de los dos nodos en cada par de PG, cf. (c1) y (c2). Además, los hiperarcos en DG solo tocan vértices incluidos en al menos un par de PG - cf. (c3); y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se pueden construir a partir de él pertenece a PG - cf. (c4). El lector puede preguntarse ahora si existe un conjunto DG que satisfaga (c1), (c2), (c3) y (c4). En el siguiente lema, respondemos positivamente a esta pregunta y referimos al lector a su demostración para un ejemplo de construcción. Lema 1. Un conjunto DG, con |DG| = 2 × |PG| + 2, que cumple las condiciones (c1), (c2), (c3) y (c4) se puede construir en tiempo O(|PG|2). Ingredientes clave. Ahora estamos en la posición de presentar una visión general de los ingredientes clave de la prueba. Sea G un grafo de elementos arbitrario para HG, y sea TD = T, χ una descomposición de árbol de ancho 3 de G (nota que, debido a las cliques, por ejemplo, en los nodos {bsx, bx, bx, bdx}, cualquier grafo de elementos para HG tiene un ancho de árbol de al menos 3). Hay tres observaciones básicas que sirven para demostrar la corrección de la reducción. Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértices. Específicamente, para cada nodo x ∈ N, TD contiene un vértice bs(x) tal que χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, y un vértice bt(x) tal que χ(bt(x)) ⊇ {btx, bx, bx, bdx}. Y, para cada arista e = (x, y) ∈ E, TD contiene un vértice ns(x,e) tal que χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, y un vértice nt(y,e) tal que χ(nt(y,e)) ⊇ {nte y, nty, nty}. Intuitivamente, se requiere que estos vértices cubran los cliques de HG asociados con los hiperarcos de tipo 1) y 2). Cada uno de estos vértices desempeña un papel específico en la reducción. De hecho, cada arista dirigida e = (x, y) ∈ E está codificada en TD mediante los vértices: ns(x,e), que representan precisamente que e comienza en x; y nt(y,e), que representan precisamente que e termina en y. Además, cada nodo x ∈ N está codificado en TD mediante los vértices: bs(x), que representa el punto de inicio de las aristas que se originan en x; y, bt(x), que representa el punto de terminación de las aristas que terminan en x. Como ejemplo, la Figura 2. (b) muestra el esqueleto de una descomposición de árbol TD. El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el hipercubo HG en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación. La conexión entre bloques y la unicidad de las conexiones: La segunda observación crucial es que en el camino que conecta un vértice de la forma bs(x) (resp., bt(y)) con un vértice de la forma ns(x,e) (resp., nt(y,e)) hay un vértice especial de la forma w(x,y) tal que: χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E. Garantizar la existencia de un vértice así es precisamente el papel que desempeñan los hiperarcos en DG. Los argumentos para la prueba son los siguientes. Primero, observamos que I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} e I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}. Luego, mostramos una propiedad que establece que para un par de vértices consecutivos p y q en el camino que conecta bs(x) y ns(x,e) (resp., bt(y) y nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))). Por lo tanto, tenemos: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (o bien, I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}). Basándose en esta observación, y al explotar las propiedades de los hiperarcos en DG, no es difícil demostrar que cualquier par de vértices consecutivos p y q deben compartir dos nodos de HG formando un par en PG, y ambos deben tocar Sx (resp., Ty). Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w(x,y), en este camino es tal que χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E - para ello, note que nse x ∈ Sx, nte t ∈ Ty, e I(χ(w(x,y))) ⊇ DG. En particular, w(x,y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay otro vértice de la forma w(x,z), para z = y (o bien, w(z,y), para z = x). Para ayudar a la intuición, observamos que tener un vértice de la forma w(x,y) en TD corresponde a la selección de un borde desde el nodo x hasta el nodo y en el camino hamiltoniano. De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de un camino hamiltoniano para G y los vértices de la forma w(x,y). Como ejemplo, en la Figura 2. (b), los vértices de la forma w(s,x), w(x,y) y w(y,t) están en TD, y GT D muestra el camino hamiltoniano correspondiente. Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w(x, y), para una arista e = (x, y) ∈ E no está en TD (es decir, si la arista (x, y) no pertenece al camino hamiltoniano), entonces el bloque correspondiente ns(x, e) (resp., nt(y, e)) puede ser agregado arbitrariamente en el subárbol enraizado en el bloque ns(x, e) (resp., nt(y, e)), donde e es la arista de la forma e = (x, z) (resp., e = (z, y)) tal que w(x, z) (resp., w(z, y)) está en TD. Por ejemplo, la Figura 2. (a) muestra w(x,t), que no se utiliza en TD, y la Figura 2. (b) muestra cómo los bloques ns(x,e3) y nt(t,e3) pueden ser dispuestos en TD para garantizar la condición de conectividad. CASOS TRACTABLES MEDIANTE DESCOMPOSICIONES DE HIPERÁRBOLES Dado que construir grafos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden ser utilizadas para identificar clases de instancias de MaxWSP tratables. Con este fin, nos enfocamos en la noción de descomposición de hiperárboles [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros. Un hypertree para un hipercubo H es un triple T, χ, λ, donde T = (N, E) es un árbol raíz, y χ y λ son funciones de etiquetado que asocian a cada vértice p ∈ N con dos conjuntos χ(p) ⊆ N(H) y λ(p) ⊆ E(H). Si T = (N, E) es un subárbol de T, definimos χ(T) = v∈N χ(v). Denotamos el conjunto de vértices N de T como vertices(T). Además, para cualquier p ∈ N, Tp denota el subárbol de T con raíz en p. Definición 1. Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p). El ancho de una descomposición de hipertree T, χ, λ es maxp∈vertices(T )|λ(p)|. El ancho de HYPERTREE hw(H) de H es el ancho mínimo sobre todas sus descomposiciones hypertree. Un hipergrafo H es acíclico si hw(H) = 1. Ejemplo 3. El hipergrafo H I0,B0 reportado en la Figura 1. (a) es un ejemplo de hipergrafo acíclico. En cambio, tanto los hipergráficos H1 y ¯H1 mostrados en la Figura 3. (a) y la Figura 3. (b), respectivamente, no son acíclicos ya que su anchura de hipertiempo es 2. Se reporta una descomposición de hipertree de ancho 2 para ¯H1 en la Figura 3.(c). En particular, observe que H1 se ha obtenido agregando los dos hiperarcos h4 y h5 a H I0,B0 para modelar, por ejemplo, que dos nuevas ofertas, B4 y B5, respectivamente, han sido propuestas al subastador. En lo siguiente, en lugar de trabajar en el hipercampo H asociado con un problema de MaxWSP, trataremos con su dual ¯H, es decir, con el hipercampo tal que sus nodos están en correspondencia uno a uno con los hiperarcos de H, y donde para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} está en E( ¯H). Como ejemplo, el lector puede querer revisar nuevamente el hipercubo H1 en la Figura 3 (a) y notar que el hipercubo en la Figura 3 (b) es de hecho su dual. La razón de esta elección es que imponer restricciones en el hipercubo original garantiza la tratabilidad solo en escenarios muy simples. Teorema 3. En la clase de hipergrafos acíclicos, MaxWSP está (1) en P si cada nodo ocurre en un máximo de dos hiperarcos; y, (2) NP-duro, incluso si cada nodo está contenido en un máximo de tres hiperarcos. 3.1 Descomposición de hiperárboles en el hipergrafo dual y problemas de empaquetamiento tratables Para una constante fija k, sea C(hw, k) la clase de todos los hipergrafos cuyos hipergrafos duales tienen un ancho de hiperárbol limitado por k. El problema de empaquetamiento de conjuntos con peso máximo se puede resolver en tiempo polinómico en la clase C(hw, k) mediante el algoritmo ComputeSetPackingk, mostrado en la Figura 4. El algoritmo recibe como entrada un hipercubo H, una función de ponderación w, y una descomposición de hipertree de ancho k HD = T=(N, E), χ, λ de ¯H. Para cada vértice v ∈ N, sea Hv el hipergrafo cuyo conjunto de nodos N(Hv) ⊆ N(H) coincide con λ(v), y cuyo conjunto de aristas E(Hv) ⊆ E(H) coincide con χ(v). En un paso de inicialización, el algoritmo equipa a cada vértice v con todos los empaquetamientos posibles para Hv, los cuales se almacenan en el conjunto Hv. Se debe tener en cuenta que el tamaño de Hv está limitado por (|E(H)| + 1)k, ya que cada nodo en λ(v) está sin cubrir en un empaquetamiento o está cubierto precisamente por una de las hiperaristas en χ(v) ⊆ E(H). Entonces, ComputeSetPackingk está diseñado para filtrar estos empaquetamientos conservando solo aquellos que se ajusten a algún empaquetamiento para Hc, para cada hijo c de v en T, como se formaliza a continuación. Dejen que hv y hc sean dos empaquetados para Hv y Hc, respectivamente. Decimos que hv se ajusta a hc, indicado por hv ≈ hc si: para cada h ∈ hc ∩ E(Hv), h está en hv; y, para cada h ∈ (E(Hc) − hc), h no está en hv. Ejemplo 4. Considera nuevamente la descomposición de hipertree de ¯H1 reportada en la Figura 3.(c). Luego, el conjunto de todos los empaquetados posibles (que se construyen en el paso de inicialización de ComputeSetPackingk), para cada uno de sus vértices, se reFigure 5: Ejemplo de aplicación del Algoritmo ComputeSetPackingk. 157 Entrada: H, w, y una descomposición de hipertree de ancho k HD = T = (N, E), χ, λ de ¯H; Salida: Una solución para MaxWSP(H, w); var Hv: conjunto de empaquetados para Hv, para cada v ∈ N; h∗: empaquetado para H; v hv: número racional, para cada empaquetado parcial hv para Hv; hhv,c: empaquetado parcial para Hc, para cada empaquetado parcial hv para Hv, y para cada (v, c) ∈ E; -------------------------------------------Procedimiento BottomUp; begin Done := el conjunto de todas las hojas de T; mientras ∃v ∈ T tal que (i) v ∈ Done, y (ii) {c | c es hijo de v} ⊆ Done hacer para cada c tal que (v, c) ∈ E hacer Hv := Hv - {hv | ∃hc ∈ Hc tal que hv ≈ hc}; para cada hv ∈ Hv hacer v hv := w(hv); para cada c tal que (v, c) ∈ E hacer ¯hc := arg maxhc∈Hc|hv≈ hc c hc - w(hc ∩ hv); hhv,c := ¯hc; (* establecer mejor empaquetado *) v hv := v hv + c ¯hc - w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end mientras end; -------------------------------------------begin (* PRINCIPAL *) para cada vértice v en T hacer Hv := {hv empaquetado para Hv}; BottomUp; sea r la raíz de T; ¯hr := arg maxhr∈Hr r hr; h∗ := ¯hr; (* incluir empaquetado *) T opDown(r, hr); return h∗; end. Procedimiento TopDown(v: vértice de N, ¯hv ∈ Hv); comenzar para cada c ∈ N tal que (v, c) ∈ E hacer ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* incluir empaquetado *) TopDown(c, ¯hc); fin para fin; Figura 4: Algoritmo ComputeSetPackingk. representado en la Figura 5.(a). Por ejemplo, la raíz v1 es tal que Hv1 = { {}, {h1}, {h3}, {h5} }. Además, una flecha de un empaque hc a hv indica que hv cumple con hc. Por ejemplo, el lector puede comprobar que el empaquetado {h3} ∈ Hv1 se ajusta al empaquetado {h2, h3} ∈ Hv3, pero no se ajusta a {h1} ∈ Hv3. ¡ComputeSetPackingk construye una solución recorriendo T en dos fases. En la primera fase, los vértices de T se procesan desde las hojas hasta la raíz r, mediante el procedimiento BottomUp. Para cada nodo v que se está procesando, el conjunto Hv se actualiza preliminarmente eliminando todos los empaquetados hv que no cumplen con ningún empaquetado para algunos de los hijos de v. Después de realizar este filtrado, se actualiza el peso hv. De manera intuitiva, v hv almacena el peso del mejor empaquetado parcial para H calculado utilizando solo los hiperarcos que ocurren en χ(Tv). De hecho, si v es una hoja, entonces v hv = w(hv). De lo contrario, para cada hijo c de v en T, v hv se actualiza con el máximo de c hc - w(hc ∩ hv) sobre todos los empaquetados hc que se ajustan a hv (resolviendo empates de forma arbitraria). El empaque ¯hc para el cual se logra este máximo se almacena en la variable hhv,c. En la segunda fase, el árbol T se procesa comenzando desde la raíz. En primer lugar, se selecciona el empaque h∗ que maximiza el peso equipado con los empaques en Hr. Luego, el procedimiento TopDown se utiliza para extender h∗ a todos los otros empaquetamientos parciales para los vértices de T. En particular, en cada vértice v, h∗ se extiende con el empaquetamiento hhv,c, para cada hijo c de v. Ejemplo 5. Supongamos que, en nuestro ejemplo en curso, w(h1) = w(h2) = w(h3) = w(h4) = 1. Luego, una ejecución de ComputeSetPackingk se representa gráficamente en la Figura 5. (b), donde una flecha de un empaquetado hc a un empaquetado hv se utiliza para denotar que hc = hhv,c. Específicamente, las elecciones realizadas durante el cálculo son tales que se calcula el empaquetamiento {h2, h3}. En particular, durante la fase de abajo hacia arriba, tenemos que: (1) se procesa v4 y establecemos v4 {h2} = v4 {h4} = 1 y v4 {} = 0; (2) se procesa v3 y establecemos v3 {h1} = v3 {h3} = 1 y v3 {} = 0; (3) se procesa v2 y establecemos v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 y v3 {} = 0; (4) se procesa v1 y establecemos v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 y v1 {} = 0. Por ejemplo, observe que v1 {h5} = 2 ya que {h5} se ajusta al empaquetado {h4} de Hv2 de tal manera que v2 {h4} = 1. Entonces, al comienzo de la fase de arriba hacia abajo, ComputeSetPackingk selecciona {h3} como un empaquetado para Hv1 y propaga esta elección en el árbol. De manera equivalente, el algoritmo pudo haber elegido {h5}. Como ejemplo adicional, se informa en la Figura 5.(c) la forma en que se obtiene la solución {h1} mediante el algoritmo cuando w(h1) = 5 y w(h2) = w(h3) = w(h4) = 1. Observa que, en esta ocasión, en la fase de arriba hacia abajo, ComputeSetPackingk comienza a seleccionar {h1} como el mejor empaquetado para Hv1. ¡Teorema 4. Sea H un hipergrafo y w una función de ponderación para él. Sea HD = T, χ, λ una descomposición de hipertree completa de ancho k de ¯H. Entonces, ComputeSetPackingk en la entrada H, w y HD produce correctamente una solución para MaxWSP(H, w) en tiempo O(|T| × (|E(H)| + 1)2k. Prueba. [Bosquejo] Observamos que h∗ (calculado por ComputeSetPackingk) es un empaquetamiento para H. De hecho, consideremos un par de hiperarcos h1 y h2 en h∗, y supongamos, para efectos de contradicción, que h1 ∩ h2 = ∅. Sea v1 (resp., v2) un vértice arbitrario de T, para el cual ComputeSetPackingk incluyó h1 (resp., h2) en h∗ en el cálculo de abajo hacia arriba. Por construcción, tenemos h1 ∈ χ(v1) y h2 ∈ χ(v2). Sea I un elemento en h1 ∩ h2. En el hipergrafo dual H, I es un hiperborde en E(¯H) que cubre tanto los nodos h1 como h2. Por lo tanto, por la condición (1) en la Definición 1, existe un vértice v ∈ vértices(T) tal que {h1, h2} ⊆ χ(v). Se debe tener en cuenta que, debido a la condición de conectividad en la Definición 1, también podemos asumir, sin pérdida de generalidad, que v está en el camino que conecta v1 y v2 en T. Sea hv ∈ Hv el elemento añadido por ComputeSetPackingk en h∗ durante la fase de abajo hacia arriba. Dado que los elementos en Hv son empaquetamientos para Hv, se cumple que o bien h1 ∈ hv o h2 ∈ hv. Supongamos, sin pérdida de generalidad, que h1 ∈ hv, y notemos que cada vértice w en T en el camino que conecta v con v1 es tal que h1 ∈ χ(w), debido a la condición de conectividad. Por lo tanto, debido a la definición de conformidad, el empaque hw seleccionado por ComputeSetPackingk para ser agregado en el vértice w en h∗ debe ser tal que h1 ∈ hw. Esto se cumple en particular para w = v1. Contradicción con la definición de v1. Por lo tanto, h∗ es un empaquetamiento para H. Queda entonces por demostrar que tiene el peso máximo sobre todos los empaquetamientos para H. Con este fin, podemos utilizar la inducción estructural en T para demostrar que, en la fase de abajo hacia arriba, la variable v hv se actualiza para contener el peso del empaquetamiento en las aristas en χ(Tv), que contiene hv y que tiene el peso máximo sobre todos los empaquetamientos para las aristas en χ(Tv). Entonces, el resultado sigue, ya que en la fase de arriba hacia abajo, el empaquetado hr que da el peso máximo sobre χ(Tr) = E(H) se incluye primero en h∗, y luego se extiende en cada nodo c con el empaquetado hhv,c de forma conforme con hv y de manera que se alcance el valor máximo de v hv. En cuanto a la complejidad, observe que el paso de inicialización requiere la construcción del conjunto Hv, para cada vértice v, y cada conjunto tiene un tamaño de (|E(H)| + 1)k como máximo. Luego, la función BottomUp verifica la conformidad entre las estrategias en Hv con las estrategias en Hc, para cada par (v, c) ∈ E, y actualiza el peso v hv. Estas tareas pueden llevarse a cabo en tiempo O((|E(H)| + 1)2k) y deben repetirse para cada arista en T, es decir, O(|T|) veces. Finalmente, la función TopDown puede implementarse en tiempo lineal en el tamaño de T, ya que solo requiere actualizar h∗ accediendo a la variable hhv,c. El resultado anterior muestra que si se proporciona una descomposición de hipertree de ancho k, el problema MaxWSP se puede resolver de manera eficiente. Además, a diferencia del caso de los grafos de elementos estructurados, es bien sabido que decidir la existencia de una descomposición de hipertree acotada por k y calcular una (si existe alguna) son problemas que pueden resolverse eficientemente en tiempo polinómico [7]. Por lo tanto, el Teorema 4 confirma que la clase C(hw, k) constituye en realidad una clase manejable para el problema de determinación del ganador. Como muestra el siguiente teorema, para subclases grandes (que dependen solo de cómo se especifica la función de peso), MaxWSP(H, w) es altamente paralelizable. Llamemos a una función de ponderación suave si es computable en espacio logarítmico y si todos los pesos son polinomiales (y por lo tanto solo requieren O(log n) bits para su representación). Recuerde que LOGCFL es una clase de complejidad paralela contenida en NC2, cf. [9]. La versión funcional de LOGCFL es LLOGCFL, la cual se obtiene equipando un transductor de espacio logarítmico con un oráculo en LOGCFL. Teorema 5. Sea H un hipergrafo en C(hw, k), y sea w una función de ponderación suave para él. Entonces, MaxWSP(H, w) está en LLOGCFL. 4. Dadas las descomposiciones de hipertree frente a los grafos de elementos estructurados, y considerando que se ha demostrado que la clase C(hw, k) es una isla de tratabilidad para el problema de determinación del ganador, y dado que se ha demostrado que la clase C(ig, k) no es reconocible eficientemente, uno podría inclinarse a pensar que existen instancias con ancho de hipertree ilimitado, pero que admiten un grafo de elementos de ancho de árbol acotado (por lo que la intratabilidad de los grafos de elementos estructurados residiría en su generalidad). Sorprendentemente, establecemos que este no es el caso. La clave de la prueba es primero demostrar que los grafos de elementos estructurados están en correspondencia uno a uno con un tipo especial de descomposiciones de hiperárboles del hipergrafo dual, al que llamaremos estricto. Entonces, el resultado seguirá al demostrar que las descomposiciones estrictas de hipertree de ancho k son menos potentes que las descomposiciones de hipertree de ancho k. 4.1 Descomposiciones estrictas de hipertree Deje que H sea un hipergrafo, y V ⊆ N(H) sea un conjunto de nodos y X, Y ∈ N(H). X es [V]-adyacente a Y si existe un borde h ∈ E(H) tal que {X, Y} ⊆ (h - V). Un camino [V] π de X a Y es una secuencia X = X0, . . . , X = Y de variables tal que: Xi es [V]-adyacente a Xi+1, para cada i ∈ [0... -1]. Un conjunto W ⊆ N(H) de nodos está [V]-conectado si ∀X, Y ∈ W hay un [V]-camino de X a Y. Un componente [V ] es un conjunto maximal no vacío de nodos W ⊆ (N(H) − V ) que está [V ]-conectado. Para cualquier componente [V] C, sea E(C) = {h ∈ E(H) | h ∩ C = ∅}. Definición 2. Una descomposición de hipertree HD = T, χ, λ de H es estricta si se cumplen las siguientes condiciones: 1. para cada par de vértices r y s en los vértices de T tal que s es un hijo de r, y para cada componente [χ(r)]-Cr. La intersección de Cr con χ(Ts) es vacía, Cr es un componente de [χ(r) ∩ N(λ(r) ∩ λ(s))]; 2. para cada arista h ∈ E(H), hay un vértice p tal que h ∈ λ(p) y h ⊆ χ(p) (decimos que p cubre fuertemente a h); 3. para cada arista h ∈ E(H), el conjunto {p ∈ vértices(T) | h ∈ λ(p)} induce un subárbol (conectado) de T. La anchura estricta de hipertree shw(H) de H es la anchura mínima sobre todas sus descomposiciones estrictas de hipertree. La relación básica entre las descomposiciones de hipertree agradables y los grafos de elementos estructurados se muestra en el siguiente teorema. Teorema 6. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, una k-anchura descomposición en árbol de un grafo de elementos para H existe si y solo si ¯H tiene una (k + 1)-anchura descomposición estricta en hiperárbol. Se debe tener en cuenta que, en lo que respecta al problema de empaquetamiento de conjuntos ponderados máximo, dado un hipercubo H, siempre podemos asumir que para cada nodo v ∈ N(H), {v} está en E(H). De hecho, si esta hiperarista no está en el hipercubo, entonces se puede agregar sin pérdida de generalidad, estableciendo w({v}) = 0. Por lo tanto, dejando que C(shw, k) denote la clase de todos los hipergrafos cuyos hipergrafos duales (asociados con un máximo de 2 términos +1) solo juegan el papel técnico de ocuparse de la diferente definición de ancho para las descomposiciones de árboles y las descomposiciones de hiperárboles. 159 problemas de empaquetamiento de conjuntos ponderados) tienen un ancho de hiperárbol estricto limitado por k, tenemos que C(shw, k + 1) = C(ig, k). Por definición, las descomposiciones de hipertree estrictas son descomposiciones de hipertree especiales. De hecho, podemos demostrar que las condiciones adicionales en la Definición 2 inducen una restricción real en el poder de descomposición. Teorema 7. C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). \n\nC(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). Una vista desde la teoría de juegos. Arrojamos más luz sobre las descomposiciones estrictas de hypertrees al discutir una interesante caracterización basada en el juego estricto de Robber y Marshals, definido adaptando el juego de Robber y Marshals definido en [6], que caracteriza el ancho de hypertree. El juego se juega en un hipercubo H por un ladrón contra k marshals que actúan en coordinación. Los alguaciles se mueven en los hiperarcos de H, mientras que el ladrón se mueve en los nodos de H. El ladrón ve hacia dónde los alguaciles tienen la intención de moverse, y reacciona moviéndose a otro nodo que esté conectado con su posición actual y a través de un camino en G(H) que no utilice ningún nodo contenido en un hiperarco que esté ocupado por los alguaciles antes y después de su movimiento; decimos que estos hiperarcos están bloqueados. Ten en cuenta que en el juego básico definido en [6], al ladrón no se le permite moverse en vértices ocupados por los marshals antes y después de su movimiento, incluso si no pertenecen a hiperarcos bloqueados. Es importante que los marshals jueguen de manera monótona, es decir, no pueden ocupar un borde que haya sido ocupado previamente en el juego y que actualmente no lo esté. Los alguaciles ganan el juego si capturan al ladrón, ocupando un borde que cubra un nodo donde se encuentre el ladrón. De lo contrario, el ladrón gana. Teorema 8. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, ¯H tiene una descomposición estricta de hipertree de k-anchura si y solo si k marshals pueden ganar el Juego estricto de Robber y Marshals en ¯H, sin importar los movimientos de los ladrones. 5. CONCLUSIONES Hemos resuelto la pregunta abierta de determinar la complejidad de calcular un grafo de elementos estructurado asociado con un escenario de subasta combinatoria. El resultado es una mala noticia, ya que resultó que es NP-completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado, incluso para un ancho de árbol de 3. Motivados por este resultado, investigamos el uso de la descomposición de hiperárboles (en el hipergrafo dual asociado con el escenario) y demostramos que el problema es tratable en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hiperárbol acotado. Para algunos casos especiales y relevantes, también se discute un algoritmo altamente paralelizable. Curiosamente, también se descubrió que la clase de grafos de elementos estructurados está adecuadamente contenida en la clase de instancias con ancho de hiperárbol acotado (por lo tanto, la razón de su intratabilidad no es su generalidad). En particular, este último resultado se establece mostrando una relación precisa entre los grafos de elementos estructurados y formas restringidas de descomposiciones de hiperárboles (en el hipergrafo dual), llamadas descomposiciones de consultas (ver, por ejemplo, [7]). A la luz de esta observación, notamos que demostrar algunos resultados de aproximabilidad para grafos de elementos estructurados requiere una comprensión profunda de la aproximabilidad de las descomposiciones de consultas, la cual actualmente no se encuentra en la literatura. Como una vía adicional de investigación, sería relevante mejorar el algoritmo ComputeSetPackingk, por ejemplo, mediante el uso de estructuras de datos especializadas, con el fin de evitar la dependencia cuadrática de (|E(H)| + 1)k. Finalmente, otra pregunta interesante es evaluar si las técnicas de descomposición estructural discutidas en el artículo pueden ser utilizadas para abordar eficientemente generalizaciones del problema de determinación del ganador. Por ejemplo, podría ser relevante en varios escenarios de aplicación diseñar algoritmos que puedan encontrar una estrategia de venta cuando hay varias copias del mismo artículo disponibles para la venta, y además cuando el subastador está satisfecho cuando se venden al menos un número dado de copias. El trabajo de G. Gottlob fue apoyado por el EC3 - Centro de Competencia en Comercio Electrónico (Viena) y por un Premio de Mérito de Investigación Wolfson de la Royal Society. En particular, este premio permitió a Gottlob invitar a G. Greco para una visita de investigación a Oxford. Además, G. Greco cuenta con el apoyo de ICAR-CNR y del M.I.U.R. en el marco del proyecto TOCAI.IT. 6. REFERENCIAS [1] I. Adler, G. Gottlob y M. Grohe. Anchura de hipertree y invariantes de hipergrafo relacionados. En Proc. de EUROCOMB05, páginas 5-10, 2005. [2] C. Boutilier. Resolviendo problemas de subasta combinatoria expresados de manera concisa. En Proc. de AAAI02, páginas 359-366, 2002. [3] V. Conitzer, J. Derryberry y T. Sandholm. Subastas combinatorias con grafos de elementos estructurados. En Proc. de AAAI04, páginas 212-218, 2004. [4] E. M. Eschen y J. P. Sinrad. Un algoritmo O(n2) para el reconocimiento de grafos de arco circular. En Proc. de SODA93, páginas 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Óptimo y aproximado. En Proc. de IJCAI99, páginas 548-553, 1999. [6] G. Gottlob, N. Leone y F. Scarcello. Ladrones, marshals y guardias: caracterizaciones lógicas y teóricas de la amplitud de hiperárboles. Revista de Ciencias de la Computación y de Sistemas, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone y S. Scarcello. Descomposiciones de hiperárboles y consultas tratables. Revista de Ciencias de la Computación y de Sistemas, 63(3):579-627, 2002. [8] H. H. Hoos y C. Boutilier. Resolviendo subastas combinatorias utilizando búsqueda local estocástica. En Proc. de AAAI00, páginas 22-29, 2000. [9] D. Johnson. Un catálogo de clases de complejidad. En P. Cramton, Y. Shoham y R. Steinberg, editores, Manual de Ciencias de la Computación Teórica, Volumen A: Algoritmos y Complejidad, páginas 67-161. 1990. [10] N. Korte y R. H. Mohring. Un algoritmo incremental de tiempo lineal para reconocer grafos de intervalo. Revista SIAM sobre Computación, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller y T. Sandholm. El Problema de Determinación del Ganador. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, y Y. Shoham. Revelación de la verdad en aproximadamente 160 subastas combinatorias eficientes. J. ACM, 49(5):577-602, 2002. [13] R. McAfee y J. McMillan. Analizando la subasta de las ondas aéreas. Revista de Perspectivas Económicas, 10(1):159-175, 1996. [14] J. McMillan. Vendiendo derechos de espectro. Revista de Perspectivas Económicas, 8(3):145-62, 1994. [15] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. de EC00, páginas 1-12, 2000. [16] N. Robertson y P. Seymour. Menores de grafos ii. Aspectos algorítmicos del ancho de árbol. Revista de Algoritmos, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias computacionalmente manejables. Ciencia de la Gestión, 44:1131-1147, 1998. [18] T. Sandholm. Una implementación del protocolo de red de contratos basada en cálculos de costos marginales. En Proc. de AAAI93, páginas 256-262, 1993. [19] T. Sandholm. Algoritmo para la determinación óptima del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, 2002. [20] T. Sandholm. Algoritmos de determinación de ganadores. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [21] T. Sandholm y S. Suri. Bob: Mejora en la determinación de ganadores en subastas combinatorias y generalizaciones. Inteligencia Artificial, 7:33-58, 2003. [22] M. Tennenholtz. Algunas subastas combinatorias manejables. En Proc. de AAAI00, páginas 98-103, 2000. [23] E. Zurel y N. Nisan. Un algoritmo de asignación aproximada eficiente para subastas combinatorias. En Proc. de EC01, páginas 125-136, 2001. 161 ",
            "candidates": [],
            "error": [
                []
            ]
        },
        "hypergraph hg": {
            "translated_key": "hipercubo HG",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a <br>hypergraph hg</br> such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the <br>hypergraph hg</br> in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "The general idea it to build a <br>hypergraph hg</br> such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "The reader may notice in it the blocks defined above and how they are related with the <br>hypergraph hg</br> in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next."
            ],
            "translated_annotated_samples": [
                "La idea general es construir un <br>hipercubo HG</br> de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución.",
                "El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el <br>hipercubo HG</br> en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. Los algoritmos de tiempo polinómico para encontrar la mejor simplificación del grafo primal solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo. Empaquetamiento de conjuntos ponderado. Cabe destacar que la representación de hipergrafo H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en hipergrafos (por ejemplo, [17]). Formalmente, un empaquetamiento h para un hipergrafo H es un conjunto de hiperarcos de H tal que para cada par h, h ∈ h con h ≠ h, se cumple que h ∩ h = ∅. Si se deja que w sea una función de ponderación para H, es decir, una función computable en tiempo polinómico de E(H) a números racionales, el peso de un empaquetado h es el número racional w(h) = h∈h w(h), donde w({}) = 0. Entonces, el problema de empaquetamiento de conjuntos con peso máximo para H con respecto a w, denotado por MaxWSP(H, w), es el problema de encontrar un empaquetamiento para H que tenga el peso máximo entre todos los empaquetamientos para H. Para ver que MaxWSP es simplemente una formulación diferente para el problema de determinación del ganador, dado una subasta combinatoria I, B, es suficiente definir la función de ponderación w I,B (elemento(Bi)) = pago(Bi). Entonces, el conjunto de soluciones para el problema de empaquetamiento de conjuntos ponderados para H I,B con respecto a w I,B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, B. Ejemplo 2. Considera nuevamente el hipercubo H I0,B0 reportado en la Figura 1.(a). Un ejemplo de empaquetado para H I0, B0 es h = {h1}, que intuitivamente corresponde a un resultado para I0, B0, donde el subastador aceptó la oferta B1. Al asumir que las ofertas B1, B2 y B3 son tales que pay(B1) = pay(B2) = pay(B3), el empaquetado h no es una solución para el problema MaxWSP(H I0,B0 , w I0,B0). De hecho, el empaque h∗ = {h2, h3} es tal que w I0,B0 (h∗ ) > w I0,B0 (h). ¡Contribuciones! El objetivo principal de este artículo es identificar clases grandes y manejables para el problema de determinación del ganador, que además sean reconocibles de forma polinómica. Con este objetivo, primero estudiamos grafos de elementos estructurados y resolvemos el problema abierto en [3]. El resultado es una noticia muy mala: es NP completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado de ancho de árbol 3. De manera más formal, dejando que C(ig, k) denote la clase de todos los hipergrafos que tienen un árbol de ítems con un ancho de árbol limitado por k, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C(ig, 3) es NP-completo. A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que puedan ser verificados en tiempo polinómico y que aún puedan ser utilizados para aislar clases tratables del problema de empaquetamiento de conjuntos con peso máximo o, equivalentemente, el problema de determinación del ganador. Nuestras investigaciones, esta vez, llevaron a noticias muy buenas que se resumen a continuación: Para un hipercubo H, su dual ¯H = (V, E) es tal que los nodos en V están en correspondencia uno a uno con los hiperarcos en H, y para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} está en E. Mostramos que MaxWSP es tratable en la clase de aquellas instancias cuyos hipercubos duales tienen un ancho de hiperárbol[7] limitado por k (abreviado: clase C(hw, k) de hipercubos). Cabe destacar que un problema clave de la tratabilidad es considerar el ancho de hiperárbol del hipergrafo dual ¯H en lugar del hipergrafo de subastas H. De hecho, podemos demostrar que MaxWSP sigue siendo NP-duro incluso cuando H es acíclico (es decir, cuando tiene un ancho de hiperárbol de 1), incluso cuando cada nodo está contenido en un máximo de 3 hiperarcos. Para algunas clases especiales relevantes de hipergrafos en C(hw, k), diseñamos un algoritmo altamente paralelizable para MaxWSP. Específicamente, si las funciones de ponderación se pueden calcular en espacio logarítmico y los pesos son polinomiales (por ejemplo, cuando todos los hiperarcos tienen pesos unitarios y se está interesado en encontrar el empaquetamiento con el máximo número de arcos), demostramos que MaxWSP puede resolverse mediante un algoritmo LOGCFL. Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son reducibles en espacio logarítmico a lenguajes libres de contexto, y que LOGCFL ⊆ NC2 ⊆ P (ver, por ejemplo, [9]). Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la descomposición de hipertree de los hipergrafos duales en lugar de la treewidth de los grafos de elementos. Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados. De hecho, demostramos que clases de instancias estrictamente más grandes son tratables según nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados. De manera intuitiva, la NP-dificultad de reconocer grafos de elementos estructurados de ancho acotado no se debe a su gran generalidad, sino más bien a algunas peculiaridades en su definición. La prueba de los resultados anteriores nos brinda una perspectiva interesante sobre la noción de grafo de elementos estructurados. De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos descomposiciones de hiperárboles estrictas. También se propone una caracterización de juego para la noción de ancho de hiperárbol estricto, que se especializa en el juego de Ladrón y Policías en [6] (propuesto para caracterizar el ancho de hiperárbol), y que aclara los requisitos adicionales sobre las descomposiciones de hiperárboles. El resto del documento está organizado de la siguiente manera. La sección 2 discute la intratabilidad de los grafos de elementos estructurados. La sección 3 presenta el algoritmo de tiempo polinómico para resolver MaxWSP en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hipertree acotado, y discute los casos en los que el algoritmo también es altamente paralelizable. La comparación entre las clases C(ig, k) y C(hw, k) se discute en la Sección 4. Finalmente, en la Sección 5 sacamos nuestras conclusiones también delineando las direcciones para futuras investigaciones. 2. COMPLEJIDAD DE LOS GRAFOS DE ELEMENTOS ESTRUCTURADOS Sea H un hipergrafo. Un grafo G = (V, E) es un grafo de elementos para H si V = N(H) y, para cada h ∈ E(H), el subgrafo de G inducido sobre los nodos en h está conectado. Una clase importante de grafos de elementos es la de grafos de elementos estructurados, es decir, aquellos grafos de elementos que tienen un ancho de árbol acotado como se formaliza a continuación. Una descomposición de árbol [16] de un grafo G = (V, E) es un par T, χ, donde T = (N, F) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjunto de vértices χ(p) ⊆ V, de modo que se satisfacen las siguientes condiciones: (1) para cada vértice b de G, existe un p ∈ N tal que b ∈ χ(p); (2) para cada arista {b, d} ∈ E, existe un p ∈ N tal que {b, d} ⊆ χ(p); (3) para cada vértice b de G, el conjunto {p ∈ N | b ∈ χ(p)} induce un subárbol conectado de T. El ancho de T, χ es el número maxp∈N |χ(p) − 1|. El treewidth de G, denotado por tw(G), es el ancho mínimo sobre todas sus descomposiciones en árboles. El problema de determinación del ganador puede resolverse en tiempo polinómico en grafos de elementos con treewidth acotado [3]. Teorema 1 (cf. [3]). Se tiene una descomposición en árbol de ancho k T, χ de un grafo de elementos para H. Entonces, MaxWSP(H, w) se puede resolver en tiempo O(|T|2 ×(|E(H)|+1)k+1 ). Muchos gráficos de elementos pueden estar asociados con un hipergráfico. Como ejemplo, observe que el grafo de elementos en la Figura 1. (c) tiene un ancho de árbol de 1, mientras que la Figura 1. (d) muestra un grafo de elementos cuyo ancho de árbol es 2. De hecho, era una pregunta abierta si, para una constante k dada, se puede verificar en tiempo polinómico si existe un grafo de ítems de ancho de árbol k, y en caso afirmativo, si dicho grafo de ítems se puede calcular eficientemente. La principal tarea de esta sección es demostrar que la clase C(ig, k) es difícil de reconocer. Teorema 2. Decidir si un hipergrafo H pertenece a C(ig, 3) es NP-difícil. La prueba de este resultado se basa en una reducción elaborada del problema de camino hamiltoniano HP(s, t) que consiste en decidir si hay un camino hamiltoniano desde un nodo s hasta un nodo t en un grafo dirigido G = (N, E). Para ayudar a la intuición, aquí presentamos una descripción general de alto nivel de los principales ingredientes utilizados en la prueba. La idea general es construir un <br>hipercubo HG</br> de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución. Primero, discutimos la forma en que se construye HG. Ver la Figura 2. (a) para una ilustración, donde el grafo G consiste en los nodos s, x, y, y t, y el conjunto de sus aristas es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. De G a HG. Sea G = (N, E) un grafo dirigido. Entonces, el conjunto de nodos en HG es tal que: para cada x ∈ N, N(HG) contiene los nodos bsx, btx, bx, bx, bdx; para cada e = (x, y) ∈ E, N(HG) contiene los nodos nsx, nsx, nty, nty, nsex y ntey. Ningún otro nodo está en N(HG). Los hiperarcos en HG son de tres tipos: 1) para cada x ∈ N, E(HG) contiene los hiperarcos: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, y A3 x = {bx, bx} -nota que estos hiperarcos inducen una clique en los nodos {bx, bx, bdx}; 1 Las pruebas detalladas se pueden encontrar en el Apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf. Figura 2: Prueba del Teorema 2: (a) de G a HG - solo se reportan los hiperarcos en 1) y 2); (b) un esqueleto para una descomposición en árbol TD para HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, y TA3 x = {btx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {btx, bx, bx, bdx}; 2) para cada e = (x, y) ∈ E, E(HG) contiene los hiperarcos: • SHx = {nsx, nsx}; • THy = {nty, nty}; • SEe = {nsx, nse x} y SEe = {nsx, nse x} -nota que estos dos hiperarcos más SHx inducen una clique en los nodos {nsx, nsx, nse x}; • TEe = {nty, nte y} y TEe = {nty, nte y} -nota que estos dos hiperarcos más THy inducen una clique en los nodos {nty, nty, nte y}. Observa que cada uno de los hiperarcos anteriores, excepto aquellos de la forma Sx y Tx, contiene exactamente dos nodos. Como ejemplo de los hiperarcos de tipo 1) y 2), el lector puede referirse a la construcción de ejemplo reportada en la Figura 2. (a), y notar, por ejemplo, que Sx = {bsx, nse2 x, nse3 x} y que Tt = {btt, nte4 t, nte3 t}. 3) finalmente, denotamos por DG al conjunto que contiene los hiperarcos en E(HG) del tercer tipo. En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperarcos que satisfacen las cuatro condiciones que se discuten a continuación. Sea PG el conjunto de los siguientes |PG| ≤ |N| + 3 × |E| pares: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}. Además, sea I(v) el conjunto {h ∈ E(H) | v ∈ h} de los hiperarcos de H que son tocados por v; y, para un conjunto V ⊆ N(H), sea I(V) = v∈V I(v). Entonces, DG tiene que ser un conjunto tal que: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ PG o (β, α) ∈ PG, se cumple: I(α) ∩ DG = ∅; y, (c4) ∀S ⊆ N tal que |S| ≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ PG, se cumple que: I(S) ⊇ DG. De manera intuitiva, el conjunto DG es tal que cada una de sus hiperaristas es tocada exactamente por uno de los dos nodos en cada par de PG, cf. (c1) y (c2). Además, los hiperarcos en DG solo tocan vértices incluidos en al menos un par de PG - cf. (c3); y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se pueden construir a partir de él pertenece a PG - cf. (c4). El lector puede preguntarse ahora si existe un conjunto DG que satisfaga (c1), (c2), (c3) y (c4). En el siguiente lema, respondemos positivamente a esta pregunta y referimos al lector a su demostración para un ejemplo de construcción. Lema 1. Un conjunto DG, con |DG| = 2 × |PG| + 2, que cumple las condiciones (c1), (c2), (c3) y (c4) se puede construir en tiempo O(|PG|2). Ingredientes clave. Ahora estamos en la posición de presentar una visión general de los ingredientes clave de la prueba. Sea G un grafo de elementos arbitrario para HG, y sea TD = T, χ una descomposición de árbol de ancho 3 de G (nota que, debido a las cliques, por ejemplo, en los nodos {bsx, bx, bx, bdx}, cualquier grafo de elementos para HG tiene un ancho de árbol de al menos 3). Hay tres observaciones básicas que sirven para demostrar la corrección de la reducción. Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértices. Específicamente, para cada nodo x ∈ N, TD contiene un vértice bs(x) tal que χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, y un vértice bt(x) tal que χ(bt(x)) ⊇ {btx, bx, bx, bdx}. Y, para cada arista e = (x, y) ∈ E, TD contiene un vértice ns(x,e) tal que χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, y un vértice nt(y,e) tal que χ(nt(y,e)) ⊇ {nte y, nty, nty}. Intuitivamente, se requiere que estos vértices cubran los cliques de HG asociados con los hiperarcos de tipo 1) y 2). Cada uno de estos vértices desempeña un papel específico en la reducción. De hecho, cada arista dirigida e = (x, y) ∈ E está codificada en TD mediante los vértices: ns(x,e), que representan precisamente que e comienza en x; y nt(y,e), que representan precisamente que e termina en y. Además, cada nodo x ∈ N está codificado en TD mediante los vértices: bs(x), que representa el punto de inicio de las aristas que se originan en x; y, bt(x), que representa el punto de terminación de las aristas que terminan en x. Como ejemplo, la Figura 2. (b) muestra el esqueleto de una descomposición de árbol TD. El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el <br>hipercubo HG</br> en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación. La conexión entre bloques y la unicidad de las conexiones: La segunda observación crucial es que en el camino que conecta un vértice de la forma bs(x) (resp., bt(y)) con un vértice de la forma ns(x,e) (resp., nt(y,e)) hay un vértice especial de la forma w(x,y) tal que: χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E. Garantizar la existencia de un vértice así es precisamente el papel que desempeñan los hiperarcos en DG. Los argumentos para la prueba son los siguientes. Primero, observamos que I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} e I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}. Luego, mostramos una propiedad que establece que para un par de vértices consecutivos p y q en el camino que conecta bs(x) y ns(x,e) (resp., bt(y) y nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))). Por lo tanto, tenemos: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (o bien, I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}). Basándose en esta observación, y al explotar las propiedades de los hiperarcos en DG, no es difícil demostrar que cualquier par de vértices consecutivos p y q deben compartir dos nodos de HG formando un par en PG, y ambos deben tocar Sx (resp., Ty). Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w(x,y), en este camino es tal que χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E - para ello, note que nse x ∈ Sx, nte t ∈ Ty, e I(χ(w(x,y))) ⊇ DG. En particular, w(x,y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay otro vértice de la forma w(x,z), para z = y (o bien, w(z,y), para z = x). Para ayudar a la intuición, observamos que tener un vértice de la forma w(x,y) en TD corresponde a la selección de un borde desde el nodo x hasta el nodo y en el camino hamiltoniano. De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de un camino hamiltoniano para G y los vértices de la forma w(x,y). Como ejemplo, en la Figura 2. (b), los vértices de la forma w(s,x), w(x,y) y w(y,t) están en TD, y GT D muestra el camino hamiltoniano correspondiente. Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w(x, y), para una arista e = (x, y) ∈ E no está en TD (es decir, si la arista (x, y) no pertenece al camino hamiltoniano), entonces el bloque correspondiente ns(x, e) (resp., nt(y, e)) puede ser agregado arbitrariamente en el subárbol enraizado en el bloque ns(x, e) (resp., nt(y, e)), donde e es la arista de la forma e = (x, z) (resp., e = (z, y)) tal que w(x, z) (resp., w(z, y)) está en TD. Por ejemplo, la Figura 2. (a) muestra w(x,t), que no se utiliza en TD, y la Figura 2. (b) muestra cómo los bloques ns(x,e3) y nt(t,e3) pueden ser dispuestos en TD para garantizar la condición de conectividad. CASOS TRACTABLES MEDIANTE DESCOMPOSICIONES DE HIPERÁRBOLES Dado que construir grafos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden ser utilizadas para identificar clases de instancias de MaxWSP tratables. Con este fin, nos enfocamos en la noción de descomposición de hiperárboles [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros. Un hypertree para un hipercubo H es un triple T, χ, λ, donde T = (N, E) es un árbol raíz, y χ y λ son funciones de etiquetado que asocian a cada vértice p ∈ N con dos conjuntos χ(p) ⊆ N(H) y λ(p) ⊆ E(H). Si T = (N, E) es un subárbol de T, definimos χ(T) = v∈N χ(v). Denotamos el conjunto de vértices N de T como vertices(T). Además, para cualquier p ∈ N, Tp denota el subárbol de T con raíz en p. Definición 1. Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p). El ancho de una descomposición de hipertree T, χ, λ es maxp∈vertices(T )|λ(p)|. El ancho de HYPERTREE hw(H) de H es el ancho mínimo sobre todas sus descomposiciones hypertree. Un hipergrafo H es acíclico si hw(H) = 1. Ejemplo 3. El hipergrafo H I0,B0 reportado en la Figura 1. (a) es un ejemplo de hipergrafo acíclico. En cambio, tanto los hipergráficos H1 y ¯H1 mostrados en la Figura 3. (a) y la Figura 3. (b), respectivamente, no son acíclicos ya que su anchura de hipertiempo es 2. Se reporta una descomposición de hipertree de ancho 2 para ¯H1 en la Figura 3.(c). En particular, observe que H1 se ha obtenido agregando los dos hiperarcos h4 y h5 a H I0,B0 para modelar, por ejemplo, que dos nuevas ofertas, B4 y B5, respectivamente, han sido propuestas al subastador. En lo siguiente, en lugar de trabajar en el hipercampo H asociado con un problema de MaxWSP, trataremos con su dual ¯H, es decir, con el hipercampo tal que sus nodos están en correspondencia uno a uno con los hiperarcos de H, y donde para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} está en E( ¯H). Como ejemplo, el lector puede querer revisar nuevamente el hipercubo H1 en la Figura 3 (a) y notar que el hipercubo en la Figura 3 (b) es de hecho su dual. La razón de esta elección es que imponer restricciones en el hipercubo original garantiza la tratabilidad solo en escenarios muy simples. Teorema 3. En la clase de hipergrafos acíclicos, MaxWSP está (1) en P si cada nodo ocurre en un máximo de dos hiperarcos; y, (2) NP-duro, incluso si cada nodo está contenido en un máximo de tres hiperarcos. 3.1 Descomposición de hiperárboles en el hipergrafo dual y problemas de empaquetamiento tratables Para una constante fija k, sea C(hw, k) la clase de todos los hipergrafos cuyos hipergrafos duales tienen un ancho de hiperárbol limitado por k. El problema de empaquetamiento de conjuntos con peso máximo se puede resolver en tiempo polinómico en la clase C(hw, k) mediante el algoritmo ComputeSetPackingk, mostrado en la Figura 4. El algoritmo recibe como entrada un hipercubo H, una función de ponderación w, y una descomposición de hipertree de ancho k HD = T=(N, E), χ, λ de ¯H. Para cada vértice v ∈ N, sea Hv el hipergrafo cuyo conjunto de nodos N(Hv) ⊆ N(H) coincide con λ(v), y cuyo conjunto de aristas E(Hv) ⊆ E(H) coincide con χ(v). En un paso de inicialización, el algoritmo equipa a cada vértice v con todos los empaquetamientos posibles para Hv, los cuales se almacenan en el conjunto Hv. Se debe tener en cuenta que el tamaño de Hv está limitado por (|E(H)| + 1)k, ya que cada nodo en λ(v) está sin cubrir en un empaquetamiento o está cubierto precisamente por una de las hiperaristas en χ(v) ⊆ E(H). Entonces, ComputeSetPackingk está diseñado para filtrar estos empaquetamientos conservando solo aquellos que se ajusten a algún empaquetamiento para Hc, para cada hijo c de v en T, como se formaliza a continuación. Dejen que hv y hc sean dos empaquetados para Hv y Hc, respectivamente. Decimos que hv se ajusta a hc, indicado por hv ≈ hc si: para cada h ∈ hc ∩ E(Hv), h está en hv; y, para cada h ∈ (E(Hc) − hc), h no está en hv. Ejemplo 4. Considera nuevamente la descomposición de hipertree de ¯H1 reportada en la Figura 3.(c). Luego, el conjunto de todos los empaquetados posibles (que se construyen en el paso de inicialización de ComputeSetPackingk), para cada uno de sus vértices, se reFigure 5: Ejemplo de aplicación del Algoritmo ComputeSetPackingk. 157 Entrada: H, w, y una descomposición de hipertree de ancho k HD = T = (N, E), χ, λ de ¯H; Salida: Una solución para MaxWSP(H, w); var Hv: conjunto de empaquetados para Hv, para cada v ∈ N; h∗: empaquetado para H; v hv: número racional, para cada empaquetado parcial hv para Hv; hhv,c: empaquetado parcial para Hc, para cada empaquetado parcial hv para Hv, y para cada (v, c) ∈ E; -------------------------------------------Procedimiento BottomUp; begin Done := el conjunto de todas las hojas de T; mientras ∃v ∈ T tal que (i) v ∈ Done, y (ii) {c | c es hijo de v} ⊆ Done hacer para cada c tal que (v, c) ∈ E hacer Hv := Hv - {hv | ∃hc ∈ Hc tal que hv ≈ hc}; para cada hv ∈ Hv hacer v hv := w(hv); para cada c tal que (v, c) ∈ E hacer ¯hc := arg maxhc∈Hc|hv≈ hc c hc - w(hc ∩ hv); hhv,c := ¯hc; (* establecer mejor empaquetado *) v hv := v hv + c ¯hc - w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end mientras end; -------------------------------------------begin (* PRINCIPAL *) para cada vértice v en T hacer Hv := {hv empaquetado para Hv}; BottomUp; sea r la raíz de T; ¯hr := arg maxhr∈Hr r hr; h∗ := ¯hr; (* incluir empaquetado *) T opDown(r, hr); return h∗; end. Procedimiento TopDown(v: vértice de N, ¯hv ∈ Hv); comenzar para cada c ∈ N tal que (v, c) ∈ E hacer ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* incluir empaquetado *) TopDown(c, ¯hc); fin para fin; Figura 4: Algoritmo ComputeSetPackingk. representado en la Figura 5.(a). Por ejemplo, la raíz v1 es tal que Hv1 = { {}, {h1}, {h3}, {h5} }. Además, una flecha de un empaque hc a hv indica que hv cumple con hc. Por ejemplo, el lector puede comprobar que el empaquetado {h3} ∈ Hv1 se ajusta al empaquetado {h2, h3} ∈ Hv3, pero no se ajusta a {h1} ∈ Hv3. ¡ComputeSetPackingk construye una solución recorriendo T en dos fases. En la primera fase, los vértices de T se procesan desde las hojas hasta la raíz r, mediante el procedimiento BottomUp. Para cada nodo v que se está procesando, el conjunto Hv se actualiza preliminarmente eliminando todos los empaquetados hv que no cumplen con ningún empaquetado para algunos de los hijos de v. Después de realizar este filtrado, se actualiza el peso hv. De manera intuitiva, v hv almacena el peso del mejor empaquetado parcial para H calculado utilizando solo los hiperarcos que ocurren en χ(Tv). De hecho, si v es una hoja, entonces v hv = w(hv). De lo contrario, para cada hijo c de v en T, v hv se actualiza con el máximo de c hc - w(hc ∩ hv) sobre todos los empaquetados hc que se ajustan a hv (resolviendo empates de forma arbitraria). El empaque ¯hc para el cual se logra este máximo se almacena en la variable hhv,c. En la segunda fase, el árbol T se procesa comenzando desde la raíz. En primer lugar, se selecciona el empaque h∗ que maximiza el peso equipado con los empaques en Hr. Luego, el procedimiento TopDown se utiliza para extender h∗ a todos los otros empaquetamientos parciales para los vértices de T. En particular, en cada vértice v, h∗ se extiende con el empaquetamiento hhv,c, para cada hijo c de v. Ejemplo 5. Supongamos que, en nuestro ejemplo en curso, w(h1) = w(h2) = w(h3) = w(h4) = 1. Luego, una ejecución de ComputeSetPackingk se representa gráficamente en la Figura 5. (b), donde una flecha de un empaquetado hc a un empaquetado hv se utiliza para denotar que hc = hhv,c. Específicamente, las elecciones realizadas durante el cálculo son tales que se calcula el empaquetamiento {h2, h3}. En particular, durante la fase de abajo hacia arriba, tenemos que: (1) se procesa v4 y establecemos v4 {h2} = v4 {h4} = 1 y v4 {} = 0; (2) se procesa v3 y establecemos v3 {h1} = v3 {h3} = 1 y v3 {} = 0; (3) se procesa v2 y establecemos v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 y v3 {} = 0; (4) se procesa v1 y establecemos v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 y v1 {} = 0. Por ejemplo, observe que v1 {h5} = 2 ya que {h5} se ajusta al empaquetado {h4} de Hv2 de tal manera que v2 {h4} = 1. Entonces, al comienzo de la fase de arriba hacia abajo, ComputeSetPackingk selecciona {h3} como un empaquetado para Hv1 y propaga esta elección en el árbol. De manera equivalente, el algoritmo pudo haber elegido {h5}. Como ejemplo adicional, se informa en la Figura 5.(c) la forma en que se obtiene la solución {h1} mediante el algoritmo cuando w(h1) = 5 y w(h2) = w(h3) = w(h4) = 1. Observa que, en esta ocasión, en la fase de arriba hacia abajo, ComputeSetPackingk comienza a seleccionar {h1} como el mejor empaquetado para Hv1. ¡Teorema 4. Sea H un hipergrafo y w una función de ponderación para él. Sea HD = T, χ, λ una descomposición de hipertree completa de ancho k de ¯H. Entonces, ComputeSetPackingk en la entrada H, w y HD produce correctamente una solución para MaxWSP(H, w) en tiempo O(|T| × (|E(H)| + 1)2k. Prueba. [Bosquejo] Observamos que h∗ (calculado por ComputeSetPackingk) es un empaquetamiento para H. De hecho, consideremos un par de hiperarcos h1 y h2 en h∗, y supongamos, para efectos de contradicción, que h1 ∩ h2 = ∅. Sea v1 (resp., v2) un vértice arbitrario de T, para el cual ComputeSetPackingk incluyó h1 (resp., h2) en h∗ en el cálculo de abajo hacia arriba. Por construcción, tenemos h1 ∈ χ(v1) y h2 ∈ χ(v2). Sea I un elemento en h1 ∩ h2. En el hipergrafo dual H, I es un hiperborde en E(¯H) que cubre tanto los nodos h1 como h2. Por lo tanto, por la condición (1) en la Definición 1, existe un vértice v ∈ vértices(T) tal que {h1, h2} ⊆ χ(v). Se debe tener en cuenta que, debido a la condición de conectividad en la Definición 1, también podemos asumir, sin pérdida de generalidad, que v está en el camino que conecta v1 y v2 en T. Sea hv ∈ Hv el elemento añadido por ComputeSetPackingk en h∗ durante la fase de abajo hacia arriba. Dado que los elementos en Hv son empaquetamientos para Hv, se cumple que o bien h1 ∈ hv o h2 ∈ hv. Supongamos, sin pérdida de generalidad, que h1 ∈ hv, y notemos que cada vértice w en T en el camino que conecta v con v1 es tal que h1 ∈ χ(w), debido a la condición de conectividad. Por lo tanto, debido a la definición de conformidad, el empaque hw seleccionado por ComputeSetPackingk para ser agregado en el vértice w en h∗ debe ser tal que h1 ∈ hw. Esto se cumple en particular para w = v1. Contradicción con la definición de v1. Por lo tanto, h∗ es un empaquetamiento para H. Queda entonces por demostrar que tiene el peso máximo sobre todos los empaquetamientos para H. Con este fin, podemos utilizar la inducción estructural en T para demostrar que, en la fase de abajo hacia arriba, la variable v hv se actualiza para contener el peso del empaquetamiento en las aristas en χ(Tv), que contiene hv y que tiene el peso máximo sobre todos los empaquetamientos para las aristas en χ(Tv). Entonces, el resultado sigue, ya que en la fase de arriba hacia abajo, el empaquetado hr que da el peso máximo sobre χ(Tr) = E(H) se incluye primero en h∗, y luego se extiende en cada nodo c con el empaquetado hhv,c de forma conforme con hv y de manera que se alcance el valor máximo de v hv. En cuanto a la complejidad, observe que el paso de inicialización requiere la construcción del conjunto Hv, para cada vértice v, y cada conjunto tiene un tamaño de (|E(H)| + 1)k como máximo. Luego, la función BottomUp verifica la conformidad entre las estrategias en Hv con las estrategias en Hc, para cada par (v, c) ∈ E, y actualiza el peso v hv. Estas tareas pueden llevarse a cabo en tiempo O((|E(H)| + 1)2k) y deben repetirse para cada arista en T, es decir, O(|T|) veces. Finalmente, la función TopDown puede implementarse en tiempo lineal en el tamaño de T, ya que solo requiere actualizar h∗ accediendo a la variable hhv,c. El resultado anterior muestra que si se proporciona una descomposición de hipertree de ancho k, el problema MaxWSP se puede resolver de manera eficiente. Además, a diferencia del caso de los grafos de elementos estructurados, es bien sabido que decidir la existencia de una descomposición de hipertree acotada por k y calcular una (si existe alguna) son problemas que pueden resolverse eficientemente en tiempo polinómico [7]. Por lo tanto, el Teorema 4 confirma que la clase C(hw, k) constituye en realidad una clase manejable para el problema de determinación del ganador. Como muestra el siguiente teorema, para subclases grandes (que dependen solo de cómo se especifica la función de peso), MaxWSP(H, w) es altamente paralelizable. Llamemos a una función de ponderación suave si es computable en espacio logarítmico y si todos los pesos son polinomiales (y por lo tanto solo requieren O(log n) bits para su representación). Recuerde que LOGCFL es una clase de complejidad paralela contenida en NC2, cf. [9]. La versión funcional de LOGCFL es LLOGCFL, la cual se obtiene equipando un transductor de espacio logarítmico con un oráculo en LOGCFL. Teorema 5. Sea H un hipergrafo en C(hw, k), y sea w una función de ponderación suave para él. Entonces, MaxWSP(H, w) está en LLOGCFL. 4. Dadas las descomposiciones de hipertree frente a los grafos de elementos estructurados, y considerando que se ha demostrado que la clase C(hw, k) es una isla de tratabilidad para el problema de determinación del ganador, y dado que se ha demostrado que la clase C(ig, k) no es reconocible eficientemente, uno podría inclinarse a pensar que existen instancias con ancho de hipertree ilimitado, pero que admiten un grafo de elementos de ancho de árbol acotado (por lo que la intratabilidad de los grafos de elementos estructurados residiría en su generalidad). Sorprendentemente, establecemos que este no es el caso. La clave de la prueba es primero demostrar que los grafos de elementos estructurados están en correspondencia uno a uno con un tipo especial de descomposiciones de hiperárboles del hipergrafo dual, al que llamaremos estricto. Entonces, el resultado seguirá al demostrar que las descomposiciones estrictas de hipertree de ancho k son menos potentes que las descomposiciones de hipertree de ancho k. 4.1 Descomposiciones estrictas de hipertree Deje que H sea un hipergrafo, y V ⊆ N(H) sea un conjunto de nodos y X, Y ∈ N(H). X es [V]-adyacente a Y si existe un borde h ∈ E(H) tal que {X, Y} ⊆ (h - V). Un camino [V] π de X a Y es una secuencia X = X0, . . . , X = Y de variables tal que: Xi es [V]-adyacente a Xi+1, para cada i ∈ [0... -1]. Un conjunto W ⊆ N(H) de nodos está [V]-conectado si ∀X, Y ∈ W hay un [V]-camino de X a Y. Un componente [V ] es un conjunto maximal no vacío de nodos W ⊆ (N(H) − V ) que está [V ]-conectado. Para cualquier componente [V] C, sea E(C) = {h ∈ E(H) | h ∩ C = ∅}. Definición 2. Una descomposición de hipertree HD = T, χ, λ de H es estricta si se cumplen las siguientes condiciones: 1. para cada par de vértices r y s en los vértices de T tal que s es un hijo de r, y para cada componente [χ(r)]-Cr. La intersección de Cr con χ(Ts) es vacía, Cr es un componente de [χ(r) ∩ N(λ(r) ∩ λ(s))]; 2. para cada arista h ∈ E(H), hay un vértice p tal que h ∈ λ(p) y h ⊆ χ(p) (decimos que p cubre fuertemente a h); 3. para cada arista h ∈ E(H), el conjunto {p ∈ vértices(T) | h ∈ λ(p)} induce un subárbol (conectado) de T. La anchura estricta de hipertree shw(H) de H es la anchura mínima sobre todas sus descomposiciones estrictas de hipertree. La relación básica entre las descomposiciones de hipertree agradables y los grafos de elementos estructurados se muestra en el siguiente teorema. Teorema 6. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, una k-anchura descomposición en árbol de un grafo de elementos para H existe si y solo si ¯H tiene una (k + 1)-anchura descomposición estricta en hiperárbol. Se debe tener en cuenta que, en lo que respecta al problema de empaquetamiento de conjuntos ponderados máximo, dado un hipercubo H, siempre podemos asumir que para cada nodo v ∈ N(H), {v} está en E(H). De hecho, si esta hiperarista no está en el hipercubo, entonces se puede agregar sin pérdida de generalidad, estableciendo w({v}) = 0. Por lo tanto, dejando que C(shw, k) denote la clase de todos los hipergrafos cuyos hipergrafos duales (asociados con un máximo de 2 términos +1) solo juegan el papel técnico de ocuparse de la diferente definición de ancho para las descomposiciones de árboles y las descomposiciones de hiperárboles. 159 problemas de empaquetamiento de conjuntos ponderados) tienen un ancho de hiperárbol estricto limitado por k, tenemos que C(shw, k + 1) = C(ig, k). Por definición, las descomposiciones de hipertree estrictas son descomposiciones de hipertree especiales. De hecho, podemos demostrar que las condiciones adicionales en la Definición 2 inducen una restricción real en el poder de descomposición. Teorema 7. C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). \n\nC(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). Una vista desde la teoría de juegos. Arrojamos más luz sobre las descomposiciones estrictas de hypertrees al discutir una interesante caracterización basada en el juego estricto de Robber y Marshals, definido adaptando el juego de Robber y Marshals definido en [6], que caracteriza el ancho de hypertree. El juego se juega en un hipercubo H por un ladrón contra k marshals que actúan en coordinación. Los alguaciles se mueven en los hiperarcos de H, mientras que el ladrón se mueve en los nodos de H. El ladrón ve hacia dónde los alguaciles tienen la intención de moverse, y reacciona moviéndose a otro nodo que esté conectado con su posición actual y a través de un camino en G(H) que no utilice ningún nodo contenido en un hiperarco que esté ocupado por los alguaciles antes y después de su movimiento; decimos que estos hiperarcos están bloqueados. Ten en cuenta que en el juego básico definido en [6], al ladrón no se le permite moverse en vértices ocupados por los marshals antes y después de su movimiento, incluso si no pertenecen a hiperarcos bloqueados. Es importante que los marshals jueguen de manera monótona, es decir, no pueden ocupar un borde que haya sido ocupado previamente en el juego y que actualmente no lo esté. Los alguaciles ganan el juego si capturan al ladrón, ocupando un borde que cubra un nodo donde se encuentre el ladrón. De lo contrario, el ladrón gana. Teorema 8. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, ¯H tiene una descomposición estricta de hipertree de k-anchura si y solo si k marshals pueden ganar el Juego estricto de Robber y Marshals en ¯H, sin importar los movimientos de los ladrones. 5. CONCLUSIONES Hemos resuelto la pregunta abierta de determinar la complejidad de calcular un grafo de elementos estructurado asociado con un escenario de subasta combinatoria. El resultado es una mala noticia, ya que resultó que es NP-completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado, incluso para un ancho de árbol de 3. Motivados por este resultado, investigamos el uso de la descomposición de hiperárboles (en el hipergrafo dual asociado con el escenario) y demostramos que el problema es tratable en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hiperárbol acotado. Para algunos casos especiales y relevantes, también se discute un algoritmo altamente paralelizable. Curiosamente, también se descubrió que la clase de grafos de elementos estructurados está adecuadamente contenida en la clase de instancias con ancho de hiperárbol acotado (por lo tanto, la razón de su intratabilidad no es su generalidad). En particular, este último resultado se establece mostrando una relación precisa entre los grafos de elementos estructurados y formas restringidas de descomposiciones de hiperárboles (en el hipergrafo dual), llamadas descomposiciones de consultas (ver, por ejemplo, [7]). A la luz de esta observación, notamos que demostrar algunos resultados de aproximabilidad para grafos de elementos estructurados requiere una comprensión profunda de la aproximabilidad de las descomposiciones de consultas, la cual actualmente no se encuentra en la literatura. Como una vía adicional de investigación, sería relevante mejorar el algoritmo ComputeSetPackingk, por ejemplo, mediante el uso de estructuras de datos especializadas, con el fin de evitar la dependencia cuadrática de (|E(H)| + 1)k. Finalmente, otra pregunta interesante es evaluar si las técnicas de descomposición estructural discutidas en el artículo pueden ser utilizadas para abordar eficientemente generalizaciones del problema de determinación del ganador. Por ejemplo, podría ser relevante en varios escenarios de aplicación diseñar algoritmos que puedan encontrar una estrategia de venta cuando hay varias copias del mismo artículo disponibles para la venta, y además cuando el subastador está satisfecho cuando se venden al menos un número dado de copias. El trabajo de G. Gottlob fue apoyado por el EC3 - Centro de Competencia en Comercio Electrónico (Viena) y por un Premio de Mérito de Investigación Wolfson de la Royal Society. En particular, este premio permitió a Gottlob invitar a G. Greco para una visita de investigación a Oxford. Además, G. Greco cuenta con el apoyo de ICAR-CNR y del M.I.U.R. en el marco del proyecto TOCAI.IT. 6. REFERENCIAS [1] I. Adler, G. Gottlob y M. Grohe. Anchura de hipertree y invariantes de hipergrafo relacionados. En Proc. de EUROCOMB05, páginas 5-10, 2005. [2] C. Boutilier. Resolviendo problemas de subasta combinatoria expresados de manera concisa. En Proc. de AAAI02, páginas 359-366, 2002. [3] V. Conitzer, J. Derryberry y T. Sandholm. Subastas combinatorias con grafos de elementos estructurados. En Proc. de AAAI04, páginas 212-218, 2004. [4] E. M. Eschen y J. P. Sinrad. Un algoritmo O(n2) para el reconocimiento de grafos de arco circular. En Proc. de SODA93, páginas 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Óptimo y aproximado. En Proc. de IJCAI99, páginas 548-553, 1999. [6] G. Gottlob, N. Leone y F. Scarcello. Ladrones, marshals y guardias: caracterizaciones lógicas y teóricas de la amplitud de hiperárboles. Revista de Ciencias de la Computación y de Sistemas, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone y S. Scarcello. Descomposiciones de hiperárboles y consultas tratables. Revista de Ciencias de la Computación y de Sistemas, 63(3):579-627, 2002. [8] H. H. Hoos y C. Boutilier. Resolviendo subastas combinatorias utilizando búsqueda local estocástica. En Proc. de AAAI00, páginas 22-29, 2000. [9] D. Johnson. Un catálogo de clases de complejidad. En P. Cramton, Y. Shoham y R. Steinberg, editores, Manual de Ciencias de la Computación Teórica, Volumen A: Algoritmos y Complejidad, páginas 67-161. 1990. [10] N. Korte y R. H. Mohring. Un algoritmo incremental de tiempo lineal para reconocer grafos de intervalo. Revista SIAM sobre Computación, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller y T. Sandholm. El Problema de Determinación del Ganador. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, y Y. Shoham. Revelación de la verdad en aproximadamente 160 subastas combinatorias eficientes. J. ACM, 49(5):577-602, 2002. [13] R. McAfee y J. McMillan. Analizando la subasta de las ondas aéreas. Revista de Perspectivas Económicas, 10(1):159-175, 1996. [14] J. McMillan. Vendiendo derechos de espectro. Revista de Perspectivas Económicas, 8(3):145-62, 1994. [15] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. de EC00, páginas 1-12, 2000. [16] N. Robertson y P. Seymour. Menores de grafos ii. Aspectos algorítmicos del ancho de árbol. Revista de Algoritmos, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias computacionalmente manejables. Ciencia de la Gestión, 44:1131-1147, 1998. [18] T. Sandholm. Una implementación del protocolo de red de contratos basada en cálculos de costos marginales. En Proc. de AAAI93, páginas 256-262, 1993. [19] T. Sandholm. Algoritmo para la determinación óptima del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, 2002. [20] T. Sandholm. Algoritmos de determinación de ganadores. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [21] T. Sandholm y S. Suri. Bob: Mejora en la determinación de ganadores en subastas combinatorias y generalizaciones. Inteligencia Artificial, 7:33-58, 2003. [22] M. Tennenholtz. Algunas subastas combinatorias manejables. En Proc. de AAAI00, páginas 98-103, 2000. [23] E. Zurel y N. Nisan. Un algoritmo de asignación aproximada eficiente para subastas combinatorias. En Proc. de EC01, páginas 125-136, 2001. 161 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "complexity of structured item graph": {
            "translated_key": "complejidad del grafo de elementos estructurados",
            "is_in_text": false,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "structured item graph complexity": {
            "translated_key": "complejidad del gráfico de elementos estructurados",
            "is_in_text": false,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "simplification of the primal graph": {
            "translated_key": "simplificación del grafo primal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best <br>simplification of the primal graph</br> were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "Polynomial time algorithms to find the best <br>simplification of the primal graph</br> were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so."
            ],
            "translated_annotated_samples": [
                "Los algoritmos de tiempo polinómico para encontrar la mejor <br>simplificación del grafo primal</br> solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. Los algoritmos de tiempo polinómico para encontrar la mejor <br>simplificación del grafo primal</br> solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo. Empaquetamiento de conjuntos ponderado. Cabe destacar que la representación de hipergrafo H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en hipergrafos (por ejemplo, [17]). Formalmente, un empaquetamiento h para un hipergrafo H es un conjunto de hiperarcos de H tal que para cada par h, h ∈ h con h ≠ h, se cumple que h ∩ h = ∅. Si se deja que w sea una función de ponderación para H, es decir, una función computable en tiempo polinómico de E(H) a números racionales, el peso de un empaquetado h es el número racional w(h) = h∈h w(h), donde w({}) = 0. Entonces, el problema de empaquetamiento de conjuntos con peso máximo para H con respecto a w, denotado por MaxWSP(H, w), es el problema de encontrar un empaquetamiento para H que tenga el peso máximo entre todos los empaquetamientos para H. Para ver que MaxWSP es simplemente una formulación diferente para el problema de determinación del ganador, dado una subasta combinatoria I, B, es suficiente definir la función de ponderación w I,B (elemento(Bi)) = pago(Bi). Entonces, el conjunto de soluciones para el problema de empaquetamiento de conjuntos ponderados para H I,B con respecto a w I,B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, B. Ejemplo 2. Considera nuevamente el hipercubo H I0,B0 reportado en la Figura 1.(a). Un ejemplo de empaquetado para H I0, B0 es h = {h1}, que intuitivamente corresponde a un resultado para I0, B0, donde el subastador aceptó la oferta B1. Al asumir que las ofertas B1, B2 y B3 son tales que pay(B1) = pay(B2) = pay(B3), el empaquetado h no es una solución para el problema MaxWSP(H I0,B0 , w I0,B0). De hecho, el empaque h∗ = {h2, h3} es tal que w I0,B0 (h∗ ) > w I0,B0 (h). ¡Contribuciones! El objetivo principal de este artículo es identificar clases grandes y manejables para el problema de determinación del ganador, que además sean reconocibles de forma polinómica. Con este objetivo, primero estudiamos grafos de elementos estructurados y resolvemos el problema abierto en [3]. El resultado es una noticia muy mala: es NP completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado de ancho de árbol 3. De manera más formal, dejando que C(ig, k) denote la clase de todos los hipergrafos que tienen un árbol de ítems con un ancho de árbol limitado por k, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C(ig, 3) es NP-completo. A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que puedan ser verificados en tiempo polinómico y que aún puedan ser utilizados para aislar clases tratables del problema de empaquetamiento de conjuntos con peso máximo o, equivalentemente, el problema de determinación del ganador. Nuestras investigaciones, esta vez, llevaron a noticias muy buenas que se resumen a continuación: Para un hipercubo H, su dual ¯H = (V, E) es tal que los nodos en V están en correspondencia uno a uno con los hiperarcos en H, y para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} está en E. Mostramos que MaxWSP es tratable en la clase de aquellas instancias cuyos hipercubos duales tienen un ancho de hiperárbol[7] limitado por k (abreviado: clase C(hw, k) de hipercubos). Cabe destacar que un problema clave de la tratabilidad es considerar el ancho de hiperárbol del hipergrafo dual ¯H en lugar del hipergrafo de subastas H. De hecho, podemos demostrar que MaxWSP sigue siendo NP-duro incluso cuando H es acíclico (es decir, cuando tiene un ancho de hiperárbol de 1), incluso cuando cada nodo está contenido en un máximo de 3 hiperarcos. Para algunas clases especiales relevantes de hipergrafos en C(hw, k), diseñamos un algoritmo altamente paralelizable para MaxWSP. Específicamente, si las funciones de ponderación se pueden calcular en espacio logarítmico y los pesos son polinomiales (por ejemplo, cuando todos los hiperarcos tienen pesos unitarios y se está interesado en encontrar el empaquetamiento con el máximo número de arcos), demostramos que MaxWSP puede resolverse mediante un algoritmo LOGCFL. Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son reducibles en espacio logarítmico a lenguajes libres de contexto, y que LOGCFL ⊆ NC2 ⊆ P (ver, por ejemplo, [9]). Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la descomposición de hipertree de los hipergrafos duales en lugar de la treewidth de los grafos de elementos. Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados. De hecho, demostramos que clases de instancias estrictamente más grandes son tratables según nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados. De manera intuitiva, la NP-dificultad de reconocer grafos de elementos estructurados de ancho acotado no se debe a su gran generalidad, sino más bien a algunas peculiaridades en su definición. La prueba de los resultados anteriores nos brinda una perspectiva interesante sobre la noción de grafo de elementos estructurados. De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos descomposiciones de hiperárboles estrictas. También se propone una caracterización de juego para la noción de ancho de hiperárbol estricto, que se especializa en el juego de Ladrón y Policías en [6] (propuesto para caracterizar el ancho de hiperárbol), y que aclara los requisitos adicionales sobre las descomposiciones de hiperárboles. El resto del documento está organizado de la siguiente manera. La sección 2 discute la intratabilidad de los grafos de elementos estructurados. La sección 3 presenta el algoritmo de tiempo polinómico para resolver MaxWSP en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hipertree acotado, y discute los casos en los que el algoritmo también es altamente paralelizable. La comparación entre las clases C(ig, k) y C(hw, k) se discute en la Sección 4. Finalmente, en la Sección 5 sacamos nuestras conclusiones también delineando las direcciones para futuras investigaciones. 2. COMPLEJIDAD DE LOS GRAFOS DE ELEMENTOS ESTRUCTURADOS Sea H un hipergrafo. Un grafo G = (V, E) es un grafo de elementos para H si V = N(H) y, para cada h ∈ E(H), el subgrafo de G inducido sobre los nodos en h está conectado. Una clase importante de grafos de elementos es la de grafos de elementos estructurados, es decir, aquellos grafos de elementos que tienen un ancho de árbol acotado como se formaliza a continuación. Una descomposición de árbol [16] de un grafo G = (V, E) es un par T, χ, donde T = (N, F) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjunto de vértices χ(p) ⊆ V, de modo que se satisfacen las siguientes condiciones: (1) para cada vértice b de G, existe un p ∈ N tal que b ∈ χ(p); (2) para cada arista {b, d} ∈ E, existe un p ∈ N tal que {b, d} ⊆ χ(p); (3) para cada vértice b de G, el conjunto {p ∈ N | b ∈ χ(p)} induce un subárbol conectado de T. El ancho de T, χ es el número maxp∈N |χ(p) − 1|. El treewidth de G, denotado por tw(G), es el ancho mínimo sobre todas sus descomposiciones en árboles. El problema de determinación del ganador puede resolverse en tiempo polinómico en grafos de elementos con treewidth acotado [3]. Teorema 1 (cf. [3]). Se tiene una descomposición en árbol de ancho k T, χ de un grafo de elementos para H. Entonces, MaxWSP(H, w) se puede resolver en tiempo O(|T|2 ×(|E(H)|+1)k+1 ). Muchos gráficos de elementos pueden estar asociados con un hipergráfico. Como ejemplo, observe que el grafo de elementos en la Figura 1. (c) tiene un ancho de árbol de 1, mientras que la Figura 1. (d) muestra un grafo de elementos cuyo ancho de árbol es 2. De hecho, era una pregunta abierta si, para una constante k dada, se puede verificar en tiempo polinómico si existe un grafo de ítems de ancho de árbol k, y en caso afirmativo, si dicho grafo de ítems se puede calcular eficientemente. La principal tarea de esta sección es demostrar que la clase C(ig, k) es difícil de reconocer. Teorema 2. Decidir si un hipergrafo H pertenece a C(ig, 3) es NP-difícil. La prueba de este resultado se basa en una reducción elaborada del problema de camino hamiltoniano HP(s, t) que consiste en decidir si hay un camino hamiltoniano desde un nodo s hasta un nodo t en un grafo dirigido G = (N, E). Para ayudar a la intuición, aquí presentamos una descripción general de alto nivel de los principales ingredientes utilizados en la prueba. La idea general es construir un hipercubo HG de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución. Primero, discutimos la forma en que se construye HG. Ver la Figura 2. (a) para una ilustración, donde el grafo G consiste en los nodos s, x, y, y t, y el conjunto de sus aristas es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. De G a HG. Sea G = (N, E) un grafo dirigido. Entonces, el conjunto de nodos en HG es tal que: para cada x ∈ N, N(HG) contiene los nodos bsx, btx, bx, bx, bdx; para cada e = (x, y) ∈ E, N(HG) contiene los nodos nsx, nsx, nty, nty, nsex y ntey. Ningún otro nodo está en N(HG). Los hiperarcos en HG son de tres tipos: 1) para cada x ∈ N, E(HG) contiene los hiperarcos: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, y A3 x = {bx, bx} -nota que estos hiperarcos inducen una clique en los nodos {bx, bx, bdx}; 1 Las pruebas detalladas se pueden encontrar en el Apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf. Figura 2: Prueba del Teorema 2: (a) de G a HG - solo se reportan los hiperarcos en 1) y 2); (b) un esqueleto para una descomposición en árbol TD para HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, y TA3 x = {btx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {btx, bx, bx, bdx}; 2) para cada e = (x, y) ∈ E, E(HG) contiene los hiperarcos: • SHx = {nsx, nsx}; • THy = {nty, nty}; • SEe = {nsx, nse x} y SEe = {nsx, nse x} -nota que estos dos hiperarcos más SHx inducen una clique en los nodos {nsx, nsx, nse x}; • TEe = {nty, nte y} y TEe = {nty, nte y} -nota que estos dos hiperarcos más THy inducen una clique en los nodos {nty, nty, nte y}. Observa que cada uno de los hiperarcos anteriores, excepto aquellos de la forma Sx y Tx, contiene exactamente dos nodos. Como ejemplo de los hiperarcos de tipo 1) y 2), el lector puede referirse a la construcción de ejemplo reportada en la Figura 2. (a), y notar, por ejemplo, que Sx = {bsx, nse2 x, nse3 x} y que Tt = {btt, nte4 t, nte3 t}. 3) finalmente, denotamos por DG al conjunto que contiene los hiperarcos en E(HG) del tercer tipo. En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperarcos que satisfacen las cuatro condiciones que se discuten a continuación. Sea PG el conjunto de los siguientes |PG| ≤ |N| + 3 × |E| pares: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}. Además, sea I(v) el conjunto {h ∈ E(H) | v ∈ h} de los hiperarcos de H que son tocados por v; y, para un conjunto V ⊆ N(H), sea I(V) = v∈V I(v). Entonces, DG tiene que ser un conjunto tal que: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ PG o (β, α) ∈ PG, se cumple: I(α) ∩ DG = ∅; y, (c4) ∀S ⊆ N tal que |S| ≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ PG, se cumple que: I(S) ⊇ DG. De manera intuitiva, el conjunto DG es tal que cada una de sus hiperaristas es tocada exactamente por uno de los dos nodos en cada par de PG, cf. (c1) y (c2). Además, los hiperarcos en DG solo tocan vértices incluidos en al menos un par de PG - cf. (c3); y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se pueden construir a partir de él pertenece a PG - cf. (c4). El lector puede preguntarse ahora si existe un conjunto DG que satisfaga (c1), (c2), (c3) y (c4). En el siguiente lema, respondemos positivamente a esta pregunta y referimos al lector a su demostración para un ejemplo de construcción. Lema 1. Un conjunto DG, con |DG| = 2 × |PG| + 2, que cumple las condiciones (c1), (c2), (c3) y (c4) se puede construir en tiempo O(|PG|2). Ingredientes clave. Ahora estamos en la posición de presentar una visión general de los ingredientes clave de la prueba. Sea G un grafo de elementos arbitrario para HG, y sea TD = T, χ una descomposición de árbol de ancho 3 de G (nota que, debido a las cliques, por ejemplo, en los nodos {bsx, bx, bx, bdx}, cualquier grafo de elementos para HG tiene un ancho de árbol de al menos 3). Hay tres observaciones básicas que sirven para demostrar la corrección de la reducción. Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértices. Específicamente, para cada nodo x ∈ N, TD contiene un vértice bs(x) tal que χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, y un vértice bt(x) tal que χ(bt(x)) ⊇ {btx, bx, bx, bdx}. Y, para cada arista e = (x, y) ∈ E, TD contiene un vértice ns(x,e) tal que χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, y un vértice nt(y,e) tal que χ(nt(y,e)) ⊇ {nte y, nty, nty}. Intuitivamente, se requiere que estos vértices cubran los cliques de HG asociados con los hiperarcos de tipo 1) y 2). Cada uno de estos vértices desempeña un papel específico en la reducción. De hecho, cada arista dirigida e = (x, y) ∈ E está codificada en TD mediante los vértices: ns(x,e), que representan precisamente que e comienza en x; y nt(y,e), que representan precisamente que e termina en y. Además, cada nodo x ∈ N está codificado en TD mediante los vértices: bs(x), que representa el punto de inicio de las aristas que se originan en x; y, bt(x), que representa el punto de terminación de las aristas que terminan en x. Como ejemplo, la Figura 2. (b) muestra el esqueleto de una descomposición de árbol TD. El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el hipercubo HG en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación. La conexión entre bloques y la unicidad de las conexiones: La segunda observación crucial es que en el camino que conecta un vértice de la forma bs(x) (resp., bt(y)) con un vértice de la forma ns(x,e) (resp., nt(y,e)) hay un vértice especial de la forma w(x,y) tal que: χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E. Garantizar la existencia de un vértice así es precisamente el papel que desempeñan los hiperarcos en DG. Los argumentos para la prueba son los siguientes. Primero, observamos que I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} e I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}. Luego, mostramos una propiedad que establece que para un par de vértices consecutivos p y q en el camino que conecta bs(x) y ns(x,e) (resp., bt(y) y nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))). Por lo tanto, tenemos: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (o bien, I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}). Basándose en esta observación, y al explotar las propiedades de los hiperarcos en DG, no es difícil demostrar que cualquier par de vértices consecutivos p y q deben compartir dos nodos de HG formando un par en PG, y ambos deben tocar Sx (resp., Ty). Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w(x,y), en este camino es tal que χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E - para ello, note que nse x ∈ Sx, nte t ∈ Ty, e I(χ(w(x,y))) ⊇ DG. En particular, w(x,y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay otro vértice de la forma w(x,z), para z = y (o bien, w(z,y), para z = x). Para ayudar a la intuición, observamos que tener un vértice de la forma w(x,y) en TD corresponde a la selección de un borde desde el nodo x hasta el nodo y en el camino hamiltoniano. De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de un camino hamiltoniano para G y los vértices de la forma w(x,y). Como ejemplo, en la Figura 2. (b), los vértices de la forma w(s,x), w(x,y) y w(y,t) están en TD, y GT D muestra el camino hamiltoniano correspondiente. Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w(x, y), para una arista e = (x, y) ∈ E no está en TD (es decir, si la arista (x, y) no pertenece al camino hamiltoniano), entonces el bloque correspondiente ns(x, e) (resp., nt(y, e)) puede ser agregado arbitrariamente en el subárbol enraizado en el bloque ns(x, e) (resp., nt(y, e)), donde e es la arista de la forma e = (x, z) (resp., e = (z, y)) tal que w(x, z) (resp., w(z, y)) está en TD. Por ejemplo, la Figura 2. (a) muestra w(x,t), que no se utiliza en TD, y la Figura 2. (b) muestra cómo los bloques ns(x,e3) y nt(t,e3) pueden ser dispuestos en TD para garantizar la condición de conectividad. CASOS TRACTABLES MEDIANTE DESCOMPOSICIONES DE HIPERÁRBOLES Dado que construir grafos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden ser utilizadas para identificar clases de instancias de MaxWSP tratables. Con este fin, nos enfocamos en la noción de descomposición de hiperárboles [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros. Un hypertree para un hipercubo H es un triple T, χ, λ, donde T = (N, E) es un árbol raíz, y χ y λ son funciones de etiquetado que asocian a cada vértice p ∈ N con dos conjuntos χ(p) ⊆ N(H) y λ(p) ⊆ E(H). Si T = (N, E) es un subárbol de T, definimos χ(T) = v∈N χ(v). Denotamos el conjunto de vértices N de T como vertices(T). Además, para cualquier p ∈ N, Tp denota el subárbol de T con raíz en p. Definición 1. Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p). El ancho de una descomposición de hipertree T, χ, λ es maxp∈vertices(T )|λ(p)|. El ancho de HYPERTREE hw(H) de H es el ancho mínimo sobre todas sus descomposiciones hypertree. Un hipergrafo H es acíclico si hw(H) = 1. Ejemplo 3. El hipergrafo H I0,B0 reportado en la Figura 1. (a) es un ejemplo de hipergrafo acíclico. En cambio, tanto los hipergráficos H1 y ¯H1 mostrados en la Figura 3. (a) y la Figura 3. (b), respectivamente, no son acíclicos ya que su anchura de hipertiempo es 2. Se reporta una descomposición de hipertree de ancho 2 para ¯H1 en la Figura 3.(c). En particular, observe que H1 se ha obtenido agregando los dos hiperarcos h4 y h5 a H I0,B0 para modelar, por ejemplo, que dos nuevas ofertas, B4 y B5, respectivamente, han sido propuestas al subastador. En lo siguiente, en lugar de trabajar en el hipercampo H asociado con un problema de MaxWSP, trataremos con su dual ¯H, es decir, con el hipercampo tal que sus nodos están en correspondencia uno a uno con los hiperarcos de H, y donde para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} está en E( ¯H). Como ejemplo, el lector puede querer revisar nuevamente el hipercubo H1 en la Figura 3 (a) y notar que el hipercubo en la Figura 3 (b) es de hecho su dual. La razón de esta elección es que imponer restricciones en el hipercubo original garantiza la tratabilidad solo en escenarios muy simples. Teorema 3. En la clase de hipergrafos acíclicos, MaxWSP está (1) en P si cada nodo ocurre en un máximo de dos hiperarcos; y, (2) NP-duro, incluso si cada nodo está contenido en un máximo de tres hiperarcos. 3.1 Descomposición de hiperárboles en el hipergrafo dual y problemas de empaquetamiento tratables Para una constante fija k, sea C(hw, k) la clase de todos los hipergrafos cuyos hipergrafos duales tienen un ancho de hiperárbol limitado por k. El problema de empaquetamiento de conjuntos con peso máximo se puede resolver en tiempo polinómico en la clase C(hw, k) mediante el algoritmo ComputeSetPackingk, mostrado en la Figura 4. El algoritmo recibe como entrada un hipercubo H, una función de ponderación w, y una descomposición de hipertree de ancho k HD = T=(N, E), χ, λ de ¯H. Para cada vértice v ∈ N, sea Hv el hipergrafo cuyo conjunto de nodos N(Hv) ⊆ N(H) coincide con λ(v), y cuyo conjunto de aristas E(Hv) ⊆ E(H) coincide con χ(v). En un paso de inicialización, el algoritmo equipa a cada vértice v con todos los empaquetamientos posibles para Hv, los cuales se almacenan en el conjunto Hv. Se debe tener en cuenta que el tamaño de Hv está limitado por (|E(H)| + 1)k, ya que cada nodo en λ(v) está sin cubrir en un empaquetamiento o está cubierto precisamente por una de las hiperaristas en χ(v) ⊆ E(H). Entonces, ComputeSetPackingk está diseñado para filtrar estos empaquetamientos conservando solo aquellos que se ajusten a algún empaquetamiento para Hc, para cada hijo c de v en T, como se formaliza a continuación. Dejen que hv y hc sean dos empaquetados para Hv y Hc, respectivamente. Decimos que hv se ajusta a hc, indicado por hv ≈ hc si: para cada h ∈ hc ∩ E(Hv), h está en hv; y, para cada h ∈ (E(Hc) − hc), h no está en hv. Ejemplo 4. Considera nuevamente la descomposición de hipertree de ¯H1 reportada en la Figura 3.(c). Luego, el conjunto de todos los empaquetados posibles (que se construyen en el paso de inicialización de ComputeSetPackingk), para cada uno de sus vértices, se reFigure 5: Ejemplo de aplicación del Algoritmo ComputeSetPackingk. 157 Entrada: H, w, y una descomposición de hipertree de ancho k HD = T = (N, E), χ, λ de ¯H; Salida: Una solución para MaxWSP(H, w); var Hv: conjunto de empaquetados para Hv, para cada v ∈ N; h∗: empaquetado para H; v hv: número racional, para cada empaquetado parcial hv para Hv; hhv,c: empaquetado parcial para Hc, para cada empaquetado parcial hv para Hv, y para cada (v, c) ∈ E; -------------------------------------------Procedimiento BottomUp; begin Done := el conjunto de todas las hojas de T; mientras ∃v ∈ T tal que (i) v ∈ Done, y (ii) {c | c es hijo de v} ⊆ Done hacer para cada c tal que (v, c) ∈ E hacer Hv := Hv - {hv | ∃hc ∈ Hc tal que hv ≈ hc}; para cada hv ∈ Hv hacer v hv := w(hv); para cada c tal que (v, c) ∈ E hacer ¯hc := arg maxhc∈Hc|hv≈ hc c hc - w(hc ∩ hv); hhv,c := ¯hc; (* establecer mejor empaquetado *) v hv := v hv + c ¯hc - w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end mientras end; -------------------------------------------begin (* PRINCIPAL *) para cada vértice v en T hacer Hv := {hv empaquetado para Hv}; BottomUp; sea r la raíz de T; ¯hr := arg maxhr∈Hr r hr; h∗ := ¯hr; (* incluir empaquetado *) T opDown(r, hr); return h∗; end. Procedimiento TopDown(v: vértice de N, ¯hv ∈ Hv); comenzar para cada c ∈ N tal que (v, c) ∈ E hacer ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* incluir empaquetado *) TopDown(c, ¯hc); fin para fin; Figura 4: Algoritmo ComputeSetPackingk. representado en la Figura 5.(a). Por ejemplo, la raíz v1 es tal que Hv1 = { {}, {h1}, {h3}, {h5} }. Además, una flecha de un empaque hc a hv indica que hv cumple con hc. Por ejemplo, el lector puede comprobar que el empaquetado {h3} ∈ Hv1 se ajusta al empaquetado {h2, h3} ∈ Hv3, pero no se ajusta a {h1} ∈ Hv3. ¡ComputeSetPackingk construye una solución recorriendo T en dos fases. En la primera fase, los vértices de T se procesan desde las hojas hasta la raíz r, mediante el procedimiento BottomUp. Para cada nodo v que se está procesando, el conjunto Hv se actualiza preliminarmente eliminando todos los empaquetados hv que no cumplen con ningún empaquetado para algunos de los hijos de v. Después de realizar este filtrado, se actualiza el peso hv. De manera intuitiva, v hv almacena el peso del mejor empaquetado parcial para H calculado utilizando solo los hiperarcos que ocurren en χ(Tv). De hecho, si v es una hoja, entonces v hv = w(hv). De lo contrario, para cada hijo c de v en T, v hv se actualiza con el máximo de c hc - w(hc ∩ hv) sobre todos los empaquetados hc que se ajustan a hv (resolviendo empates de forma arbitraria). El empaque ¯hc para el cual se logra este máximo se almacena en la variable hhv,c. En la segunda fase, el árbol T se procesa comenzando desde la raíz. En primer lugar, se selecciona el empaque h∗ que maximiza el peso equipado con los empaques en Hr. Luego, el procedimiento TopDown se utiliza para extender h∗ a todos los otros empaquetamientos parciales para los vértices de T. En particular, en cada vértice v, h∗ se extiende con el empaquetamiento hhv,c, para cada hijo c de v. Ejemplo 5. Supongamos que, en nuestro ejemplo en curso, w(h1) = w(h2) = w(h3) = w(h4) = 1. Luego, una ejecución de ComputeSetPackingk se representa gráficamente en la Figura 5. (b), donde una flecha de un empaquetado hc a un empaquetado hv se utiliza para denotar que hc = hhv,c. Específicamente, las elecciones realizadas durante el cálculo son tales que se calcula el empaquetamiento {h2, h3}. En particular, durante la fase de abajo hacia arriba, tenemos que: (1) se procesa v4 y establecemos v4 {h2} = v4 {h4} = 1 y v4 {} = 0; (2) se procesa v3 y establecemos v3 {h1} = v3 {h3} = 1 y v3 {} = 0; (3) se procesa v2 y establecemos v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 y v3 {} = 0; (4) se procesa v1 y establecemos v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 y v1 {} = 0. Por ejemplo, observe que v1 {h5} = 2 ya que {h5} se ajusta al empaquetado {h4} de Hv2 de tal manera que v2 {h4} = 1. Entonces, al comienzo de la fase de arriba hacia abajo, ComputeSetPackingk selecciona {h3} como un empaquetado para Hv1 y propaga esta elección en el árbol. De manera equivalente, el algoritmo pudo haber elegido {h5}. Como ejemplo adicional, se informa en la Figura 5.(c) la forma en que se obtiene la solución {h1} mediante el algoritmo cuando w(h1) = 5 y w(h2) = w(h3) = w(h4) = 1. Observa que, en esta ocasión, en la fase de arriba hacia abajo, ComputeSetPackingk comienza a seleccionar {h1} como el mejor empaquetado para Hv1. ¡Teorema 4. Sea H un hipergrafo y w una función de ponderación para él. Sea HD = T, χ, λ una descomposición de hipertree completa de ancho k de ¯H. Entonces, ComputeSetPackingk en la entrada H, w y HD produce correctamente una solución para MaxWSP(H, w) en tiempo O(|T| × (|E(H)| + 1)2k. Prueba. [Bosquejo] Observamos que h∗ (calculado por ComputeSetPackingk) es un empaquetamiento para H. De hecho, consideremos un par de hiperarcos h1 y h2 en h∗, y supongamos, para efectos de contradicción, que h1 ∩ h2 = ∅. Sea v1 (resp., v2) un vértice arbitrario de T, para el cual ComputeSetPackingk incluyó h1 (resp., h2) en h∗ en el cálculo de abajo hacia arriba. Por construcción, tenemos h1 ∈ χ(v1) y h2 ∈ χ(v2). Sea I un elemento en h1 ∩ h2. En el hipergrafo dual H, I es un hiperborde en E(¯H) que cubre tanto los nodos h1 como h2. Por lo tanto, por la condición (1) en la Definición 1, existe un vértice v ∈ vértices(T) tal que {h1, h2} ⊆ χ(v). Se debe tener en cuenta que, debido a la condición de conectividad en la Definición 1, también podemos asumir, sin pérdida de generalidad, que v está en el camino que conecta v1 y v2 en T. Sea hv ∈ Hv el elemento añadido por ComputeSetPackingk en h∗ durante la fase de abajo hacia arriba. Dado que los elementos en Hv son empaquetamientos para Hv, se cumple que o bien h1 ∈ hv o h2 ∈ hv. Supongamos, sin pérdida de generalidad, que h1 ∈ hv, y notemos que cada vértice w en T en el camino que conecta v con v1 es tal que h1 ∈ χ(w), debido a la condición de conectividad. Por lo tanto, debido a la definición de conformidad, el empaque hw seleccionado por ComputeSetPackingk para ser agregado en el vértice w en h∗ debe ser tal que h1 ∈ hw. Esto se cumple en particular para w = v1. Contradicción con la definición de v1. Por lo tanto, h∗ es un empaquetamiento para H. Queda entonces por demostrar que tiene el peso máximo sobre todos los empaquetamientos para H. Con este fin, podemos utilizar la inducción estructural en T para demostrar que, en la fase de abajo hacia arriba, la variable v hv se actualiza para contener el peso del empaquetamiento en las aristas en χ(Tv), que contiene hv y que tiene el peso máximo sobre todos los empaquetamientos para las aristas en χ(Tv). Entonces, el resultado sigue, ya que en la fase de arriba hacia abajo, el empaquetado hr que da el peso máximo sobre χ(Tr) = E(H) se incluye primero en h∗, y luego se extiende en cada nodo c con el empaquetado hhv,c de forma conforme con hv y de manera que se alcance el valor máximo de v hv. En cuanto a la complejidad, observe que el paso de inicialización requiere la construcción del conjunto Hv, para cada vértice v, y cada conjunto tiene un tamaño de (|E(H)| + 1)k como máximo. Luego, la función BottomUp verifica la conformidad entre las estrategias en Hv con las estrategias en Hc, para cada par (v, c) ∈ E, y actualiza el peso v hv. Estas tareas pueden llevarse a cabo en tiempo O((|E(H)| + 1)2k) y deben repetirse para cada arista en T, es decir, O(|T|) veces. Finalmente, la función TopDown puede implementarse en tiempo lineal en el tamaño de T, ya que solo requiere actualizar h∗ accediendo a la variable hhv,c. El resultado anterior muestra que si se proporciona una descomposición de hipertree de ancho k, el problema MaxWSP se puede resolver de manera eficiente. Además, a diferencia del caso de los grafos de elementos estructurados, es bien sabido que decidir la existencia de una descomposición de hipertree acotada por k y calcular una (si existe alguna) son problemas que pueden resolverse eficientemente en tiempo polinómico [7]. Por lo tanto, el Teorema 4 confirma que la clase C(hw, k) constituye en realidad una clase manejable para el problema de determinación del ganador. Como muestra el siguiente teorema, para subclases grandes (que dependen solo de cómo se especifica la función de peso), MaxWSP(H, w) es altamente paralelizable. Llamemos a una función de ponderación suave si es computable en espacio logarítmico y si todos los pesos son polinomiales (y por lo tanto solo requieren O(log n) bits para su representación). Recuerde que LOGCFL es una clase de complejidad paralela contenida en NC2, cf. [9]. La versión funcional de LOGCFL es LLOGCFL, la cual se obtiene equipando un transductor de espacio logarítmico con un oráculo en LOGCFL. Teorema 5. Sea H un hipergrafo en C(hw, k), y sea w una función de ponderación suave para él. Entonces, MaxWSP(H, w) está en LLOGCFL. 4. Dadas las descomposiciones de hipertree frente a los grafos de elementos estructurados, y considerando que se ha demostrado que la clase C(hw, k) es una isla de tratabilidad para el problema de determinación del ganador, y dado que se ha demostrado que la clase C(ig, k) no es reconocible eficientemente, uno podría inclinarse a pensar que existen instancias con ancho de hipertree ilimitado, pero que admiten un grafo de elementos de ancho de árbol acotado (por lo que la intratabilidad de los grafos de elementos estructurados residiría en su generalidad). Sorprendentemente, establecemos que este no es el caso. La clave de la prueba es primero demostrar que los grafos de elementos estructurados están en correspondencia uno a uno con un tipo especial de descomposiciones de hiperárboles del hipergrafo dual, al que llamaremos estricto. Entonces, el resultado seguirá al demostrar que las descomposiciones estrictas de hipertree de ancho k son menos potentes que las descomposiciones de hipertree de ancho k. 4.1 Descomposiciones estrictas de hipertree Deje que H sea un hipergrafo, y V ⊆ N(H) sea un conjunto de nodos y X, Y ∈ N(H). X es [V]-adyacente a Y si existe un borde h ∈ E(H) tal que {X, Y} ⊆ (h - V). Un camino [V] π de X a Y es una secuencia X = X0, . . . , X = Y de variables tal que: Xi es [V]-adyacente a Xi+1, para cada i ∈ [0... -1]. Un conjunto W ⊆ N(H) de nodos está [V]-conectado si ∀X, Y ∈ W hay un [V]-camino de X a Y. Un componente [V ] es un conjunto maximal no vacío de nodos W ⊆ (N(H) − V ) que está [V ]-conectado. Para cualquier componente [V] C, sea E(C) = {h ∈ E(H) | h ∩ C = ∅}. Definición 2. Una descomposición de hipertree HD = T, χ, λ de H es estricta si se cumplen las siguientes condiciones: 1. para cada par de vértices r y s en los vértices de T tal que s es un hijo de r, y para cada componente [χ(r)]-Cr. La intersección de Cr con χ(Ts) es vacía, Cr es un componente de [χ(r) ∩ N(λ(r) ∩ λ(s))]; 2. para cada arista h ∈ E(H), hay un vértice p tal que h ∈ λ(p) y h ⊆ χ(p) (decimos que p cubre fuertemente a h); 3. para cada arista h ∈ E(H), el conjunto {p ∈ vértices(T) | h ∈ λ(p)} induce un subárbol (conectado) de T. La anchura estricta de hipertree shw(H) de H es la anchura mínima sobre todas sus descomposiciones estrictas de hipertree. La relación básica entre las descomposiciones de hipertree agradables y los grafos de elementos estructurados se muestra en el siguiente teorema. Teorema 6. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, una k-anchura descomposición en árbol de un grafo de elementos para H existe si y solo si ¯H tiene una (k + 1)-anchura descomposición estricta en hiperárbol. Se debe tener en cuenta que, en lo que respecta al problema de empaquetamiento de conjuntos ponderados máximo, dado un hipercubo H, siempre podemos asumir que para cada nodo v ∈ N(H), {v} está en E(H). De hecho, si esta hiperarista no está en el hipercubo, entonces se puede agregar sin pérdida de generalidad, estableciendo w({v}) = 0. Por lo tanto, dejando que C(shw, k) denote la clase de todos los hipergrafos cuyos hipergrafos duales (asociados con un máximo de 2 términos +1) solo juegan el papel técnico de ocuparse de la diferente definición de ancho para las descomposiciones de árboles y las descomposiciones de hiperárboles. 159 problemas de empaquetamiento de conjuntos ponderados) tienen un ancho de hiperárbol estricto limitado por k, tenemos que C(shw, k + 1) = C(ig, k). Por definición, las descomposiciones de hipertree estrictas son descomposiciones de hipertree especiales. De hecho, podemos demostrar que las condiciones adicionales en la Definición 2 inducen una restricción real en el poder de descomposición. Teorema 7. C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). \n\nC(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). Una vista desde la teoría de juegos. Arrojamos más luz sobre las descomposiciones estrictas de hypertrees al discutir una interesante caracterización basada en el juego estricto de Robber y Marshals, definido adaptando el juego de Robber y Marshals definido en [6], que caracteriza el ancho de hypertree. El juego se juega en un hipercubo H por un ladrón contra k marshals que actúan en coordinación. Los alguaciles se mueven en los hiperarcos de H, mientras que el ladrón se mueve en los nodos de H. El ladrón ve hacia dónde los alguaciles tienen la intención de moverse, y reacciona moviéndose a otro nodo que esté conectado con su posición actual y a través de un camino en G(H) que no utilice ningún nodo contenido en un hiperarco que esté ocupado por los alguaciles antes y después de su movimiento; decimos que estos hiperarcos están bloqueados. Ten en cuenta que en el juego básico definido en [6], al ladrón no se le permite moverse en vértices ocupados por los marshals antes y después de su movimiento, incluso si no pertenecen a hiperarcos bloqueados. Es importante que los marshals jueguen de manera monótona, es decir, no pueden ocupar un borde que haya sido ocupado previamente en el juego y que actualmente no lo esté. Los alguaciles ganan el juego si capturan al ladrón, ocupando un borde que cubra un nodo donde se encuentre el ladrón. De lo contrario, el ladrón gana. Teorema 8. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, ¯H tiene una descomposición estricta de hipertree de k-anchura si y solo si k marshals pueden ganar el Juego estricto de Robber y Marshals en ¯H, sin importar los movimientos de los ladrones. 5. CONCLUSIONES Hemos resuelto la pregunta abierta de determinar la complejidad de calcular un grafo de elementos estructurado asociado con un escenario de subasta combinatoria. El resultado es una mala noticia, ya que resultó que es NP-completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado, incluso para un ancho de árbol de 3. Motivados por este resultado, investigamos el uso de la descomposición de hiperárboles (en el hipergrafo dual asociado con el escenario) y demostramos que el problema es tratable en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hiperárbol acotado. Para algunos casos especiales y relevantes, también se discute un algoritmo altamente paralelizable. Curiosamente, también se descubrió que la clase de grafos de elementos estructurados está adecuadamente contenida en la clase de instancias con ancho de hiperárbol acotado (por lo tanto, la razón de su intratabilidad no es su generalidad). En particular, este último resultado se establece mostrando una relación precisa entre los grafos de elementos estructurados y formas restringidas de descomposiciones de hiperárboles (en el hipergrafo dual), llamadas descomposiciones de consultas (ver, por ejemplo, [7]). A la luz de esta observación, notamos que demostrar algunos resultados de aproximabilidad para grafos de elementos estructurados requiere una comprensión profunda de la aproximabilidad de las descomposiciones de consultas, la cual actualmente no se encuentra en la literatura. Como una vía adicional de investigación, sería relevante mejorar el algoritmo ComputeSetPackingk, por ejemplo, mediante el uso de estructuras de datos especializadas, con el fin de evitar la dependencia cuadrática de (|E(H)| + 1)k. Finalmente, otra pregunta interesante es evaluar si las técnicas de descomposición estructural discutidas en el artículo pueden ser utilizadas para abordar eficientemente generalizaciones del problema de determinación del ganador. Por ejemplo, podría ser relevante en varios escenarios de aplicación diseñar algoritmos que puedan encontrar una estrategia de venta cuando hay varias copias del mismo artículo disponibles para la venta, y además cuando el subastador está satisfecho cuando se venden al menos un número dado de copias. El trabajo de G. Gottlob fue apoyado por el EC3 - Centro de Competencia en Comercio Electrónico (Viena) y por un Premio de Mérito de Investigación Wolfson de la Royal Society. En particular, este premio permitió a Gottlob invitar a G. Greco para una visita de investigación a Oxford. Además, G. Greco cuenta con el apoyo de ICAR-CNR y del M.I.U.R. en el marco del proyecto TOCAI.IT. 6. REFERENCIAS [1] I. Adler, G. Gottlob y M. Grohe. Anchura de hipertree y invariantes de hipergrafo relacionados. En Proc. de EUROCOMB05, páginas 5-10, 2005. [2] C. Boutilier. Resolviendo problemas de subasta combinatoria expresados de manera concisa. En Proc. de AAAI02, páginas 359-366, 2002. [3] V. Conitzer, J. Derryberry y T. Sandholm. Subastas combinatorias con grafos de elementos estructurados. En Proc. de AAAI04, páginas 212-218, 2004. [4] E. M. Eschen y J. P. Sinrad. Un algoritmo O(n2) para el reconocimiento de grafos de arco circular. En Proc. de SODA93, páginas 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Óptimo y aproximado. En Proc. de IJCAI99, páginas 548-553, 1999. [6] G. Gottlob, N. Leone y F. Scarcello. Ladrones, marshals y guardias: caracterizaciones lógicas y teóricas de la amplitud de hiperárboles. Revista de Ciencias de la Computación y de Sistemas, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone y S. Scarcello. Descomposiciones de hiperárboles y consultas tratables. Revista de Ciencias de la Computación y de Sistemas, 63(3):579-627, 2002. [8] H. H. Hoos y C. Boutilier. Resolviendo subastas combinatorias utilizando búsqueda local estocástica. En Proc. de AAAI00, páginas 22-29, 2000. [9] D. Johnson. Un catálogo de clases de complejidad. En P. Cramton, Y. Shoham y R. Steinberg, editores, Manual de Ciencias de la Computación Teórica, Volumen A: Algoritmos y Complejidad, páginas 67-161. 1990. [10] N. Korte y R. H. Mohring. Un algoritmo incremental de tiempo lineal para reconocer grafos de intervalo. Revista SIAM sobre Computación, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller y T. Sandholm. El Problema de Determinación del Ganador. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, y Y. Shoham. Revelación de la verdad en aproximadamente 160 subastas combinatorias eficientes. J. ACM, 49(5):577-602, 2002. [13] R. McAfee y J. McMillan. Analizando la subasta de las ondas aéreas. Revista de Perspectivas Económicas, 10(1):159-175, 1996. [14] J. McMillan. Vendiendo derechos de espectro. Revista de Perspectivas Económicas, 8(3):145-62, 1994. [15] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. de EC00, páginas 1-12, 2000. [16] N. Robertson y P. Seymour. Menores de grafos ii. Aspectos algorítmicos del ancho de árbol. Revista de Algoritmos, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias computacionalmente manejables. Ciencia de la Gestión, 44:1131-1147, 1998. [18] T. Sandholm. Una implementación del protocolo de red de contratos basada en cálculos de costos marginales. En Proc. de AAAI93, páginas 256-262, 1993. [19] T. Sandholm. Algoritmo para la determinación óptima del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, 2002. [20] T. Sandholm. Algoritmos de determinación de ganadores. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [21] T. Sandholm y S. Suri. Bob: Mejora en la determinación de ganadores en subastas combinatorias y generalizaciones. Inteligencia Artificial, 7:33-58, 2003. [22] M. Tennenholtz. Algunas subastas combinatorias manejables. En Proc. de AAAI00, páginas 98-103, 2000. [23] E. Zurel y N. Nisan. Un algoritmo de asignación aproximada eficiente para subastas combinatorias. En Proc. de EC01, páginas 125-136, 2001. 161 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "the primal graph simplification": {
            "translated_key": "la simplificación del grafo primario",
            "is_in_text": false,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "structured item graph": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a <br>structured item graph</br> of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a <br>structured item graph</br> is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a <br>structured item graph</br>.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a <br>structured item graph</br>, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a <br>structured item graph</br> either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a <br>structured item graph</br> of a certain (constant) treewidth exists, and if so, how to compute such a <br>structured item graph</br> efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a <br>structured item graph</br> of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of <br>structured item graph</br>.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a <br>structured item graph</br> associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a <br>structured item graph</br>, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "In fact, the tractability of determining whether a <br>structured item graph</br> of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a <br>structured item graph</br> is computationally intractable, even for treewidth 3.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a <br>structured item graph</br>.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a <br>structured item graph</br>, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a <br>structured item graph</br> either is given or can be efficiently determined."
            ],
            "translated_annotated_samples": [
                "De hecho, la tratabilidad de determinar si existe un <br>grafo de ítems estructurados</br> con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial.",
                "En este artículo, resolvemos este problema demostrando que la existencia de un <br>grafo de elementos estructurados</br> es computacionalmente intratable, incluso para una treewidth de 3.",
                "Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un <br>grafo de elementos estructurado</br>.",
                "De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un <br>grafo de elementos estructurado</br>, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16].",
                "El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un <br>grafo de elementos estructurados</br> está dado o puede determinarse eficientemente."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un <br>grafo de ítems estructurados</br> con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un <br>grafo de elementos estructurados</br> es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un <br>grafo de elementos estructurado</br>. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un <br>grafo de elementos estructurado</br>, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un <br>grafo de elementos estructurados</br> está dado o puede determinarse eficientemente. ",
            "candidates": [],
            "error": [
                [
                    "grafo de ítems estructurados",
                    "grafo de elementos estructurados",
                    "grafo de elementos estructurado",
                    "grafo de elementos estructurado",
                    "grafo de elementos estructurados"
                ]
            ]
        },
        "fixed treewidth": {
            "translated_key": "ancho de árbol fijo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a <br>fixed treewidth</br> exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "In fact, the tractability of determining whether a structured item graph of a <br>fixed treewidth</br> exists (and if so, computing one) was left as a crucial open problem."
            ],
            "translated_annotated_samples": [
                "De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un <br>ancho de árbol fijo</br> (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un <br>ancho de árbol fijo</br> (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. Los algoritmos de tiempo polinómico para encontrar la mejor simplificación del grafo primal solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo. Empaquetamiento de conjuntos ponderado. Cabe destacar que la representación de hipergrafo H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en hipergrafos (por ejemplo, [17]). Formalmente, un empaquetamiento h para un hipergrafo H es un conjunto de hiperarcos de H tal que para cada par h, h ∈ h con h ≠ h, se cumple que h ∩ h = ∅. Si se deja que w sea una función de ponderación para H, es decir, una función computable en tiempo polinómico de E(H) a números racionales, el peso de un empaquetado h es el número racional w(h) = h∈h w(h), donde w({}) = 0. Entonces, el problema de empaquetamiento de conjuntos con peso máximo para H con respecto a w, denotado por MaxWSP(H, w), es el problema de encontrar un empaquetamiento para H que tenga el peso máximo entre todos los empaquetamientos para H. Para ver que MaxWSP es simplemente una formulación diferente para el problema de determinación del ganador, dado una subasta combinatoria I, B, es suficiente definir la función de ponderación w I,B (elemento(Bi)) = pago(Bi). Entonces, el conjunto de soluciones para el problema de empaquetamiento de conjuntos ponderados para H I,B con respecto a w I,B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, B. Ejemplo 2. Considera nuevamente el hipercubo H I0,B0 reportado en la Figura 1.(a). Un ejemplo de empaquetado para H I0, B0 es h = {h1}, que intuitivamente corresponde a un resultado para I0, B0, donde el subastador aceptó la oferta B1. Al asumir que las ofertas B1, B2 y B3 son tales que pay(B1) = pay(B2) = pay(B3), el empaquetado h no es una solución para el problema MaxWSP(H I0,B0 , w I0,B0). De hecho, el empaque h∗ = {h2, h3} es tal que w I0,B0 (h∗ ) > w I0,B0 (h). ¡Contribuciones! El objetivo principal de este artículo es identificar clases grandes y manejables para el problema de determinación del ganador, que además sean reconocibles de forma polinómica. Con este objetivo, primero estudiamos grafos de elementos estructurados y resolvemos el problema abierto en [3]. El resultado es una noticia muy mala: es NP completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado de ancho de árbol 3. De manera más formal, dejando que C(ig, k) denote la clase de todos los hipergrafos que tienen un árbol de ítems con un ancho de árbol limitado por k, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C(ig, 3) es NP-completo. A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que puedan ser verificados en tiempo polinómico y que aún puedan ser utilizados para aislar clases tratables del problema de empaquetamiento de conjuntos con peso máximo o, equivalentemente, el problema de determinación del ganador. Nuestras investigaciones, esta vez, llevaron a noticias muy buenas que se resumen a continuación: Para un hipercubo H, su dual ¯H = (V, E) es tal que los nodos en V están en correspondencia uno a uno con los hiperarcos en H, y para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} está en E. Mostramos que MaxWSP es tratable en la clase de aquellas instancias cuyos hipercubos duales tienen un ancho de hiperárbol[7] limitado por k (abreviado: clase C(hw, k) de hipercubos). Cabe destacar que un problema clave de la tratabilidad es considerar el ancho de hiperárbol del hipergrafo dual ¯H en lugar del hipergrafo de subastas H. De hecho, podemos demostrar que MaxWSP sigue siendo NP-duro incluso cuando H es acíclico (es decir, cuando tiene un ancho de hiperárbol de 1), incluso cuando cada nodo está contenido en un máximo de 3 hiperarcos. Para algunas clases especiales relevantes de hipergrafos en C(hw, k), diseñamos un algoritmo altamente paralelizable para MaxWSP. Específicamente, si las funciones de ponderación se pueden calcular en espacio logarítmico y los pesos son polinomiales (por ejemplo, cuando todos los hiperarcos tienen pesos unitarios y se está interesado en encontrar el empaquetamiento con el máximo número de arcos), demostramos que MaxWSP puede resolverse mediante un algoritmo LOGCFL. Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son reducibles en espacio logarítmico a lenguajes libres de contexto, y que LOGCFL ⊆ NC2 ⊆ P (ver, por ejemplo, [9]). Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la descomposición de hipertree de los hipergrafos duales en lugar de la treewidth de los grafos de elementos. Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados. De hecho, demostramos que clases de instancias estrictamente más grandes son tratables según nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados. De manera intuitiva, la NP-dificultad de reconocer grafos de elementos estructurados de ancho acotado no se debe a su gran generalidad, sino más bien a algunas peculiaridades en su definición. La prueba de los resultados anteriores nos brinda una perspectiva interesante sobre la noción de grafo de elementos estructurados. De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos descomposiciones de hiperárboles estrictas. También se propone una caracterización de juego para la noción de ancho de hiperárbol estricto, que se especializa en el juego de Ladrón y Policías en [6] (propuesto para caracterizar el ancho de hiperárbol), y que aclara los requisitos adicionales sobre las descomposiciones de hiperárboles. El resto del documento está organizado de la siguiente manera. La sección 2 discute la intratabilidad de los grafos de elementos estructurados. La sección 3 presenta el algoritmo de tiempo polinómico para resolver MaxWSP en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hipertree acotado, y discute los casos en los que el algoritmo también es altamente paralelizable. La comparación entre las clases C(ig, k) y C(hw, k) se discute en la Sección 4. Finalmente, en la Sección 5 sacamos nuestras conclusiones también delineando las direcciones para futuras investigaciones. 2. COMPLEJIDAD DE LOS GRAFOS DE ELEMENTOS ESTRUCTURADOS Sea H un hipergrafo. Un grafo G = (V, E) es un grafo de elementos para H si V = N(H) y, para cada h ∈ E(H), el subgrafo de G inducido sobre los nodos en h está conectado. Una clase importante de grafos de elementos es la de grafos de elementos estructurados, es decir, aquellos grafos de elementos que tienen un ancho de árbol acotado como se formaliza a continuación. Una descomposición de árbol [16] de un grafo G = (V, E) es un par T, χ, donde T = (N, F) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjunto de vértices χ(p) ⊆ V, de modo que se satisfacen las siguientes condiciones: (1) para cada vértice b de G, existe un p ∈ N tal que b ∈ χ(p); (2) para cada arista {b, d} ∈ E, existe un p ∈ N tal que {b, d} ⊆ χ(p); (3) para cada vértice b de G, el conjunto {p ∈ N | b ∈ χ(p)} induce un subárbol conectado de T. El ancho de T, χ es el número maxp∈N |χ(p) − 1|. El treewidth de G, denotado por tw(G), es el ancho mínimo sobre todas sus descomposiciones en árboles. El problema de determinación del ganador puede resolverse en tiempo polinómico en grafos de elementos con treewidth acotado [3]. Teorema 1 (cf. [3]). Se tiene una descomposición en árbol de ancho k T, χ de un grafo de elementos para H. Entonces, MaxWSP(H, w) se puede resolver en tiempo O(|T|2 ×(|E(H)|+1)k+1 ). Muchos gráficos de elementos pueden estar asociados con un hipergráfico. Como ejemplo, observe que el grafo de elementos en la Figura 1. (c) tiene un ancho de árbol de 1, mientras que la Figura 1. (d) muestra un grafo de elementos cuyo ancho de árbol es 2. De hecho, era una pregunta abierta si, para una constante k dada, se puede verificar en tiempo polinómico si existe un grafo de ítems de ancho de árbol k, y en caso afirmativo, si dicho grafo de ítems se puede calcular eficientemente. La principal tarea de esta sección es demostrar que la clase C(ig, k) es difícil de reconocer. Teorema 2. Decidir si un hipergrafo H pertenece a C(ig, 3) es NP-difícil. La prueba de este resultado se basa en una reducción elaborada del problema de camino hamiltoniano HP(s, t) que consiste en decidir si hay un camino hamiltoniano desde un nodo s hasta un nodo t en un grafo dirigido G = (N, E). Para ayudar a la intuición, aquí presentamos una descripción general de alto nivel de los principales ingredientes utilizados en la prueba. La idea general es construir un hipercubo HG de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución. Primero, discutimos la forma en que se construye HG. Ver la Figura 2. (a) para una ilustración, donde el grafo G consiste en los nodos s, x, y, y t, y el conjunto de sus aristas es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. De G a HG. Sea G = (N, E) un grafo dirigido. Entonces, el conjunto de nodos en HG es tal que: para cada x ∈ N, N(HG) contiene los nodos bsx, btx, bx, bx, bdx; para cada e = (x, y) ∈ E, N(HG) contiene los nodos nsx, nsx, nty, nty, nsex y ntey. Ningún otro nodo está en N(HG). Los hiperarcos en HG son de tres tipos: 1) para cada x ∈ N, E(HG) contiene los hiperarcos: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, y A3 x = {bx, bx} -nota que estos hiperarcos inducen una clique en los nodos {bx, bx, bdx}; 1 Las pruebas detalladas se pueden encontrar en el Apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf. Figura 2: Prueba del Teorema 2: (a) de G a HG - solo se reportan los hiperarcos en 1) y 2); (b) un esqueleto para una descomposición en árbol TD para HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, y TA3 x = {btx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {btx, bx, bx, bdx}; 2) para cada e = (x, y) ∈ E, E(HG) contiene los hiperarcos: • SHx = {nsx, nsx}; • THy = {nty, nty}; • SEe = {nsx, nse x} y SEe = {nsx, nse x} -nota que estos dos hiperarcos más SHx inducen una clique en los nodos {nsx, nsx, nse x}; • TEe = {nty, nte y} y TEe = {nty, nte y} -nota que estos dos hiperarcos más THy inducen una clique en los nodos {nty, nty, nte y}. Observa que cada uno de los hiperarcos anteriores, excepto aquellos de la forma Sx y Tx, contiene exactamente dos nodos. Como ejemplo de los hiperarcos de tipo 1) y 2), el lector puede referirse a la construcción de ejemplo reportada en la Figura 2. (a), y notar, por ejemplo, que Sx = {bsx, nse2 x, nse3 x} y que Tt = {btt, nte4 t, nte3 t}. 3) finalmente, denotamos por DG al conjunto que contiene los hiperarcos en E(HG) del tercer tipo. En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperarcos que satisfacen las cuatro condiciones que se discuten a continuación. Sea PG el conjunto de los siguientes |PG| ≤ |N| + 3 × |E| pares: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}. Además, sea I(v) el conjunto {h ∈ E(H) | v ∈ h} de los hiperarcos de H que son tocados por v; y, para un conjunto V ⊆ N(H), sea I(V) = v∈V I(v). Entonces, DG tiene que ser un conjunto tal que: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ PG o (β, α) ∈ PG, se cumple: I(α) ∩ DG = ∅; y, (c4) ∀S ⊆ N tal que |S| ≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ PG, se cumple que: I(S) ⊇ DG. De manera intuitiva, el conjunto DG es tal que cada una de sus hiperaristas es tocada exactamente por uno de los dos nodos en cada par de PG, cf. (c1) y (c2). Además, los hiperarcos en DG solo tocan vértices incluidos en al menos un par de PG - cf. (c3); y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se pueden construir a partir de él pertenece a PG - cf. (c4). El lector puede preguntarse ahora si existe un conjunto DG que satisfaga (c1), (c2), (c3) y (c4). En el siguiente lema, respondemos positivamente a esta pregunta y referimos al lector a su demostración para un ejemplo de construcción. Lema 1. Un conjunto DG, con |DG| = 2 × |PG| + 2, que cumple las condiciones (c1), (c2), (c3) y (c4) se puede construir en tiempo O(|PG|2). Ingredientes clave. Ahora estamos en la posición de presentar una visión general de los ingredientes clave de la prueba. Sea G un grafo de elementos arbitrario para HG, y sea TD = T, χ una descomposición de árbol de ancho 3 de G (nota que, debido a las cliques, por ejemplo, en los nodos {bsx, bx, bx, bdx}, cualquier grafo de elementos para HG tiene un ancho de árbol de al menos 3). Hay tres observaciones básicas que sirven para demostrar la corrección de la reducción. Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértices. Específicamente, para cada nodo x ∈ N, TD contiene un vértice bs(x) tal que χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, y un vértice bt(x) tal que χ(bt(x)) ⊇ {btx, bx, bx, bdx}. Y, para cada arista e = (x, y) ∈ E, TD contiene un vértice ns(x,e) tal que χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, y un vértice nt(y,e) tal que χ(nt(y,e)) ⊇ {nte y, nty, nty}. Intuitivamente, se requiere que estos vértices cubran los cliques de HG asociados con los hiperarcos de tipo 1) y 2). Cada uno de estos vértices desempeña un papel específico en la reducción. De hecho, cada arista dirigida e = (x, y) ∈ E está codificada en TD mediante los vértices: ns(x,e), que representan precisamente que e comienza en x; y nt(y,e), que representan precisamente que e termina en y. Además, cada nodo x ∈ N está codificado en TD mediante los vértices: bs(x), que representa el punto de inicio de las aristas que se originan en x; y, bt(x), que representa el punto de terminación de las aristas que terminan en x. Como ejemplo, la Figura 2. (b) muestra el esqueleto de una descomposición de árbol TD. El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el hipercubo HG en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación. La conexión entre bloques y la unicidad de las conexiones: La segunda observación crucial es que en el camino que conecta un vértice de la forma bs(x) (resp., bt(y)) con un vértice de la forma ns(x,e) (resp., nt(y,e)) hay un vértice especial de la forma w(x,y) tal que: χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E. Garantizar la existencia de un vértice así es precisamente el papel que desempeñan los hiperarcos en DG. Los argumentos para la prueba son los siguientes. Primero, observamos que I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} e I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}. Luego, mostramos una propiedad que establece que para un par de vértices consecutivos p y q en el camino que conecta bs(x) y ns(x,e) (resp., bt(y) y nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))). Por lo tanto, tenemos: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (o bien, I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}). Basándose en esta observación, y al explotar las propiedades de los hiperarcos en DG, no es difícil demostrar que cualquier par de vértices consecutivos p y q deben compartir dos nodos de HG formando un par en PG, y ambos deben tocar Sx (resp., Ty). Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w(x,y), en este camino es tal que χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E - para ello, note que nse x ∈ Sx, nte t ∈ Ty, e I(χ(w(x,y))) ⊇ DG. En particular, w(x,y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay otro vértice de la forma w(x,z), para z = y (o bien, w(z,y), para z = x). Para ayudar a la intuición, observamos que tener un vértice de la forma w(x,y) en TD corresponde a la selección de un borde desde el nodo x hasta el nodo y en el camino hamiltoniano. De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de un camino hamiltoniano para G y los vértices de la forma w(x,y). Como ejemplo, en la Figura 2. (b), los vértices de la forma w(s,x), w(x,y) y w(y,t) están en TD, y GT D muestra el camino hamiltoniano correspondiente. Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w(x, y), para una arista e = (x, y) ∈ E no está en TD (es decir, si la arista (x, y) no pertenece al camino hamiltoniano), entonces el bloque correspondiente ns(x, e) (resp., nt(y, e)) puede ser agregado arbitrariamente en el subárbol enraizado en el bloque ns(x, e) (resp., nt(y, e)), donde e es la arista de la forma e = (x, z) (resp., e = (z, y)) tal que w(x, z) (resp., w(z, y)) está en TD. Por ejemplo, la Figura 2. (a) muestra w(x,t), que no se utiliza en TD, y la Figura 2. (b) muestra cómo los bloques ns(x,e3) y nt(t,e3) pueden ser dispuestos en TD para garantizar la condición de conectividad. CASOS TRACTABLES MEDIANTE DESCOMPOSICIONES DE HIPERÁRBOLES Dado que construir grafos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden ser utilizadas para identificar clases de instancias de MaxWSP tratables. Con este fin, nos enfocamos en la noción de descomposición de hiperárboles [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros. Un hypertree para un hipercubo H es un triple T, χ, λ, donde T = (N, E) es un árbol raíz, y χ y λ son funciones de etiquetado que asocian a cada vértice p ∈ N con dos conjuntos χ(p) ⊆ N(H) y λ(p) ⊆ E(H). Si T = (N, E) es un subárbol de T, definimos χ(T) = v∈N χ(v). Denotamos el conjunto de vértices N de T como vertices(T). Además, para cualquier p ∈ N, Tp denota el subárbol de T con raíz en p. Definición 1. Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p). El ancho de una descomposición de hipertree T, χ, λ es maxp∈vertices(T )|λ(p)|. El ancho de HYPERTREE hw(H) de H es el ancho mínimo sobre todas sus descomposiciones hypertree. Un hipergrafo H es acíclico si hw(H) = 1. Ejemplo 3. El hipergrafo H I0,B0 reportado en la Figura 1. (a) es un ejemplo de hipergrafo acíclico. En cambio, tanto los hipergráficos H1 y ¯H1 mostrados en la Figura 3. (a) y la Figura 3. (b), respectivamente, no son acíclicos ya que su anchura de hipertiempo es 2. Se reporta una descomposición de hipertree de ancho 2 para ¯H1 en la Figura 3.(c). En particular, observe que H1 se ha obtenido agregando los dos hiperarcos h4 y h5 a H I0,B0 para modelar, por ejemplo, que dos nuevas ofertas, B4 y B5, respectivamente, han sido propuestas al subastador. En lo siguiente, en lugar de trabajar en el hipercampo H asociado con un problema de MaxWSP, trataremos con su dual ¯H, es decir, con el hipercampo tal que sus nodos están en correspondencia uno a uno con los hiperarcos de H, y donde para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} está en E( ¯H). Como ejemplo, el lector puede querer revisar nuevamente el hipercubo H1 en la Figura 3 (a) y notar que el hipercubo en la Figura 3 (b) es de hecho su dual. La razón de esta elección es que imponer restricciones en el hipercubo original garantiza la tratabilidad solo en escenarios muy simples. Teorema 3. En la clase de hipergrafos acíclicos, MaxWSP está (1) en P si cada nodo ocurre en un máximo de dos hiperarcos; y, (2) NP-duro, incluso si cada nodo está contenido en un máximo de tres hiperarcos. 3.1 Descomposición de hiperárboles en el hipergrafo dual y problemas de empaquetamiento tratables Para una constante fija k, sea C(hw, k) la clase de todos los hipergrafos cuyos hipergrafos duales tienen un ancho de hiperárbol limitado por k. El problema de empaquetamiento de conjuntos con peso máximo se puede resolver en tiempo polinómico en la clase C(hw, k) mediante el algoritmo ComputeSetPackingk, mostrado en la Figura 4. El algoritmo recibe como entrada un hipercubo H, una función de ponderación w, y una descomposición de hipertree de ancho k HD = T=(N, E), χ, λ de ¯H. Para cada vértice v ∈ N, sea Hv el hipergrafo cuyo conjunto de nodos N(Hv) ⊆ N(H) coincide con λ(v), y cuyo conjunto de aristas E(Hv) ⊆ E(H) coincide con χ(v). En un paso de inicialización, el algoritmo equipa a cada vértice v con todos los empaquetamientos posibles para Hv, los cuales se almacenan en el conjunto Hv. Se debe tener en cuenta que el tamaño de Hv está limitado por (|E(H)| + 1)k, ya que cada nodo en λ(v) está sin cubrir en un empaquetamiento o está cubierto precisamente por una de las hiperaristas en χ(v) ⊆ E(H). Entonces, ComputeSetPackingk está diseñado para filtrar estos empaquetamientos conservando solo aquellos que se ajusten a algún empaquetamiento para Hc, para cada hijo c de v en T, como se formaliza a continuación. Dejen que hv y hc sean dos empaquetados para Hv y Hc, respectivamente. Decimos que hv se ajusta a hc, indicado por hv ≈ hc si: para cada h ∈ hc ∩ E(Hv), h está en hv; y, para cada h ∈ (E(Hc) − hc), h no está en hv. Ejemplo 4. Considera nuevamente la descomposición de hipertree de ¯H1 reportada en la Figura 3.(c). Luego, el conjunto de todos los empaquetados posibles (que se construyen en el paso de inicialización de ComputeSetPackingk), para cada uno de sus vértices, se reFigure 5: Ejemplo de aplicación del Algoritmo ComputeSetPackingk. 157 Entrada: H, w, y una descomposición de hipertree de ancho k HD = T = (N, E), χ, λ de ¯H; Salida: Una solución para MaxWSP(H, w); var Hv: conjunto de empaquetados para Hv, para cada v ∈ N; h∗: empaquetado para H; v hv: número racional, para cada empaquetado parcial hv para Hv; hhv,c: empaquetado parcial para Hc, para cada empaquetado parcial hv para Hv, y para cada (v, c) ∈ E; -------------------------------------------Procedimiento BottomUp; begin Done := el conjunto de todas las hojas de T; mientras ∃v ∈ T tal que (i) v ∈ Done, y (ii) {c | c es hijo de v} ⊆ Done hacer para cada c tal que (v, c) ∈ E hacer Hv := Hv - {hv | ∃hc ∈ Hc tal que hv ≈ hc}; para cada hv ∈ Hv hacer v hv := w(hv); para cada c tal que (v, c) ∈ E hacer ¯hc := arg maxhc∈Hc|hv≈ hc c hc - w(hc ∩ hv); hhv,c := ¯hc; (* establecer mejor empaquetado *) v hv := v hv + c ¯hc - w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end mientras end; -------------------------------------------begin (* PRINCIPAL *) para cada vértice v en T hacer Hv := {hv empaquetado para Hv}; BottomUp; sea r la raíz de T; ¯hr := arg maxhr∈Hr r hr; h∗ := ¯hr; (* incluir empaquetado *) T opDown(r, hr); return h∗; end. Procedimiento TopDown(v: vértice de N, ¯hv ∈ Hv); comenzar para cada c ∈ N tal que (v, c) ∈ E hacer ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* incluir empaquetado *) TopDown(c, ¯hc); fin para fin; Figura 4: Algoritmo ComputeSetPackingk. representado en la Figura 5.(a). Por ejemplo, la raíz v1 es tal que Hv1 = { {}, {h1}, {h3}, {h5} }. Además, una flecha de un empaque hc a hv indica que hv cumple con hc. Por ejemplo, el lector puede comprobar que el empaquetado {h3} ∈ Hv1 se ajusta al empaquetado {h2, h3} ∈ Hv3, pero no se ajusta a {h1} ∈ Hv3. ¡ComputeSetPackingk construye una solución recorriendo T en dos fases. En la primera fase, los vértices de T se procesan desde las hojas hasta la raíz r, mediante el procedimiento BottomUp. Para cada nodo v que se está procesando, el conjunto Hv se actualiza preliminarmente eliminando todos los empaquetados hv que no cumplen con ningún empaquetado para algunos de los hijos de v. Después de realizar este filtrado, se actualiza el peso hv. De manera intuitiva, v hv almacena el peso del mejor empaquetado parcial para H calculado utilizando solo los hiperarcos que ocurren en χ(Tv). De hecho, si v es una hoja, entonces v hv = w(hv). De lo contrario, para cada hijo c de v en T, v hv se actualiza con el máximo de c hc - w(hc ∩ hv) sobre todos los empaquetados hc que se ajustan a hv (resolviendo empates de forma arbitraria). El empaque ¯hc para el cual se logra este máximo se almacena en la variable hhv,c. En la segunda fase, el árbol T se procesa comenzando desde la raíz. En primer lugar, se selecciona el empaque h∗ que maximiza el peso equipado con los empaques en Hr. Luego, el procedimiento TopDown se utiliza para extender h∗ a todos los otros empaquetamientos parciales para los vértices de T. En particular, en cada vértice v, h∗ se extiende con el empaquetamiento hhv,c, para cada hijo c de v. Ejemplo 5. Supongamos que, en nuestro ejemplo en curso, w(h1) = w(h2) = w(h3) = w(h4) = 1. Luego, una ejecución de ComputeSetPackingk se representa gráficamente en la Figura 5. (b), donde una flecha de un empaquetado hc a un empaquetado hv se utiliza para denotar que hc = hhv,c. Específicamente, las elecciones realizadas durante el cálculo son tales que se calcula el empaquetamiento {h2, h3}. En particular, durante la fase de abajo hacia arriba, tenemos que: (1) se procesa v4 y establecemos v4 {h2} = v4 {h4} = 1 y v4 {} = 0; (2) se procesa v3 y establecemos v3 {h1} = v3 {h3} = 1 y v3 {} = 0; (3) se procesa v2 y establecemos v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 y v3 {} = 0; (4) se procesa v1 y establecemos v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 y v1 {} = 0. Por ejemplo, observe que v1 {h5} = 2 ya que {h5} se ajusta al empaquetado {h4} de Hv2 de tal manera que v2 {h4} = 1. Entonces, al comienzo de la fase de arriba hacia abajo, ComputeSetPackingk selecciona {h3} como un empaquetado para Hv1 y propaga esta elección en el árbol. De manera equivalente, el algoritmo pudo haber elegido {h5}. Como ejemplo adicional, se informa en la Figura 5.(c) la forma en que se obtiene la solución {h1} mediante el algoritmo cuando w(h1) = 5 y w(h2) = w(h3) = w(h4) = 1. Observa que, en esta ocasión, en la fase de arriba hacia abajo, ComputeSetPackingk comienza a seleccionar {h1} como el mejor empaquetado para Hv1. ¡Teorema 4. Sea H un hipergrafo y w una función de ponderación para él. Sea HD = T, χ, λ una descomposición de hipertree completa de ancho k de ¯H. Entonces, ComputeSetPackingk en la entrada H, w y HD produce correctamente una solución para MaxWSP(H, w) en tiempo O(|T| × (|E(H)| + 1)2k. Prueba. [Bosquejo] Observamos que h∗ (calculado por ComputeSetPackingk) es un empaquetamiento para H. De hecho, consideremos un par de hiperarcos h1 y h2 en h∗, y supongamos, para efectos de contradicción, que h1 ∩ h2 = ∅. Sea v1 (resp., v2) un vértice arbitrario de T, para el cual ComputeSetPackingk incluyó h1 (resp., h2) en h∗ en el cálculo de abajo hacia arriba. Por construcción, tenemos h1 ∈ χ(v1) y h2 ∈ χ(v2). Sea I un elemento en h1 ∩ h2. En el hipergrafo dual H, I es un hiperborde en E(¯H) que cubre tanto los nodos h1 como h2. Por lo tanto, por la condición (1) en la Definición 1, existe un vértice v ∈ vértices(T) tal que {h1, h2} ⊆ χ(v). Se debe tener en cuenta que, debido a la condición de conectividad en la Definición 1, también podemos asumir, sin pérdida de generalidad, que v está en el camino que conecta v1 y v2 en T. Sea hv ∈ Hv el elemento añadido por ComputeSetPackingk en h∗ durante la fase de abajo hacia arriba. Dado que los elementos en Hv son empaquetamientos para Hv, se cumple que o bien h1 ∈ hv o h2 ∈ hv. Supongamos, sin pérdida de generalidad, que h1 ∈ hv, y notemos que cada vértice w en T en el camino que conecta v con v1 es tal que h1 ∈ χ(w), debido a la condición de conectividad. Por lo tanto, debido a la definición de conformidad, el empaque hw seleccionado por ComputeSetPackingk para ser agregado en el vértice w en h∗ debe ser tal que h1 ∈ hw. Esto se cumple en particular para w = v1. Contradicción con la definición de v1. Por lo tanto, h∗ es un empaquetamiento para H. Queda entonces por demostrar que tiene el peso máximo sobre todos los empaquetamientos para H. Con este fin, podemos utilizar la inducción estructural en T para demostrar que, en la fase de abajo hacia arriba, la variable v hv se actualiza para contener el peso del empaquetamiento en las aristas en χ(Tv), que contiene hv y que tiene el peso máximo sobre todos los empaquetamientos para las aristas en χ(Tv). Entonces, el resultado sigue, ya que en la fase de arriba hacia abajo, el empaquetado hr que da el peso máximo sobre χ(Tr) = E(H) se incluye primero en h∗, y luego se extiende en cada nodo c con el empaquetado hhv,c de forma conforme con hv y de manera que se alcance el valor máximo de v hv. En cuanto a la complejidad, observe que el paso de inicialización requiere la construcción del conjunto Hv, para cada vértice v, y cada conjunto tiene un tamaño de (|E(H)| + 1)k como máximo. Luego, la función BottomUp verifica la conformidad entre las estrategias en Hv con las estrategias en Hc, para cada par (v, c) ∈ E, y actualiza el peso v hv. Estas tareas pueden llevarse a cabo en tiempo O((|E(H)| + 1)2k) y deben repetirse para cada arista en T, es decir, O(|T|) veces. Finalmente, la función TopDown puede implementarse en tiempo lineal en el tamaño de T, ya que solo requiere actualizar h∗ accediendo a la variable hhv,c. El resultado anterior muestra que si se proporciona una descomposición de hipertree de ancho k, el problema MaxWSP se puede resolver de manera eficiente. Además, a diferencia del caso de los grafos de elementos estructurados, es bien sabido que decidir la existencia de una descomposición de hipertree acotada por k y calcular una (si existe alguna) son problemas que pueden resolverse eficientemente en tiempo polinómico [7]. Por lo tanto, el Teorema 4 confirma que la clase C(hw, k) constituye en realidad una clase manejable para el problema de determinación del ganador. Como muestra el siguiente teorema, para subclases grandes (que dependen solo de cómo se especifica la función de peso), MaxWSP(H, w) es altamente paralelizable. Llamemos a una función de ponderación suave si es computable en espacio logarítmico y si todos los pesos son polinomiales (y por lo tanto solo requieren O(log n) bits para su representación). Recuerde que LOGCFL es una clase de complejidad paralela contenida en NC2, cf. [9]. La versión funcional de LOGCFL es LLOGCFL, la cual se obtiene equipando un transductor de espacio logarítmico con un oráculo en LOGCFL. Teorema 5. Sea H un hipergrafo en C(hw, k), y sea w una función de ponderación suave para él. Entonces, MaxWSP(H, w) está en LLOGCFL. 4. Dadas las descomposiciones de hipertree frente a los grafos de elementos estructurados, y considerando que se ha demostrado que la clase C(hw, k) es una isla de tratabilidad para el problema de determinación del ganador, y dado que se ha demostrado que la clase C(ig, k) no es reconocible eficientemente, uno podría inclinarse a pensar que existen instancias con ancho de hipertree ilimitado, pero que admiten un grafo de elementos de ancho de árbol acotado (por lo que la intratabilidad de los grafos de elementos estructurados residiría en su generalidad). Sorprendentemente, establecemos que este no es el caso. La clave de la prueba es primero demostrar que los grafos de elementos estructurados están en correspondencia uno a uno con un tipo especial de descomposiciones de hiperárboles del hipergrafo dual, al que llamaremos estricto. Entonces, el resultado seguirá al demostrar que las descomposiciones estrictas de hipertree de ancho k son menos potentes que las descomposiciones de hipertree de ancho k. 4.1 Descomposiciones estrictas de hipertree Deje que H sea un hipergrafo, y V ⊆ N(H) sea un conjunto de nodos y X, Y ∈ N(H). X es [V]-adyacente a Y si existe un borde h ∈ E(H) tal que {X, Y} ⊆ (h - V). Un camino [V] π de X a Y es una secuencia X = X0, . . . , X = Y de variables tal que: Xi es [V]-adyacente a Xi+1, para cada i ∈ [0... -1]. Un conjunto W ⊆ N(H) de nodos está [V]-conectado si ∀X, Y ∈ W hay un [V]-camino de X a Y. Un componente [V ] es un conjunto maximal no vacío de nodos W ⊆ (N(H) − V ) que está [V ]-conectado. Para cualquier componente [V] C, sea E(C) = {h ∈ E(H) | h ∩ C = ∅}. Definición 2. Una descomposición de hipertree HD = T, χ, λ de H es estricta si se cumplen las siguientes condiciones: 1. para cada par de vértices r y s en los vértices de T tal que s es un hijo de r, y para cada componente [χ(r)]-Cr. La intersección de Cr con χ(Ts) es vacía, Cr es un componente de [χ(r) ∩ N(λ(r) ∩ λ(s))]; 2. para cada arista h ∈ E(H), hay un vértice p tal que h ∈ λ(p) y h ⊆ χ(p) (decimos que p cubre fuertemente a h); 3. para cada arista h ∈ E(H), el conjunto {p ∈ vértices(T) | h ∈ λ(p)} induce un subárbol (conectado) de T. La anchura estricta de hipertree shw(H) de H es la anchura mínima sobre todas sus descomposiciones estrictas de hipertree. La relación básica entre las descomposiciones de hipertree agradables y los grafos de elementos estructurados se muestra en el siguiente teorema. Teorema 6. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, una k-anchura descomposición en árbol de un grafo de elementos para H existe si y solo si ¯H tiene una (k + 1)-anchura descomposición estricta en hiperárbol. Se debe tener en cuenta que, en lo que respecta al problema de empaquetamiento de conjuntos ponderados máximo, dado un hipercubo H, siempre podemos asumir que para cada nodo v ∈ N(H), {v} está en E(H). De hecho, si esta hiperarista no está en el hipercubo, entonces se puede agregar sin pérdida de generalidad, estableciendo w({v}) = 0. Por lo tanto, dejando que C(shw, k) denote la clase de todos los hipergrafos cuyos hipergrafos duales (asociados con un máximo de 2 términos +1) solo juegan el papel técnico de ocuparse de la diferente definición de ancho para las descomposiciones de árboles y las descomposiciones de hiperárboles. 159 problemas de empaquetamiento de conjuntos ponderados) tienen un ancho de hiperárbol estricto limitado por k, tenemos que C(shw, k + 1) = C(ig, k). Por definición, las descomposiciones de hipertree estrictas son descomposiciones de hipertree especiales. De hecho, podemos demostrar que las condiciones adicionales en la Definición 2 inducen una restricción real en el poder de descomposición. Teorema 7. C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). \n\nC(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). Una vista desde la teoría de juegos. Arrojamos más luz sobre las descomposiciones estrictas de hypertrees al discutir una interesante caracterización basada en el juego estricto de Robber y Marshals, definido adaptando el juego de Robber y Marshals definido en [6], que caracteriza el ancho de hypertree. El juego se juega en un hipercubo H por un ladrón contra k marshals que actúan en coordinación. Los alguaciles se mueven en los hiperarcos de H, mientras que el ladrón se mueve en los nodos de H. El ladrón ve hacia dónde los alguaciles tienen la intención de moverse, y reacciona moviéndose a otro nodo que esté conectado con su posición actual y a través de un camino en G(H) que no utilice ningún nodo contenido en un hiperarco que esté ocupado por los alguaciles antes y después de su movimiento; decimos que estos hiperarcos están bloqueados. Ten en cuenta que en el juego básico definido en [6], al ladrón no se le permite moverse en vértices ocupados por los marshals antes y después de su movimiento, incluso si no pertenecen a hiperarcos bloqueados. Es importante que los marshals jueguen de manera monótona, es decir, no pueden ocupar un borde que haya sido ocupado previamente en el juego y que actualmente no lo esté. Los alguaciles ganan el juego si capturan al ladrón, ocupando un borde que cubra un nodo donde se encuentre el ladrón. De lo contrario, el ladrón gana. Teorema 8. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, ¯H tiene una descomposición estricta de hipertree de k-anchura si y solo si k marshals pueden ganar el Juego estricto de Robber y Marshals en ¯H, sin importar los movimientos de los ladrones. 5. CONCLUSIONES Hemos resuelto la pregunta abierta de determinar la complejidad de calcular un grafo de elementos estructurado asociado con un escenario de subasta combinatoria. El resultado es una mala noticia, ya que resultó que es NP-completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado, incluso para un ancho de árbol de 3. Motivados por este resultado, investigamos el uso de la descomposición de hiperárboles (en el hipergrafo dual asociado con el escenario) y demostramos que el problema es tratable en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hiperárbol acotado. Para algunos casos especiales y relevantes, también se discute un algoritmo altamente paralelizable. Curiosamente, también se descubrió que la clase de grafos de elementos estructurados está adecuadamente contenida en la clase de instancias con ancho de hiperárbol acotado (por lo tanto, la razón de su intratabilidad no es su generalidad). En particular, este último resultado se establece mostrando una relación precisa entre los grafos de elementos estructurados y formas restringidas de descomposiciones de hiperárboles (en el hipergrafo dual), llamadas descomposiciones de consultas (ver, por ejemplo, [7]). A la luz de esta observación, notamos que demostrar algunos resultados de aproximabilidad para grafos de elementos estructurados requiere una comprensión profunda de la aproximabilidad de las descomposiciones de consultas, la cual actualmente no se encuentra en la literatura. Como una vía adicional de investigación, sería relevante mejorar el algoritmo ComputeSetPackingk, por ejemplo, mediante el uso de estructuras de datos especializadas, con el fin de evitar la dependencia cuadrática de (|E(H)| + 1)k. Finalmente, otra pregunta interesante es evaluar si las técnicas de descomposición estructural discutidas en el artículo pueden ser utilizadas para abordar eficientemente generalizaciones del problema de determinación del ganador. Por ejemplo, podría ser relevante en varios escenarios de aplicación diseñar algoritmos que puedan encontrar una estrategia de venta cuando hay varias copias del mismo artículo disponibles para la venta, y además cuando el subastador está satisfecho cuando se venden al menos un número dado de copias. El trabajo de G. Gottlob fue apoyado por el EC3 - Centro de Competencia en Comercio Electrónico (Viena) y por un Premio de Mérito de Investigación Wolfson de la Royal Society. En particular, este premio permitió a Gottlob invitar a G. Greco para una visita de investigación a Oxford. Además, G. Greco cuenta con el apoyo de ICAR-CNR y del M.I.U.R. en el marco del proyecto TOCAI.IT. 6. REFERENCIAS [1] I. Adler, G. Gottlob y M. Grohe. Anchura de hipertree y invariantes de hipergrafo relacionados. En Proc. de EUROCOMB05, páginas 5-10, 2005. [2] C. Boutilier. Resolviendo problemas de subasta combinatoria expresados de manera concisa. En Proc. de AAAI02, páginas 359-366, 2002. [3] V. Conitzer, J. Derryberry y T. Sandholm. Subastas combinatorias con grafos de elementos estructurados. En Proc. de AAAI04, páginas 212-218, 2004. [4] E. M. Eschen y J. P. Sinrad. Un algoritmo O(n2) para el reconocimiento de grafos de arco circular. En Proc. de SODA93, páginas 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Óptimo y aproximado. En Proc. de IJCAI99, páginas 548-553, 1999. [6] G. Gottlob, N. Leone y F. Scarcello. Ladrones, marshals y guardias: caracterizaciones lógicas y teóricas de la amplitud de hiperárboles. Revista de Ciencias de la Computación y de Sistemas, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone y S. Scarcello. Descomposiciones de hiperárboles y consultas tratables. Revista de Ciencias de la Computación y de Sistemas, 63(3):579-627, 2002. [8] H. H. Hoos y C. Boutilier. Resolviendo subastas combinatorias utilizando búsqueda local estocástica. En Proc. de AAAI00, páginas 22-29, 2000. [9] D. Johnson. Un catálogo de clases de complejidad. En P. Cramton, Y. Shoham y R. Steinberg, editores, Manual de Ciencias de la Computación Teórica, Volumen A: Algoritmos y Complejidad, páginas 67-161. 1990. [10] N. Korte y R. H. Mohring. Un algoritmo incremental de tiempo lineal para reconocer grafos de intervalo. Revista SIAM sobre Computación, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller y T. Sandholm. El Problema de Determinación del Ganador. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, y Y. Shoham. Revelación de la verdad en aproximadamente 160 subastas combinatorias eficientes. J. ACM, 49(5):577-602, 2002. [13] R. McAfee y J. McMillan. Analizando la subasta de las ondas aéreas. Revista de Perspectivas Económicas, 10(1):159-175, 1996. [14] J. McMillan. Vendiendo derechos de espectro. Revista de Perspectivas Económicas, 8(3):145-62, 1994. [15] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. de EC00, páginas 1-12, 2000. [16] N. Robertson y P. Seymour. Menores de grafos ii. Aspectos algorítmicos del ancho de árbol. Revista de Algoritmos, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias computacionalmente manejables. Ciencia de la Gestión, 44:1131-1147, 1998. [18] T. Sandholm. Una implementación del protocolo de red de contratos basada en cálculos de costos marginales. En Proc. de AAAI93, páginas 256-262, 1993. [19] T. Sandholm. Algoritmo para la determinación óptima del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, 2002. [20] T. Sandholm. Algoritmos de determinación de ganadores. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [21] T. Sandholm y S. Suri. Bob: Mejora en la determinación de ganadores en subastas combinatorias y generalizaciones. Inteligencia Artificial, 7:33-58, 2003. [22] M. Tennenholtz. Algunas subastas combinatorias manejables. En Proc. de AAAI00, páginas 98-103, 2000. [23] E. Zurel y N. Nisan. Un algoritmo de asignación aproximada eficiente para subastas combinatorias. En Proc. de EC01, páginas 125-136, 2001. 161 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "accepted bid price": {
            "translated_key": "precios de las ofertas aceptadas",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the <br>accepted bid price</br>s.",
                "While this problem is in general NPhard, it is known to be feasible in polynomial time on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in polynomial time on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the <br>accepted bid price</br>s (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in polynomial time unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in polynomial time (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in polynomial time if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "Polynomial time algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in polynomial time, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in polynomial time and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in polynomial time on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in polynomial time if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in polynomial time on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in polynomial time [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the <br>accepted bid price</br>s.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the <br>accepted bid price</br>s (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes."
            ],
            "translated_annotated_samples": [
                "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los <br>precios de las ofertas aceptadas</br>.",
                "Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los <br>precios de las ofertas aceptadas</br> (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los <br>precios de las ofertas aceptadas</br>. Si bien este problema es en general NP-difícil, se sabe que es factible en tiempo polinómico en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en tiempo polinómico en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los <br>precios de las ofertas aceptadas</br> (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en tiempo polinómico a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en tiempo polinómico (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en tiempo polinómico si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. Para tener una intuición sobre cómo se pueden construir los gráficos de elementos, notamos que la interacción del postor en una subasta combinatoria I, B puede ser representada mediante un hipergrafo H I,B de tal manera que su conjunto de nodos N(H I,B) coincide con el conjunto de elementos I, y donde sus aristas E(H I,B) son precisamente las ofertas de los compradores {elemento(Bi) | Bi ∈ B}. Un gráfico de ítems especiales para I, B es el gráfico primal de H I,B, denotado por G(H I,B), que contiene una arista entre cada par de nodos en alguna hiperarista de H I,B. Entonces, cualquier gráfico de elementos para H I,B se puede ver como una simplificación de G(H I,B) obtenida al eliminar algunas aristas, manteniendo la condición de conectividad en los nodos incluidos en cada hiperarista. Ejemplo 1. El hipercubo H I0,B0 reportado en la Figura 1. (a) es una codificación para una subasta combinatoria I0, B0, donde I0 = {I1, ..., I5}, y item(Bi) = hi, para cada 1 ≤ i ≤ 3. El grafo primario para H I0,B0 se reporta en la Figura 1. (b), mientras que dos ejemplos de grafos de elementos se reportan en la Figura 1. (c) y (d), donde se muestran en negrita las aristas necesarias para mantener la conectividad para h1. ¡Problema abierto: Calcular de manera eficiente los grafos de elementos estructurados. El resultado de tratabilidad mencionado anteriormente en grafos de elementos estructurados resulta ser útil en la práctica solo cuando un grafo de elementos estructurados está dado o puede determinarse eficientemente. Sin embargo, podría haber una cantidad exponencial de gráficos de elementos asociados con una subasta combinatoria, y no está claro cómo determinar si existe un gráfico de elementos estructurado de cierto ancho de árbol (constante), y en caso afirmativo, cómo calcular eficientemente dicho gráfico de elementos estructurado. Los algoritmos de tiempo polinómico para encontrar la mejor simplificación del grafo primal solo se conocían hasta ahora para los casos en los que el grafo de elementos a construir es una línea [10], un ciclo [4] o un árbol [3], pero era un importante problema abierto (cf. [3]) si es factible verificar si para una subasta combinatoria, existe un grafo de elementos con un ancho de árbol limitado por un número natural fijo k y si se puede construir en tiempo polinómico, en caso afirmativo. Empaquetamiento de conjuntos ponderado. Cabe destacar que la representación de hipergrafo H I,B de una subasta combinatoria I, B también es útil para establecer la analogía entre el problema de determinación del ganador y el problema de empaquetamiento de conjuntos con peso máximo en hipergrafos (por ejemplo, [17]). Formalmente, un empaquetamiento h para un hipergrafo H es un conjunto de hiperarcos de H tal que para cada par h, h ∈ h con h ≠ h, se cumple que h ∩ h = ∅. Si se deja que w sea una función de ponderación para H, es decir, una función computable en tiempo polinómico de E(H) a números racionales, el peso de un empaquetado h es el número racional w(h) = h∈h w(h), donde w({}) = 0. Entonces, el problema de empaquetamiento de conjuntos con peso máximo para H con respecto a w, denotado por MaxWSP(H, w), es el problema de encontrar un empaquetamiento para H que tenga el peso máximo entre todos los empaquetamientos para H. Para ver que MaxWSP es simplemente una formulación diferente para el problema de determinación del ganador, dado una subasta combinatoria I, B, es suficiente definir la función de ponderación w I,B (elemento(Bi)) = pago(Bi). Entonces, el conjunto de soluciones para el problema de empaquetamiento de conjuntos ponderados para H I,B con respecto a w I,B coincide con el conjunto de soluciones para el problema de determinación del ganador en I, B. Ejemplo 2. Considera nuevamente el hipercubo H I0,B0 reportado en la Figura 1.(a). Un ejemplo de empaquetado para H I0, B0 es h = {h1}, que intuitivamente corresponde a un resultado para I0, B0, donde el subastador aceptó la oferta B1. Al asumir que las ofertas B1, B2 y B3 son tales que pay(B1) = pay(B2) = pay(B3), el empaquetado h no es una solución para el problema MaxWSP(H I0,B0 , w I0,B0). De hecho, el empaque h∗ = {h2, h3} es tal que w I0,B0 (h∗ ) > w I0,B0 (h). ¡Contribuciones! El objetivo principal de este artículo es identificar clases grandes y manejables para el problema de determinación del ganador, que además sean reconocibles de forma polinómica. Con este objetivo, primero estudiamos grafos de elementos estructurados y resolvemos el problema abierto en [3]. El resultado es una noticia muy mala: es NP completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado de ancho de árbol 3. De manera más formal, dejando que C(ig, k) denote la clase de todos los hipergrafos que tienen un árbol de ítems con un ancho de árbol limitado por k, demostramos que decidir si un hipergrafo (asociado con un problema de subasta combinatoria) pertenece a C(ig, 3) es NP-completo. A la luz de este resultado, fue crucial evaluar si existen otros tipos de requisitos estructurales que puedan ser verificados en tiempo polinómico y que aún puedan ser utilizados para aislar clases tratables del problema de empaquetamiento de conjuntos con peso máximo o, equivalentemente, el problema de determinación del ganador. Nuestras investigaciones, esta vez, llevaron a noticias muy buenas que se resumen a continuación: Para un hipercubo H, su dual ¯H = (V, E) es tal que los nodos en V están en correspondencia uno a uno con los hiperarcos en H, y para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} está en E. Mostramos que MaxWSP es tratable en la clase de aquellas instancias cuyos hipercubos duales tienen un ancho de hiperárbol[7] limitado por k (abreviado: clase C(hw, k) de hipercubos). Cabe destacar que un problema clave de la tratabilidad es considerar el ancho de hiperárbol del hipergrafo dual ¯H en lugar del hipergrafo de subastas H. De hecho, podemos demostrar que MaxWSP sigue siendo NP-duro incluso cuando H es acíclico (es decir, cuando tiene un ancho de hiperárbol de 1), incluso cuando cada nodo está contenido en un máximo de 3 hiperarcos. Para algunas clases especiales relevantes de hipergrafos en C(hw, k), diseñamos un algoritmo altamente paralelizable para MaxWSP. Específicamente, si las funciones de ponderación se pueden calcular en espacio logarítmico y los pesos son polinomiales (por ejemplo, cuando todos los hiperarcos tienen pesos unitarios y se está interesado en encontrar el empaquetamiento con el máximo número de arcos), demostramos que MaxWSP puede resolverse mediante un algoritmo LOGCFL. Recuerde, de hecho, que LOGCFL es la clase de problemas de decisión que son reducibles en espacio logarítmico a lenguajes libres de contexto, y que LOGCFL ⊆ NC2 ⊆ P (ver, por ejemplo, [9]). Sorprendentemente, demostramos que no se pierde nada en términos de generalidad al considerar la descomposición de hipertree de los hipergrafos duales en lugar de la treewidth de los grafos de elementos. Por el contrario, el método de descomposición propuesto basado en hypertrees es estrictamente más general que el método de grafos de elementos estructurados. De hecho, demostramos que clases de instancias estrictamente más grandes son tratables según nuestro nuevo enfoque que según el enfoque de gráficos de elementos estructurados. De manera intuitiva, la NP-dificultad de reconocer grafos de elementos estructurados de ancho acotado no se debe a su gran generalidad, sino más bien a algunas peculiaridades en su definición. La prueba de los resultados anteriores nos brinda una perspectiva interesante sobre la noción de grafo de elementos estructurados. De hecho, demostramos que los grafos de elementos estructurados están en correspondencia uno a uno con algunos tipos especiales de descomposición de hiperárboles del hipergrafo dual, a los que llamamos descomposiciones de hiperárboles estrictas. También se propone una caracterización de juego para la noción de ancho de hiperárbol estricto, que se especializa en el juego de Ladrón y Policías en [6] (propuesto para caracterizar el ancho de hiperárbol), y que aclara los requisitos adicionales sobre las descomposiciones de hiperárboles. El resto del documento está organizado de la siguiente manera. La sección 2 discute la intratabilidad de los grafos de elementos estructurados. La sección 3 presenta el algoritmo de tiempo polinómico para resolver MaxWSP en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hipertree acotado, y discute los casos en los que el algoritmo también es altamente paralelizable. La comparación entre las clases C(ig, k) y C(hw, k) se discute en la Sección 4. Finalmente, en la Sección 5 sacamos nuestras conclusiones también delineando las direcciones para futuras investigaciones. 2. COMPLEJIDAD DE LOS GRAFOS DE ELEMENTOS ESTRUCTURADOS Sea H un hipergrafo. Un grafo G = (V, E) es un grafo de elementos para H si V = N(H) y, para cada h ∈ E(H), el subgrafo de G inducido sobre los nodos en h está conectado. Una clase importante de grafos de elementos es la de grafos de elementos estructurados, es decir, aquellos grafos de elementos que tienen un ancho de árbol acotado como se formaliza a continuación. Una descomposición de árbol [16] de un grafo G = (V, E) es un par T, χ, donde T = (N, F) es un árbol, y χ es una función de etiquetado que asigna a cada vértice p ∈ N un conjunto de vértices χ(p) ⊆ V, de modo que se satisfacen las siguientes condiciones: (1) para cada vértice b de G, existe un p ∈ N tal que b ∈ χ(p); (2) para cada arista {b, d} ∈ E, existe un p ∈ N tal que {b, d} ⊆ χ(p); (3) para cada vértice b de G, el conjunto {p ∈ N | b ∈ χ(p)} induce un subárbol conectado de T. El ancho de T, χ es el número maxp∈N |χ(p) − 1|. El treewidth de G, denotado por tw(G), es el ancho mínimo sobre todas sus descomposiciones en árboles. El problema de determinación del ganador puede resolverse en tiempo polinómico en grafos de elementos con treewidth acotado [3]. Teorema 1 (cf. [3]). Se tiene una descomposición en árbol de ancho k T, χ de un grafo de elementos para H. Entonces, MaxWSP(H, w) se puede resolver en tiempo O(|T|2 ×(|E(H)|+1)k+1 ). Muchos gráficos de elementos pueden estar asociados con un hipergráfico. Como ejemplo, observe que el grafo de elementos en la Figura 1. (c) tiene un ancho de árbol de 1, mientras que la Figura 1. (d) muestra un grafo de elementos cuyo ancho de árbol es 2. De hecho, era una pregunta abierta si, para una constante k dada, se puede verificar en tiempo polinómico si existe un grafo de ítems de ancho de árbol k, y en caso afirmativo, si dicho grafo de ítems se puede calcular eficientemente. La principal tarea de esta sección es demostrar que la clase C(ig, k) es difícil de reconocer. Teorema 2. Decidir si un hipergrafo H pertenece a C(ig, 3) es NP-difícil. La prueba de este resultado se basa en una reducción elaborada del problema de camino hamiltoniano HP(s, t) que consiste en decidir si hay un camino hamiltoniano desde un nodo s hasta un nodo t en un grafo dirigido G = (N, E). Para ayudar a la intuición, aquí presentamos una descripción general de alto nivel de los principales ingredientes utilizados en la prueba. La idea general es construir un hipercubo HG de tal manera que exista un grafo de elementos G para HG con tw(G) ≤ 3 si y solo si HP(s, t) sobre G tiene una solución. Primero, discutimos la forma en que se construye HG. Ver la Figura 2. (a) para una ilustración, donde el grafo G consiste en los nodos s, x, y, y t, y el conjunto de sus aristas es {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}. De G a HG. Sea G = (N, E) un grafo dirigido. Entonces, el conjunto de nodos en HG es tal que: para cada x ∈ N, N(HG) contiene los nodos bsx, btx, bx, bx, bdx; para cada e = (x, y) ∈ E, N(HG) contiene los nodos nsx, nsx, nty, nty, nsex y ntey. Ningún otro nodo está en N(HG). Los hiperarcos en HG son de tres tipos: 1) para cada x ∈ N, E(HG) contiene los hiperarcos: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, y A3 x = {bx, bx} -nota que estos hiperarcos inducen una clique en los nodos {bx, bx, bdx}; 1 Las pruebas detalladas se pueden encontrar en el Apéndice, disponible en www.mat.unical.it/∼ggreco/papers/ca.pdf. Figura 2: Prueba del Teorema 2: (a) de G a HG - solo se reportan los hiperarcos en 1) y 2); (b) un esqueleto para una descomposición en árbol TD para HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, y TA3 x = {btx, bdx} -nota que estos hiperarcos más A1 x, A2 x y A3 x inducen una clique en los nodos {btx, bx, bx, bdx}; 2) para cada e = (x, y) ∈ E, E(HG) contiene los hiperarcos: • SHx = {nsx, nsx}; • THy = {nty, nty}; • SEe = {nsx, nse x} y SEe = {nsx, nse x} -nota que estos dos hiperarcos más SHx inducen una clique en los nodos {nsx, nsx, nse x}; • TEe = {nty, nte y} y TEe = {nty, nte y} -nota que estos dos hiperarcos más THy inducen una clique en los nodos {nty, nty, nte y}. Observa que cada uno de los hiperarcos anteriores, excepto aquellos de la forma Sx y Tx, contiene exactamente dos nodos. Como ejemplo de los hiperarcos de tipo 1) y 2), el lector puede referirse a la construcción de ejemplo reportada en la Figura 2. (a), y notar, por ejemplo, que Sx = {bsx, nse2 x, nse3 x} y que Tt = {btt, nte4 t, nte3 t}. 3) finalmente, denotamos por DG al conjunto que contiene los hiperarcos en E(HG) del tercer tipo. En la reducción que estamos explotando, DG puede ser un conjunto arbitrario de hiperarcos que satisfacen las cuatro condiciones que se discuten a continuación. Sea PG el conjunto de los siguientes |PG| ≤ |N| + 3 × |E| pares: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}. Además, sea I(v) el conjunto {h ∈ E(H) | v ∈ h} de los hiperarcos de H que son tocados por v; y, para un conjunto V ⊆ N(H), sea I(V) = v∈V I(v). Entonces, DG tiene que ser un conjunto tal que: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N tal que ∃β ∈ N con (α, β) ∈ PG o (β, α) ∈ PG, se cumple: I(α) ∩ DG = ∅; y, (c4) ∀S ⊆ N tal que |S| ≤ 3 y donde ∃α, β ∈ S con (α, β) ∈ PG, se cumple que: I(S) ⊇ DG. De manera intuitiva, el conjunto DG es tal que cada una de sus hiperaristas es tocada exactamente por uno de los dos nodos en cada par de PG, cf. (c1) y (c2). Además, los hiperarcos en DG solo tocan vértices incluidos en al menos un par de PG - cf. (c3); y, cualquier triple de nodos no es capaz de tocar todos los elementos de DG si ninguno de los pares que se pueden construir a partir de él pertenece a PG - cf. (c4). El lector puede preguntarse ahora si existe un conjunto DG que satisfaga (c1), (c2), (c3) y (c4). En el siguiente lema, respondemos positivamente a esta pregunta y referimos al lector a su demostración para un ejemplo de construcción. Lema 1. Un conjunto DG, con |DG| = 2 × |PG| + 2, que cumple las condiciones (c1), (c2), (c3) y (c4) se puede construir en tiempo O(|PG|2). Ingredientes clave. Ahora estamos en la posición de presentar una visión general de los ingredientes clave de la prueba. Sea G un grafo de elementos arbitrario para HG, y sea TD = T, χ una descomposición de árbol de ancho 3 de G (nota que, debido a las cliques, por ejemplo, en los nodos {bsx, bx, bx, bdx}, cualquier grafo de elementos para HG tiene un ancho de árbol de al menos 3). Hay tres observaciones básicas que sirven para demostrar la corrección de la reducción. Bloques de TD: Primero, observamos que TD debe contener algunos tipos especiales de vértices. Específicamente, para cada nodo x ∈ N, TD contiene un vértice bs(x) tal que χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, y un vértice bt(x) tal que χ(bt(x)) ⊇ {btx, bx, bx, bdx}. Y, para cada arista e = (x, y) ∈ E, TD contiene un vértice ns(x,e) tal que χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, y un vértice nt(y,e) tal que χ(nt(y,e)) ⊇ {nte y, nty, nty}. Intuitivamente, se requiere que estos vértices cubran los cliques de HG asociados con los hiperarcos de tipo 1) y 2). Cada uno de estos vértices desempeña un papel específico en la reducción. De hecho, cada arista dirigida e = (x, y) ∈ E está codificada en TD mediante los vértices: ns(x,e), que representan precisamente que e comienza en x; y nt(y,e), que representan precisamente que e termina en y. Además, cada nodo x ∈ N está codificado en TD mediante los vértices: bs(x), que representa el punto de inicio de las aristas que se originan en x; y, bt(x), que representa el punto de terminación de las aristas que terminan en x. Como ejemplo, la Figura 2. (b) muestra el esqueleto de una descomposición de árbol TD. El lector puede notar en él los bloques definidos anteriormente y cómo están relacionados con el hipercubo HG en la Figura 2. (a) - otros bloques en él (de la forma w(x,y)) se definen a continuación. La conexión entre bloques y la unicidad de las conexiones: La segunda observación crucial es que en el camino que conecta un vértice de la forma bs(x) (resp., bt(y)) con un vértice de la forma ns(x,e) (resp., nt(y,e)) hay un vértice especial de la forma w(x,y) tal que: χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E. Garantizar la existencia de un vértice así es precisamente el papel que desempeñan los hiperarcos en DG. Los argumentos para la prueba son los siguientes. Primero, observamos que I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} e I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}. Luego, mostramos una propiedad que establece que para un par de vértices consecutivos p y q en el camino que conecta bs(x) y ns(x,e) (resp., bt(y) y nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))). Por lo tanto, tenemos: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (o bien, I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}). Basándose en esta observación, y al explotar las propiedades de los hiperarcos en DG, no es difícil demostrar que cualquier par de vértices consecutivos p y q deben compartir dos nodos de HG formando un par en PG, y ambos deben tocar Sx (resp., Ty). Cuando el ancho de árbol de G es 3, podemos concluir que un vértice, digamos w(x,y), en este camino es tal que χ(w(x,y)) ⊇ {nse x , nte y }, para alguna arista e = (x, y) ∈ E - para ello, note que nse x ∈ Sx, nte t ∈ Ty, e I(χ(w(x,y))) ⊇ DG. En particular, w(x,y) es el único tipo de vértice que satisface estas condiciones, es decir, en el camino no hay otro vértice de la forma w(x,z), para z = y (o bien, w(z,y), para z = x). Para ayudar a la intuición, observamos que tener un vértice de la forma w(x,y) en TD corresponde a la selección de un borde desde el nodo x hasta el nodo y en el camino hamiltoniano. De hecho, dada la singularidad de estos vértices seleccionados para garantizar la conectividad, se puede establecer una correspondencia uno a uno entre la existencia de un camino hamiltoniano para G y los vértices de la forma w(x,y). Como ejemplo, en la Figura 2. (b), los vértices de la forma w(s,x), w(x,y) y w(y,t) están en TD, y GT D muestra el camino hamiltoniano correspondiente. Bloques no utilizados: Finalmente, el tercer ingrediente de la prueba es la observación de que si un vértice de la forma w(x, y), para una arista e = (x, y) ∈ E no está en TD (es decir, si la arista (x, y) no pertenece al camino hamiltoniano), entonces el bloque correspondiente ns(x, e) (resp., nt(y, e)) puede ser agregado arbitrariamente en el subárbol enraizado en el bloque ns(x, e) (resp., nt(y, e)), donde e es la arista de la forma e = (x, z) (resp., e = (z, y)) tal que w(x, z) (resp., w(z, y)) está en TD. Por ejemplo, la Figura 2. (a) muestra w(x,t), que no se utiliza en TD, y la Figura 2. (b) muestra cómo los bloques ns(x,e3) y nt(t,e3) pueden ser dispuestos en TD para garantizar la condición de conectividad. CASOS TRACTABLES MEDIANTE DESCOMPOSICIONES DE HIPERÁRBOLES Dado que construir grafos de elementos estructurados es intratable, es relevante evaluar si otras restricciones estructurales pueden ser utilizadas para identificar clases de instancias de MaxWSP tratables. Con este fin, nos enfocamos en la noción de descomposición de hiperárboles [7], que es una generalización natural de la aciclicidad de hipergrafos y que ha sido utilizada de manera rentable en otros ámbitos, por ejemplo, en la satisfacción de restricciones y la evaluación de consultas de bases de datos, para identificar islas de tratabilidad para problemas NP-duros. Un hypertree para un hipercubo H es un triple T, χ, λ, donde T = (N, E) es un árbol raíz, y χ y λ son funciones de etiquetado que asocian a cada vértice p ∈ N con dos conjuntos χ(p) ⊆ N(H) y λ(p) ⊆ E(H). Si T = (N, E) es un subárbol de T, definimos χ(T) = v∈N χ(v). Denotamos el conjunto de vértices N de T como vertices(T). Además, para cualquier p ∈ N, Tp denota el subárbol de T con raíz en p. Definición 1. Una descomposición de hipertree de un hypergraph H es un hypertree HD = T, χ, λ para H que satisface todas las siguientes condiciones: 1. para cada arista h ∈ E(H), existe p ∈ vértices(T) tal que h ⊆ χ(p) (decimos que p cubre h); Figura 3: Problema MaxWSP de ejemplo: (a) Hypergraph H1; (b) Hypergraph ¯H1; (c) Una descomposición de hipertree de ancho 2 de ¯H1. 2. para cada nodo Y ∈ N(H), el conjunto {p ∈ vértices(T) | Y ∈ χ(p)} induce un subárbol (conectado) de T; 3. para cada p ∈ vértices(T), χ(p) ⊆ N(λ(p)); 4. para cada p ∈ vértices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p). El ancho de una descomposición de hipertree T, χ, λ es maxp∈vertices(T )|λ(p)|. El ancho de HYPERTREE hw(H) de H es el ancho mínimo sobre todas sus descomposiciones hypertree. Un hipergrafo H es acíclico si hw(H) = 1. Ejemplo 3. El hipergrafo H I0,B0 reportado en la Figura 1. (a) es un ejemplo de hipergrafo acíclico. En cambio, tanto los hipergráficos H1 y ¯H1 mostrados en la Figura 3. (a) y la Figura 3. (b), respectivamente, no son acíclicos ya que su anchura de hipertiempo es 2. Se reporta una descomposición de hipertree de ancho 2 para ¯H1 en la Figura 3.(c). En particular, observe que H1 se ha obtenido agregando los dos hiperarcos h4 y h5 a H I0,B0 para modelar, por ejemplo, que dos nuevas ofertas, B4 y B5, respectivamente, han sido propuestas al subastador. En lo siguiente, en lugar de trabajar en el hipercampo H asociado con un problema de MaxWSP, trataremos con su dual ¯H, es decir, con el hipercampo tal que sus nodos están en correspondencia uno a uno con los hiperarcos de H, y donde para cada nodo x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} está en E( ¯H). Como ejemplo, el lector puede querer revisar nuevamente el hipercubo H1 en la Figura 3 (a) y notar que el hipercubo en la Figura 3 (b) es de hecho su dual. La razón de esta elección es que imponer restricciones en el hipercubo original garantiza la tratabilidad solo en escenarios muy simples. Teorema 3. En la clase de hipergrafos acíclicos, MaxWSP está (1) en P si cada nodo ocurre en un máximo de dos hiperarcos; y, (2) NP-duro, incluso si cada nodo está contenido en un máximo de tres hiperarcos. 3.1 Descomposición de hiperárboles en el hipergrafo dual y problemas de empaquetamiento tratables Para una constante fija k, sea C(hw, k) la clase de todos los hipergrafos cuyos hipergrafos duales tienen un ancho de hiperárbol limitado por k. El problema de empaquetamiento de conjuntos con peso máximo se puede resolver en tiempo polinómico en la clase C(hw, k) mediante el algoritmo ComputeSetPackingk, mostrado en la Figura 4. El algoritmo recibe como entrada un hipercubo H, una función de ponderación w, y una descomposición de hipertree de ancho k HD = T=(N, E), χ, λ de ¯H. Para cada vértice v ∈ N, sea Hv el hipergrafo cuyo conjunto de nodos N(Hv) ⊆ N(H) coincide con λ(v), y cuyo conjunto de aristas E(Hv) ⊆ E(H) coincide con χ(v). En un paso de inicialización, el algoritmo equipa a cada vértice v con todos los empaquetamientos posibles para Hv, los cuales se almacenan en el conjunto Hv. Se debe tener en cuenta que el tamaño de Hv está limitado por (|E(H)| + 1)k, ya que cada nodo en λ(v) está sin cubrir en un empaquetamiento o está cubierto precisamente por una de las hiperaristas en χ(v) ⊆ E(H). Entonces, ComputeSetPackingk está diseñado para filtrar estos empaquetamientos conservando solo aquellos que se ajusten a algún empaquetamiento para Hc, para cada hijo c de v en T, como se formaliza a continuación. Dejen que hv y hc sean dos empaquetados para Hv y Hc, respectivamente. Decimos que hv se ajusta a hc, indicado por hv ≈ hc si: para cada h ∈ hc ∩ E(Hv), h está en hv; y, para cada h ∈ (E(Hc) − hc), h no está en hv. Ejemplo 4. Considera nuevamente la descomposición de hipertree de ¯H1 reportada en la Figura 3.(c). Luego, el conjunto de todos los empaquetados posibles (que se construyen en el paso de inicialización de ComputeSetPackingk), para cada uno de sus vértices, se reFigure 5: Ejemplo de aplicación del Algoritmo ComputeSetPackingk. 157 Entrada: H, w, y una descomposición de hipertree de ancho k HD = T = (N, E), χ, λ de ¯H; Salida: Una solución para MaxWSP(H, w); var Hv: conjunto de empaquetados para Hv, para cada v ∈ N; h∗: empaquetado para H; v hv: número racional, para cada empaquetado parcial hv para Hv; hhv,c: empaquetado parcial para Hc, para cada empaquetado parcial hv para Hv, y para cada (v, c) ∈ E; -------------------------------------------Procedimiento BottomUp; begin Done := el conjunto de todas las hojas de T; mientras ∃v ∈ T tal que (i) v ∈ Done, y (ii) {c | c es hijo de v} ⊆ Done hacer para cada c tal que (v, c) ∈ E hacer Hv := Hv - {hv | ∃hc ∈ Hc tal que hv ≈ hc}; para cada hv ∈ Hv hacer v hv := w(hv); para cada c tal que (v, c) ∈ E hacer ¯hc := arg maxhc∈Hc|hv≈ hc c hc - w(hc ∩ hv); hhv,c := ¯hc; (* establecer mejor empaquetado *) v hv := v hv + c ¯hc - w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end mientras end; -------------------------------------------begin (* PRINCIPAL *) para cada vértice v en T hacer Hv := {hv empaquetado para Hv}; BottomUp; sea r la raíz de T; ¯hr := arg maxhr∈Hr r hr; h∗ := ¯hr; (* incluir empaquetado *) T opDown(r, hr); return h∗; end. Procedimiento TopDown(v: vértice de N, ¯hv ∈ Hv); comenzar para cada c ∈ N tal que (v, c) ∈ E hacer ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* incluir empaquetado *) TopDown(c, ¯hc); fin para fin; Figura 4: Algoritmo ComputeSetPackingk. representado en la Figura 5.(a). Por ejemplo, la raíz v1 es tal que Hv1 = { {}, {h1}, {h3}, {h5} }. Además, una flecha de un empaque hc a hv indica que hv cumple con hc. Por ejemplo, el lector puede comprobar que el empaquetado {h3} ∈ Hv1 se ajusta al empaquetado {h2, h3} ∈ Hv3, pero no se ajusta a {h1} ∈ Hv3. ¡ComputeSetPackingk construye una solución recorriendo T en dos fases. En la primera fase, los vértices de T se procesan desde las hojas hasta la raíz r, mediante el procedimiento BottomUp. Para cada nodo v que se está procesando, el conjunto Hv se actualiza preliminarmente eliminando todos los empaquetados hv que no cumplen con ningún empaquetado para algunos de los hijos de v. Después de realizar este filtrado, se actualiza el peso hv. De manera intuitiva, v hv almacena el peso del mejor empaquetado parcial para H calculado utilizando solo los hiperarcos que ocurren en χ(Tv). De hecho, si v es una hoja, entonces v hv = w(hv). De lo contrario, para cada hijo c de v en T, v hv se actualiza con el máximo de c hc - w(hc ∩ hv) sobre todos los empaquetados hc que se ajustan a hv (resolviendo empates de forma arbitraria). El empaque ¯hc para el cual se logra este máximo se almacena en la variable hhv,c. En la segunda fase, el árbol T se procesa comenzando desde la raíz. En primer lugar, se selecciona el empaque h∗ que maximiza el peso equipado con los empaques en Hr. Luego, el procedimiento TopDown se utiliza para extender h∗ a todos los otros empaquetamientos parciales para los vértices de T. En particular, en cada vértice v, h∗ se extiende con el empaquetamiento hhv,c, para cada hijo c de v. Ejemplo 5. Supongamos que, en nuestro ejemplo en curso, w(h1) = w(h2) = w(h3) = w(h4) = 1. Luego, una ejecución de ComputeSetPackingk se representa gráficamente en la Figura 5. (b), donde una flecha de un empaquetado hc a un empaquetado hv se utiliza para denotar que hc = hhv,c. Específicamente, las elecciones realizadas durante el cálculo son tales que se calcula el empaquetamiento {h2, h3}. En particular, durante la fase de abajo hacia arriba, tenemos que: (1) se procesa v4 y establecemos v4 {h2} = v4 {h4} = 1 y v4 {} = 0; (2) se procesa v3 y establecemos v3 {h1} = v3 {h3} = 1 y v3 {} = 0; (3) se procesa v2 y establecemos v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 y v3 {} = 0; (4) se procesa v1 y establecemos v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 y v1 {} = 0. Por ejemplo, observe que v1 {h5} = 2 ya que {h5} se ajusta al empaquetado {h4} de Hv2 de tal manera que v2 {h4} = 1. Entonces, al comienzo de la fase de arriba hacia abajo, ComputeSetPackingk selecciona {h3} como un empaquetado para Hv1 y propaga esta elección en el árbol. De manera equivalente, el algoritmo pudo haber elegido {h5}. Como ejemplo adicional, se informa en la Figura 5.(c) la forma en que se obtiene la solución {h1} mediante el algoritmo cuando w(h1) = 5 y w(h2) = w(h3) = w(h4) = 1. Observa que, en esta ocasión, en la fase de arriba hacia abajo, ComputeSetPackingk comienza a seleccionar {h1} como el mejor empaquetado para Hv1. ¡Teorema 4. Sea H un hipergrafo y w una función de ponderación para él. Sea HD = T, χ, λ una descomposición de hipertree completa de ancho k de ¯H. Entonces, ComputeSetPackingk en la entrada H, w y HD produce correctamente una solución para MaxWSP(H, w) en tiempo O(|T| × (|E(H)| + 1)2k. Prueba. [Bosquejo] Observamos que h∗ (calculado por ComputeSetPackingk) es un empaquetamiento para H. De hecho, consideremos un par de hiperarcos h1 y h2 en h∗, y supongamos, para efectos de contradicción, que h1 ∩ h2 = ∅. Sea v1 (resp., v2) un vértice arbitrario de T, para el cual ComputeSetPackingk incluyó h1 (resp., h2) en h∗ en el cálculo de abajo hacia arriba. Por construcción, tenemos h1 ∈ χ(v1) y h2 ∈ χ(v2). Sea I un elemento en h1 ∩ h2. En el hipergrafo dual H, I es un hiperborde en E(¯H) que cubre tanto los nodos h1 como h2. Por lo tanto, por la condición (1) en la Definición 1, existe un vértice v ∈ vértices(T) tal que {h1, h2} ⊆ χ(v). Se debe tener en cuenta que, debido a la condición de conectividad en la Definición 1, también podemos asumir, sin pérdida de generalidad, que v está en el camino que conecta v1 y v2 en T. Sea hv ∈ Hv el elemento añadido por ComputeSetPackingk en h∗ durante la fase de abajo hacia arriba. Dado que los elementos en Hv son empaquetamientos para Hv, se cumple que o bien h1 ∈ hv o h2 ∈ hv. Supongamos, sin pérdida de generalidad, que h1 ∈ hv, y notemos que cada vértice w en T en el camino que conecta v con v1 es tal que h1 ∈ χ(w), debido a la condición de conectividad. Por lo tanto, debido a la definición de conformidad, el empaque hw seleccionado por ComputeSetPackingk para ser agregado en el vértice w en h∗ debe ser tal que h1 ∈ hw. Esto se cumple en particular para w = v1. Contradicción con la definición de v1. Por lo tanto, h∗ es un empaquetamiento para H. Queda entonces por demostrar que tiene el peso máximo sobre todos los empaquetamientos para H. Con este fin, podemos utilizar la inducción estructural en T para demostrar que, en la fase de abajo hacia arriba, la variable v hv se actualiza para contener el peso del empaquetamiento en las aristas en χ(Tv), que contiene hv y que tiene el peso máximo sobre todos los empaquetamientos para las aristas en χ(Tv). Entonces, el resultado sigue, ya que en la fase de arriba hacia abajo, el empaquetado hr que da el peso máximo sobre χ(Tr) = E(H) se incluye primero en h∗, y luego se extiende en cada nodo c con el empaquetado hhv,c de forma conforme con hv y de manera que se alcance el valor máximo de v hv. En cuanto a la complejidad, observe que el paso de inicialización requiere la construcción del conjunto Hv, para cada vértice v, y cada conjunto tiene un tamaño de (|E(H)| + 1)k como máximo. Luego, la función BottomUp verifica la conformidad entre las estrategias en Hv con las estrategias en Hc, para cada par (v, c) ∈ E, y actualiza el peso v hv. Estas tareas pueden llevarse a cabo en tiempo O((|E(H)| + 1)2k) y deben repetirse para cada arista en T, es decir, O(|T|) veces. Finalmente, la función TopDown puede implementarse en tiempo lineal en el tamaño de T, ya que solo requiere actualizar h∗ accediendo a la variable hhv,c. El resultado anterior muestra que si se proporciona una descomposición de hipertree de ancho k, el problema MaxWSP se puede resolver de manera eficiente. Además, a diferencia del caso de los grafos de elementos estructurados, es bien sabido que decidir la existencia de una descomposición de hipertree acotada por k y calcular una (si existe alguna) son problemas que pueden resolverse eficientemente en tiempo polinómico [7]. Por lo tanto, el Teorema 4 confirma que la clase C(hw, k) constituye en realidad una clase manejable para el problema de determinación del ganador. Como muestra el siguiente teorema, para subclases grandes (que dependen solo de cómo se especifica la función de peso), MaxWSP(H, w) es altamente paralelizable. Llamemos a una función de ponderación suave si es computable en espacio logarítmico y si todos los pesos son polinomiales (y por lo tanto solo requieren O(log n) bits para su representación). Recuerde que LOGCFL es una clase de complejidad paralela contenida en NC2, cf. [9]. La versión funcional de LOGCFL es LLOGCFL, la cual se obtiene equipando un transductor de espacio logarítmico con un oráculo en LOGCFL. Teorema 5. Sea H un hipergrafo en C(hw, k), y sea w una función de ponderación suave para él. Entonces, MaxWSP(H, w) está en LLOGCFL. 4. Dadas las descomposiciones de hipertree frente a los grafos de elementos estructurados, y considerando que se ha demostrado que la clase C(hw, k) es una isla de tratabilidad para el problema de determinación del ganador, y dado que se ha demostrado que la clase C(ig, k) no es reconocible eficientemente, uno podría inclinarse a pensar que existen instancias con ancho de hipertree ilimitado, pero que admiten un grafo de elementos de ancho de árbol acotado (por lo que la intratabilidad de los grafos de elementos estructurados residiría en su generalidad). Sorprendentemente, establecemos que este no es el caso. La clave de la prueba es primero demostrar que los grafos de elementos estructurados están en correspondencia uno a uno con un tipo especial de descomposiciones de hiperárboles del hipergrafo dual, al que llamaremos estricto. Entonces, el resultado seguirá al demostrar que las descomposiciones estrictas de hipertree de ancho k son menos potentes que las descomposiciones de hipertree de ancho k. 4.1 Descomposiciones estrictas de hipertree Deje que H sea un hipergrafo, y V ⊆ N(H) sea un conjunto de nodos y X, Y ∈ N(H). X es [V]-adyacente a Y si existe un borde h ∈ E(H) tal que {X, Y} ⊆ (h - V). Un camino [V] π de X a Y es una secuencia X = X0, . . . , X = Y de variables tal que: Xi es [V]-adyacente a Xi+1, para cada i ∈ [0... -1]. Un conjunto W ⊆ N(H) de nodos está [V]-conectado si ∀X, Y ∈ W hay un [V]-camino de X a Y. Un componente [V ] es un conjunto maximal no vacío de nodos W ⊆ (N(H) − V ) que está [V ]-conectado. Para cualquier componente [V] C, sea E(C) = {h ∈ E(H) | h ∩ C = ∅}. Definición 2. Una descomposición de hipertree HD = T, χ, λ de H es estricta si se cumplen las siguientes condiciones: 1. para cada par de vértices r y s en los vértices de T tal que s es un hijo de r, y para cada componente [χ(r)]-Cr. La intersección de Cr con χ(Ts) es vacía, Cr es un componente de [χ(r) ∩ N(λ(r) ∩ λ(s))]; 2. para cada arista h ∈ E(H), hay un vértice p tal que h ∈ λ(p) y h ⊆ χ(p) (decimos que p cubre fuertemente a h); 3. para cada arista h ∈ E(H), el conjunto {p ∈ vértices(T) | h ∈ λ(p)} induce un subárbol (conectado) de T. La anchura estricta de hipertree shw(H) de H es la anchura mínima sobre todas sus descomposiciones estrictas de hipertree. La relación básica entre las descomposiciones de hipertree agradables y los grafos de elementos estructurados se muestra en el siguiente teorema. Teorema 6. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, una k-anchura descomposición en árbol de un grafo de elementos para H existe si y solo si ¯H tiene una (k + 1)-anchura descomposición estricta en hiperárbol. Se debe tener en cuenta que, en lo que respecta al problema de empaquetamiento de conjuntos ponderados máximo, dado un hipercubo H, siempre podemos asumir que para cada nodo v ∈ N(H), {v} está en E(H). De hecho, si esta hiperarista no está en el hipercubo, entonces se puede agregar sin pérdida de generalidad, estableciendo w({v}) = 0. Por lo tanto, dejando que C(shw, k) denote la clase de todos los hipergrafos cuyos hipergrafos duales (asociados con un máximo de 2 términos +1) solo juegan el papel técnico de ocuparse de la diferente definición de ancho para las descomposiciones de árboles y las descomposiciones de hiperárboles. 159 problemas de empaquetamiento de conjuntos ponderados) tienen un ancho de hiperárbol estricto limitado por k, tenemos que C(shw, k + 1) = C(ig, k). Por definición, las descomposiciones de hipertree estrictas son descomposiciones de hipertree especiales. De hecho, podemos demostrar que las condiciones adicionales en la Definición 2 inducen una restricción real en el poder de descomposición. Teorema 7. C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). \n\nC(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1). Una vista desde la teoría de juegos. Arrojamos más luz sobre las descomposiciones estrictas de hypertrees al discutir una interesante caracterización basada en el juego estricto de Robber y Marshals, definido adaptando el juego de Robber y Marshals definido en [6], que caracteriza el ancho de hypertree. El juego se juega en un hipercubo H por un ladrón contra k marshals que actúan en coordinación. Los alguaciles se mueven en los hiperarcos de H, mientras que el ladrón se mueve en los nodos de H. El ladrón ve hacia dónde los alguaciles tienen la intención de moverse, y reacciona moviéndose a otro nodo que esté conectado con su posición actual y a través de un camino en G(H) que no utilice ningún nodo contenido en un hiperarco que esté ocupado por los alguaciles antes y después de su movimiento; decimos que estos hiperarcos están bloqueados. Ten en cuenta que en el juego básico definido en [6], al ladrón no se le permite moverse en vértices ocupados por los marshals antes y después de su movimiento, incluso si no pertenecen a hiperarcos bloqueados. Es importante que los marshals jueguen de manera monótona, es decir, no pueden ocupar un borde que haya sido ocupado previamente en el juego y que actualmente no lo esté. Los alguaciles ganan el juego si capturan al ladrón, ocupando un borde que cubra un nodo donde se encuentre el ladrón. De lo contrario, el ladrón gana. Teorema 8. Sea H un hipergrafo tal que para cada nodo v ∈ N(H), {v} está en E(H). Entonces, ¯H tiene una descomposición estricta de hipertree de k-anchura si y solo si k marshals pueden ganar el Juego estricto de Robber y Marshals en ¯H, sin importar los movimientos de los ladrones. 5. CONCLUSIONES Hemos resuelto la pregunta abierta de determinar la complejidad de calcular un grafo de elementos estructurado asociado con un escenario de subasta combinatoria. El resultado es una mala noticia, ya que resultó que es NP-completo verificar si una subasta combinatoria tiene un grafo de elementos estructurado, incluso para un ancho de árbol de 3. Motivados por este resultado, investigamos el uso de la descomposición de hiperárboles (en el hipergrafo dual asociado con el escenario) y demostramos que el problema es tratable en la clase de aquellas instancias cuyos hipergrafos duales tienen un ancho de hiperárbol acotado. Para algunos casos especiales y relevantes, también se discute un algoritmo altamente paralelizable. Curiosamente, también se descubrió que la clase de grafos de elementos estructurados está adecuadamente contenida en la clase de instancias con ancho de hiperárbol acotado (por lo tanto, la razón de su intratabilidad no es su generalidad). En particular, este último resultado se establece mostrando una relación precisa entre los grafos de elementos estructurados y formas restringidas de descomposiciones de hiperárboles (en el hipergrafo dual), llamadas descomposiciones de consultas (ver, por ejemplo, [7]). A la luz de esta observación, notamos que demostrar algunos resultados de aproximabilidad para grafos de elementos estructurados requiere una comprensión profunda de la aproximabilidad de las descomposiciones de consultas, la cual actualmente no se encuentra en la literatura. Como una vía adicional de investigación, sería relevante mejorar el algoritmo ComputeSetPackingk, por ejemplo, mediante el uso de estructuras de datos especializadas, con el fin de evitar la dependencia cuadrática de (|E(H)| + 1)k. Finalmente, otra pregunta interesante es evaluar si las técnicas de descomposición estructural discutidas en el artículo pueden ser utilizadas para abordar eficientemente generalizaciones del problema de determinación del ganador. Por ejemplo, podría ser relevante en varios escenarios de aplicación diseñar algoritmos que puedan encontrar una estrategia de venta cuando hay varias copias del mismo artículo disponibles para la venta, y además cuando el subastador está satisfecho cuando se venden al menos un número dado de copias. El trabajo de G. Gottlob fue apoyado por el EC3 - Centro de Competencia en Comercio Electrónico (Viena) y por un Premio de Mérito de Investigación Wolfson de la Royal Society. En particular, este premio permitió a Gottlob invitar a G. Greco para una visita de investigación a Oxford. Además, G. Greco cuenta con el apoyo de ICAR-CNR y del M.I.U.R. en el marco del proyecto TOCAI.IT. 6. REFERENCIAS [1] I. Adler, G. Gottlob y M. Grohe. Anchura de hipertree y invariantes de hipergrafo relacionados. En Proc. de EUROCOMB05, páginas 5-10, 2005. [2] C. Boutilier. Resolviendo problemas de subasta combinatoria expresados de manera concisa. En Proc. de AAAI02, páginas 359-366, 2002. [3] V. Conitzer, J. Derryberry y T. Sandholm. Subastas combinatorias con grafos de elementos estructurados. En Proc. de AAAI04, páginas 212-218, 2004. [4] E. M. Eschen y J. P. Sinrad. Un algoritmo O(n2) para el reconocimiento de grafos de arco circular. En Proc. de SODA93, páginas 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Óptimo y aproximado. En Proc. de IJCAI99, páginas 548-553, 1999. [6] G. Gottlob, N. Leone y F. Scarcello. Ladrones, marshals y guardias: caracterizaciones lógicas y teóricas de la amplitud de hiperárboles. Revista de Ciencias de la Computación y de Sistemas, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone y S. Scarcello. Descomposiciones de hiperárboles y consultas tratables. Revista de Ciencias de la Computación y de Sistemas, 63(3):579-627, 2002. [8] H. H. Hoos y C. Boutilier. Resolviendo subastas combinatorias utilizando búsqueda local estocástica. En Proc. de AAAI00, páginas 22-29, 2000. [9] D. Johnson. Un catálogo de clases de complejidad. En P. Cramton, Y. Shoham y R. Steinberg, editores, Manual de Ciencias de la Computación Teórica, Volumen A: Algoritmos y Complejidad, páginas 67-161. 1990. [10] N. Korte y R. H. Mohring. Un algoritmo incremental de tiempo lineal para reconocer grafos de intervalo. Revista SIAM sobre Computación, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller y T. Sandholm. El Problema de Determinación del Ganador. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, y Y. Shoham. Revelación de la verdad en aproximadamente 160 subastas combinatorias eficientes. J. ACM, 49(5):577-602, 2002. [13] R. McAfee y J. McMillan. Analizando la subasta de las ondas aéreas. Revista de Perspectivas Económicas, 10(1):159-175, 1996. [14] J. McMillan. Vendiendo derechos de espectro. Revista de Perspectivas Económicas, 8(3):145-62, 1994. [15] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. de EC00, páginas 1-12, 2000. [16] N. Robertson y P. Seymour. Menores de grafos ii. Aspectos algorítmicos del ancho de árbol. Revista de Algoritmos, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec y R. M. Harstad. Subastas combinatorias computacionalmente manejables. Ciencia de la Gestión, 44:1131-1147, 1998. [18] T. Sandholm. Una implementación del protocolo de red de contratos basada en cálculos de costos marginales. En Proc. de AAAI93, páginas 256-262, 1993. [19] T. Sandholm. Algoritmo para la determinación óptima del ganador en subastas combinatorias. Inteligencia Artificial, 135(1-2):1-54, 2002. [20] T. Sandholm. Algoritmos de determinación de ganadores. En P. Cramton, Y. Shoham y R. Steinberg, editores, Subastas Combinatorias. MIT Press, 2006. [21] T. Sandholm y S. Suri. Bob: Mejora en la determinación de ganadores en subastas combinatorias y generalizaciones. Inteligencia Artificial, 7:33-58, 2003. [22] M. Tennenholtz. Algunas subastas combinatorias manejables. En Proc. de AAAI00, páginas 98-103, 2000. [23] E. Zurel y N. Nisan. Un algoritmo de asignación aproximada eficiente para subastas combinatorias. En Proc. de EC01, páginas 125-136, 2001. 161 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "polynomial time": {
            "translated_key": "tiempo polinómico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "On The Complexity of Combinatorial Auctions: Structured Item Graphs and Hypertree Decompositions [Extended Abstract] Georg Gottlob Computing Laboratory Oxford University OX1 3QD Oxford, UK georg.gottlob@comlab.ox.ac.uk Gianluigi Greco Dipartimento di Matematica University of Calabria I-87030 Rende, Italy ggreco@mat.unical.it ABSTRACT The winner determination problem in combinatorial auctions is the problem of determining the allocation of the items among the bidders that maximizes the sum of the accepted bid prices.",
                "While this problem is in general NPhard, it is known to be feasible in <br>polynomial time</br> on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Formally, an item graph is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any bid, the items occurring in it induce a connected subgraph.",
                "Note that many item graphs might be associated with a given combinatorial auction, depending on the edges selected for guaranteeing the connectedness.",
                "In fact, the tractability of determining whether a structured item graph of a fixed treewidth exists (and if so, computing one) was left as a crucial open problem.",
                "In this paper, we solve this problem by proving that the existence of a structured item graph is computationally intractable, even for treewidth 3.",
                "Motivated by this bad news, we investigate different kinds of structural requirements that can be used to isolate tractable classes of combinatorial auctions.",
                "We show that the notion of hypertree decomposition, a recently introduced measure of hypergraph cyclicity, turns out to be most useful here.",
                "Indeed, we show that the winner determination problem is solvable in <br>polynomial time</br> on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "Even more surprisingly, we show that the class of tractable instances identified by means of our approach properly contains the class of instances having a structured item graph.",
                "Categories and Subject Descriptors J.4 [Computer Applications]: Social and Behavioral Sciences-Economics; F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity 1.",
                "INTRODUCTION Combinatorial auctions.",
                "Combinatorial auctions are well-known mechanisms for resource and task allocation where bidders are allowed to simultaneously bid on combinations of items.",
                "This is desirable when a bidders valuation of a bundle of items is not equal to the sum of her valuations of the individual items.",
                "This framework is currently used to regulate agents interactions in several application domains (cf., e.g., [21]) such as, electricity markets [13], bandwidth auctions [14], and transportation exchanges [18].",
                "Formally, a combinatorial auction is a pair I, B , where I = {I1, ..., Im} is the set of items the auctioneer has to sell, and B = {B1, ..., Bn} is the set of bids from the buyers interested in the items in I.",
                "Each bid Bi has the form item(Bi), pay(Bi) , where pay(Bi) is a rational number denoting the price a buyer offers for the items in item(Bi) ⊆ I.",
                "An outcome for I, B is a subset b of B such that item(Bi)∩item(Bj) = ∅, for each pair Bi and Bj of bids in b with i = j.",
                "The winner determination problem.",
                "A crucial problem for combinatorial auctions is to determine the outcome b∗ that maximizes the sum of the accepted bid prices (i.e., Bi∈b∗ pay(Bi)) over all the possible outcomes.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in <br>polynomial time</br> unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in <br>polynomial time</br> (e.g., [15, 22, 12, 21]).",
                "In fact, constraining bidder interaction was proven to be useful for identifying classes of tractable combinatorial auctions.",
                "Item graphs.",
                "Currently, the most general class of tractable combinatorial auctions has been singled out by modelling interactions among bidders with the notion of item graph, which is a graph whose nodes are in one-to-one correspondence with items, and edges are such that for any 152 Figure 1: Example MaxWSP problem: (a) Hypergraph H I0,B0 , and a packing h for it; (b) Primal graph for H I0,B0 ; and, (c,d) Two item graphs for H I0,B0 . bid, the items occurring in it induce a connected subgraph.",
                "Indeed, the winner determination problem was proven to be solvable in <br>polynomial time</br> if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16].",
                "To have some intuition on how item graphs can be built, we notice that bidder interaction in a combinatorial auction I, B can be represented by means of a hypergraph H I,B such that its set of nodes N(H I,B ) coincides with set of items I, and where its edges E(H I,B ) are precisely the bids of the buyers {item(Bi) | Bi ∈ B}.",
                "A special item graph for I, B is the primal graph of H I,B , denoted by G(H I,B ), which contains an edge between any pair of nodes in some hyperedge of H I,B .",
                "Then, any item graph for H I,B can be viewed as a simplification of G(H I,B ) obtained by deleting some edges, yet preserving the connectivity condition on the nodes included in each hyperedge.",
                "Example 1.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an encoding for a combinatorial auction I0, B0 , where I0 = {I1, ..., I5}, and item(Bi) = hi, for each 1 ≤ i ≤ 3.",
                "The primal graph for H I0,B0 is reported in Figure 1. (b), while two example item graphs are reported in Figure 1. (c) and (d), where edges required for maintaining the connectivity for h1 are depicted in bold. ¡ Open Problem: Computing structured item graphs efficiently.",
                "The above mentioned tractability result on structured item graphs turns out to be useful in practice only when a structured item graph either is given or can be efficiently determined.",
                "However, exponentially many item graphs might be associated with a combinatorial auction, and it is not clear how to determine whether a structured item graph of a certain (constant) treewidth exists, and if so, how to compute such a structured item graph efficiently.",
                "<br>polynomial time</br> algorithms to find the best simplification of the primal graph were so far only known for the cases where the item graph to be constructed is a line [10], a cycle [4], or a tree [3], but it was an important open problem (cf. [3]) whether it is tractable to check if for a combinatorial auction, an item graph of treewidth bounded by a fixed natural number k exists and can be constructed in <br>polynomial time</br>, if so.",
                "Weighted Set Packing.",
                "Let us note that the hypergraph representation H I,B of a combinatorial auction I, B is also useful to make the analogy between the winner determination problem and the maximum weighted-set packing problem on hypergraphs clear (e.g., [17]).",
                "Formally, a packing h for a hypergraph H is a set of hyperedges of H such that for each pair h, h ∈ h with h = h , it holds that h ∩ h = ∅.",
                "Letting w be a weighting function for H, i.e., a polynomially-time computable function from E(H) to rational numbers, the weight of a packing h is the rational number w(h) = h∈h w(h), where w({}) = 0.",
                "Then, the maximum-weighted set packing problem for H w.r.t. w, denoted by MaxWSP(H, w), is the problem of finding a packing for H having the maximum weight over all the packings for H. To see that MaxWSP is just a different formulation for the winner determination problem, given a combinatorial auction I, B , it is sufficient to define the weighting function w I,B (item(Bi)) = pay(Bi).",
                "Then, the set of the solutions for the weighted set packing problem for H I,B w.r.t. w I,B coincides with the set of the solutions for the winner determination problem on I, B .",
                "Example 2.",
                "Consider again the hypergraph H I0,B0 reported in Figure 1.(a).",
                "An example packing for H I0,B0 is h = {h1}, which intuitively corresponds to an outcome for I0, B0 , where the auctioneer accepted the bid B1.",
                "By assuming that bids B1, B2, and B3 are such that pay(B1) = pay(B2) = pay(B3), the packing h is not a solution for the problem MaxWSP(H I0,B0 , w I0,B0 ).",
                "Indeed, the packing h∗ = {h2, h3} is such that w I0,B0 (h∗ ) > w I0,B0 (h). ¡ Contributions The primary aim of this paper is to identify large tractable classes for the winner determination problem, that are, moreover polynomially recognizable.",
                "Towards this aim, we first study structured item graphs and solve the open problem in [3].",
                "The result is very bad news: It is NP complete to check whether a combinatorial auction has a structured item graph of treewidth 3.",
                "More formally, letting C(ig, k) denote the class of all the hypergraphs having an item tree of treewidth bounded by k, we prove that deciding whether a hypergraph (associated with a combinatorial auction problem) belongs to C(ig, 3) is NP-complete.",
                "In the light of this result, it was crucial to assess whether there are some other kinds of structural requirement that can be checked in <br>polynomial time</br> and that can still be used to isolate tractable classes of the maximum weightedset packing problem or, equivalently, the winner determination problem.",
                "Our investigations, this time, led to very good news which are summarized below: For a hypergraph H, its dual ¯H = (V, E) is such that nodes in V are in one-to-one correspondence with hyperedges in H, and for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ 153 E(H)} is in E. We show that MaxWSP is tractable on the class of those instances whose dual hypergraphs have hypertree width[7] bounded by k (short: class C(hw, k) of hypergraphs).",
                "Note that a key issue of the tractability is to consider the hypertree width of the dual hypergraph ¯H instead of the auction hypergraph H. In fact, we can show that MaxWSP remains NP-hard even when H is acyclic (i.e., when it has hypertree width 1), even when each node is contained in 3 hyperedges at most.",
                "For some relevant special classes of hypergraphs in C(hw, k), we design a higly-parallelizeable algorithm for MaxWSP.",
                "Specifically, if the weighting functions can be computed in logarithmic space and weights are polynomial (e.g., when all the hyperegdes have unitary weights and one is interested in finding the packing with the maximum number of edges), we show that MaxWSP can be solved by a LOGCFL algorithm.",
                "Recall, in fact, that LOGCFL is the class of decision problems that are logspace reducible to context free languages, and that LOGCFL ⊆ NC2 ⊆ P (see, e.g., [9]).",
                "Surprisingly, we show that nothing is lost in terms of generality when considering the hypertree decomposition of dual hypergraphs instead of the treewidth of item graphs.",
                "To the contrary, the proposed hypertree-based decomposition method is strictly more general than the method of structured item graphs.",
                "In fact, we show that strictly larger classes of instances are tractable according to our new approach than according to the structured item graphs approach.",
                "Intuitively, the NP-hardness of recognizing bounded-width structured item graphs is thus not due to its great generality, but rather to some peculiarities in its definition.",
                "The proof of the above results give us some interesting insight into the notion of structured item graph.",
                "Indeed, we show that structured item graphs are in one-to-one correspondence with some special kinds of hypertree decomposition of the dual hypergraph, which we call strict hypertree decompositions.",
                "A game-characterization for the notion of strict hypertree width is also proposed, which specializes the Robber and Marshals game in [6] (proposed to characterize the hypertree width), and which makes it clear the further requirements on hypertree decompositions.",
                "The rest of the paper is organized as follows.",
                "Section 2 discusses the intractability of structured item graphs.",
                "Section 3 presents the polynomial-time algorithm for solving MaxWSP on the class of those instances whose dual hypergraphs have bounded hypertree width, and discusses the cases where the algorithm is also highly parallelizable.",
                "The comparison between the classes C(ig, k) and C(hw, k) is discussed in Section 4.",
                "Finally, in Section 5 we draw our conclusions by also outlining directions for further research. 2.",
                "COMPLEXITY OF STRUCTURED ITEM GRAPHS Let H be a hypergraph.",
                "A graph G = (V, E) is an item graph for H if V = N(H) and, for each h ∈ E(H), the subgraph of G induced over the nodes in h is connected.",
                "An important class of item graphs is that of structured item graphs, i.e., of those item graphs having bounded treewidth as formalized below.",
                "A tree decomposition [16] of a graph G = (V, E) is a pair T, χ , where T = (N, F) is a tree, and χ is a labelling function assigning to each vertex p ∈ N a set of vertices χ(p) ⊆ V , such that the following conditions are satisfied: (1) for each vertex b of G, there exists p ∈ N such that b ∈ χ(p); (2) for each edge {b, d} ∈ E, there exists p ∈ N such that {b, d} ⊆ χ(p); (3) for each vertex b of G, the set {p ∈ N | b ∈ χ(p)} induces a connected subtree of T. The width of T, χ is the number maxp∈N |χ(p) − 1|.",
                "The treewidth of G, denoted by tw(G), is the minimum width over all its tree decompositions.",
                "The winner determination problem can be solved in <br>polynomial time</br> on item graphs having bounded treewidth [3].",
                "Theorem 1 (cf. [3]).",
                "Assume a k-width tree decomposition T, χ of an item graph for H is given.",
                "Then, MaxWSP(H, w) can be solved in time O(|T|2 ×(|E(H)|+1)k+1 ).",
                "Many item graphs can be associated with a hypergraph.",
                "As an example, observe that the item graph in Figure 1. (c) has treewidth 1, while Figure 1. (d) reports an item graph whose treewidth is 2.",
                "Indeed, it was an open question whether for a given constant k it can be checked in <br>polynomial time</br> if an item graph of treewidth k exists, and if so, whether such an item graph can be efficiently computed.",
                "Let C(ig, k) denote the class of all the hypergraphs having an item graph G such that tw(G) ≤ k. The main result of this section is to show that the class C(ig, k) is hard to recognize.",
                "Theorem 2.",
                "Deciding whether a hypergraph H belongs to C(ig, 3) is NP-hard.",
                "The proof of this result relies on an elaborate reduction from the Hamiltonian path problem HP(s, t) of deciding whether there is an Hamiltonian path from a node s to a node t in a directed graph G = (N, E).",
                "To help the intuition, we report here a high-level overview of the main ingredients exploited in the proof1 .",
                "The general idea it to build a hypergraph HG such that there is an item graph G for HG with tw(G ) ≤ 3 if and only if HP(s, t) over G has a solution.",
                "First, we discuss the way HG is constructed.",
                "See Figure 2. (a) for an illustration, where the graph G consists of the nodes s, x, y, and t, and the set of its edges is {e1 = (s, x), e2 = (x, y), e3 = (x, t), e4 = (y, t)}.",
                "From G to HG.",
                "Let G = (N, E) be a directed graph.",
                "Then, the set of the nodes in HG is such that: for each x ∈ N, N(HG) contains the nodes bsx, btx, bx, bx, bdx; for each e = (x, y) ∈ E, N(HG) contains the nodes nsx, nsx, nty, nty , nse x and nte y.",
                "No other node is in N(HG).",
                "Hyperedges in HG are of three kinds: 1) for each x ∈ N, E(HG) contains the hyperedges: • Sx = {bsx} ∪ {nse x | e = (x, y) ∈ E}; • Tx = {btx} ∪ {nte x | e = (z, x) ∈ E}; • A1 x = {bdx, bx}, A2 x = {bdx, bx}, and A3 x = {bx, bx} -notice that these hyperedges induce a clique on the nodes {bx, bx, bdx}; 1 Detailed proofs can be found in the Appendix, available at www.mat.unical.it/∼ggreco/papers/ca.pdf. 154 Figure 2: Proof of Theorem 2: (a) from G to HG - hyperedges in 1) and 2) are reported only; (b) a skeleton for a tree decomposition TD for HG. • SA1 x = {bsx, bx}, SA2 x = {bsx, bx}, SA3 x = {bsx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {bsx, bx, bx, bdx}; • TA1 x = {btx, bx}, TA2 x = {btx, bx}, and TA3 x = {btx, bdx} -notice that these hyperedges plus A1 x, A2 x, and A3 x induce a clique on the nodes {btx, bx, bx, bdx}; 2) for each e = (x, y) ∈ E, E(HG) contains the hyperedges: • SHx = {nsx, nsx}; • THy = {nty, nty }; • SEe = {nsx, nse x} and SEe = {nsx, nse x} -notice that these two hyperedges plus SHx induce a clique on the nodes {nsx, nsx, nse x}; • TEe = {nty, nte y} and TEe = {nty , nte y} -notice that these two hyperedges plus THy induce a clique on the nodes {nty, nty , nte y}.",
                "Notice that each of the above hyperedges but those of the form Sx and Tx contains exactly two nodes.",
                "As an example of the hyperedges of kind 1) and 2), the reader may refer to the example construction reported in Figure 2. (a), and notice, for instance, that Sx = {bsx, nse2 x , nse3 x } and that Tt = {btt, nte4 t , nte3 t }. 3) finally, we denote by DG the set containing the hyperedges in E(HG) of the third kind.",
                "In the reduction we are exploiting, DG can be an arbitrary set of hyperedges satisfying the four conditions that are discussed below.",
                "Let PG be the set of the following |PG| ≤ |N| + 3 × |E| pairs: PG = {(bx, bx) | x ∈ N} ∪ {(nsx, nsx), (nty, nty ), (nse x, nte y) | e = (x, y) ∈ E}.",
                "Also, let I(v) denote the set {h ∈ E(H) | v ∈ h} of the hyperedges of H that are touched by v; and, for a set V ⊆ N(H), let I(V ) = v∈V I(v).",
                "Then, DG has to be a set such that: (c1) ∀(α, β) ∈ PG, I(α) ∩ I(β) ∩ DG = ∅; (c2) ∀(α, β) ∈ PG, I(α) ∪ I(β) ⊇ DG; (c3) ∀α ∈ N such that ∃β ∈ N with (α, β) ∈ PG or (β, α) ∈ PG, it holds: I(α) ∩ DG = ∅; and, (c4) ∀S ⊆ N such that |S| ≤ 3 and where ∃α, β ∈ S with (α, β) ∈ PG, it is the case that: I(S) ⊇ DG.",
                "Intuitively, the set DG is such that each of its hyperedges is touched by exactly one of the two nodes in every pair 155 of PG - cf. (c1) and (c2).",
                "Moreover, hyperedges in DG touch only vertices included in at least a pair of PG - cf. (c3); and, any triple of nodes is not capable of touching all the elements of DG if none of the pairs that can be built from it belongs to PG - cf. (c4).",
                "The reader may now ask whether a set DG exists at all satisfying (c1), (c2), (c3) and (c4).",
                "In the following lemma, we positively answer this question and refer the reader to its proof for an example construction.",
                "Lemma 1.",
                "A set DG, with |DG| = 2 × |PG| + 2, satisfying conditions (c1), (c2), (c3), and (c4) can be built in time O(|PG|2 ).",
                "Key Ingredients.",
                "We are now in the position of presenting an overview of the key ingredients of the proof.",
                "Let G be an arbitrary item graph for HG, and let TD = T, χ be a 3-width tree decomposition of G (note that, because of the cliques, e.g., on the nodes {bsx, bx, bx, bdx}, any item graph for HG has treewidth 3 at least).",
                "There are three basic observations serving the purpose of proving the correctness of the reduction.",
                "Blocks of TD: First, we observe that TD must contain some special kinds of vertex.",
                "Specifically, for each node x ∈ N, TD contains a vertex bs(x) such that χ(bs(x)) ⊇ {bsx, bx, bx, bdx}, and a vertex bt(x) such that χ(bt(x)) ⊇ {btx, bx, bx, bdx}.",
                "And, for each edge e = (x, y) ∈ E, TD contains a vertex ns(x,e) such that χ(ns(x,e)) ⊇ {nse x, nsx, nsx}, and a vertex nt(y,e) such that χ(nt(y,e)) ⊇ {nte y, nty, nty }.",
                "Intuitively, these vertices are required to cover the cliques of HG associated with the hyperedges of kind 1) and 2).",
                "Each of these vertices plays a specific role in the reduction.",
                "Indeed, each directed edge e = (x, y) ∈ E is encoded in TD by means of the vertices: ns(x,e), representing precisely that e starts from x; and, nt(y,e), representing precisely that e terminates into y.",
                "Also, each node x ∈ N is encoded in TD be means of the vertices: bs(x), representing the starting point of edges originating from x; and, bt(x), representing the terminating point of edges ending into x.",
                "As an example, Figure 2. (b) reports the skeleton of a tree decomposition TD.",
                "The reader may notice in it the blocks defined above and how they are related with the hypergraph HG in Figure 2. (a) - other blocks in it (of the form w(x,y)) are defined next.",
                "Connectedness between blocks, and uniqueness of the connections: The second crucial observation is that in the path connecting a vertex of the form bs(x) (resp., bt(y)) with a vertex of the form ns(x,e) (resp., nt(y,e)) there is one special vertex of the form w(x,y) such that: χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E. Guaranteeing the existence of one such vertex is precisely the role played by the hyperedges in DG.",
                "The arguments for the proof are as follows.",
                "First, we observe that I(χ(bs(x))) ∩ I(χ(ns(x,e))) ⊇ DG ∪ {Sx} and I(χ(bt(y))) ∩ I(χ(nt(y,e))) ⊇ DG ∪ {Ty}.",
                "Then, we show a property stating that for a pair of consecutive vertices p and q in the path connecting bs(x) and ns(x,e) (resp., bt(y) and nt(y,e)), I(χ(p) ∩ χ(q)) ⊇ I(χ(bs(x))) ∩ I(χ(ns(x,e))) (resp., I(χ(p) ∩ χ(q)) ⊇ I(χ(bt(x))) ∩ I(χ(nt(y,e)))).",
                "Thus, we have: I(χ(p) ∩ χ(q)) ⊇ DG ∪{Sx} (resp., I(χ(p)∩χ(q)) ⊇ DG ∪{Ty}).",
                "Based on this observation, and by exploiting the properties of the hyperedges in DG, it is not difficult to show that any pair of consecutive vertices p and q must share two nodes of HG forming a pair in PG, and must both touch Sx (resp., Ty).",
                "When the treewidth of G is 3, we can conclude that a vertex, say w(x,y), in this path is such that χ(w(x,y)) ⊇ {nse x , nte y }, for some edge e = (x, y) ∈ E - to this end, note that nse x ∈ Sx, nte t ∈ Ty, and I(χ(w(x,y))) ⊇ DG.",
                "In particular, w(x,y) is the only kind of vertex satisfying these conditions, i.e., in the path there is no further vertex of the form w(x,z), for z = y (resp., w(z,y), for z = x).",
                "To help the intuition, we observe that having a vertex of the form w(x,y) in TD corresponds to the selection of an edge from node x to node y in the Hamiltonian path.",
                "In fact, given the uniqueness of these vertices selected for ensuring the connectivity, a one-to-one correspondence can be established between the existence of a Hamiltonian path for G and the vertices of the form w(x,y).",
                "As an example, in Figure 2. (b), the vertices of the form w(s,x), w(x,y), and w(y,t) are in TD, and GT D shows the corresponding Hamiltonian path.",
                "Unused blocks: Finally, the third ingredient of the proof is the observation that if a vertex of the form w(x,y), for an edge e = (x, y) ∈ E is not in TD (i.e., if the edge (x, y) does not belong to the Hamiltonian path), then the corresponding block ns(x,e ) (resp., nt(y,e )) can be arbitrarily appended in the subtree rooted at the block ns(x,e) (resp., nt(y,e)), where e is the edge of the form e = (x, z) (resp., e = (z, y)) such that w(x,z) (resp., w(z,y)) is in TD.",
                "E.g., Figure 2. (a) shows w(x,t), which is not used in TD, and Figure 2. (b) shows how the blocks ns(x,e3) and nt(t,e3) can be arranged in TD for ensuring the connectedness condition. 3.",
                "TRACTABLE CASES VIA HYPERTREE DECOMPOSITIONS Since constructing structured item graphs is intractable, it is relevant to assess whether other structural restrictions can be used to single out classes of tractable MaxWSP instances.",
                "To this end, we focus on the notion of hypertree decomposition [7], which is a natural generalization of hypergraph acyclicity and which has been profitably used in other domains, e.g, constraint satisfaction and database query evaluation, to identify tractability islands for NP-hard problems.",
                "A hypertree for a hypergraph H is a triple T, χ, λ , where T = (N, E) is a rooted tree, and χ and λ are labelling functions which associate each vertex p ∈ N with two sets χ(p) ⊆ N(H) and λ(p) ⊆ E(H).",
                "If T = (N , E ) is a subtree of T, we define χ(T ) = v∈N χ(v).",
                "We denote the set of vertices N of T by vertices(T).",
                "Moreover, for any p ∈ N, Tp denotes the subtree of T rooted at p. Definition 1.",
                "A hypertree decomposition of a hypergraph H is a hypertree HD = T, χ, λ for H which satisfies all the following conditions: 1. for each edge h ∈ E(H), there exists p ∈ vertices(T) such that h ⊆ χ(p) (we say that p covers h); 156 Figure 3: Example MaxWSP problem: (a) Hypergraph H1; (b) Hypergraph ¯H1; (b) A 2-width hypertree decomposition of ¯H1. 2. for each node Y ∈ N(H), the set {p ∈ vertices(T) | Y ∈ χ(p)} induces a (connected) subtree of T; 3. for each p ∈ vertices(T), χ(p) ⊆ N(λ(p)); 4. for each p ∈ vertices(T), N(λ(p)) ∩ χ(Tp) ⊆ χ(p).",
                "The width of a hypertree decomposition T, χ, λ is maxp∈vertices(T )|λ(p)|.",
                "The HYPERTREE width hw(H) of H is the minimum width over all its hypertree decompositions.",
                "A hypergraph H is acyclic if hw(H) = 1.",
                "P Example 3.",
                "The hypergraph H I0,B0 reported in Figure 1. (a) is an example acyclic hypergraph.",
                "Instead, both the hypergraphs H1 and ¯H1 shown in Figure 3. (a) and Figure 3. (b), respectively, are not acyclic since their hypertree width is 2.",
                "A 2-width hypertree decomposition for ¯H1 is reported in Figure 3.(c).",
                "In particular, observe that H1 has been obtained by adding the two hyperedges h4 and h5 to H I0,B0 to model, for instance, that two new bids, B4 and B5, respectively, have been proposed to the auctioneer. ¡ In the following, rather than working on the hypergraph H associated with a MaxWSP problem, we shall deal with its dual ¯H, i.e., with the hypergraph such that its nodes are in one-to-one correspondence with the hyperedges of H, and where for each node x ∈ N(H), {h | x ∈ h ∧ h ∈ E(H)} is in E( ¯H).",
                "As an example, the reader may want to check again the hypergraph H1 in Figure 3. (a) and notice that the hypergraph in Figure 3. (b) is in fact its dual.",
                "The rationale for this choice is that issuing restrictions on the original hypergraph is a guarantee for the tractability only in very simple scenarios.",
                "Theorem 3.",
                "On the class of acyclic hypergraphs, MaxWSP is (1) in P if each node occurs into two hyperedges at most; and, (2) NP-hard, even if each node is contained into three hyperedges at most. 3.1 Hypertree Decomposition on the Dual Hypergraph and Tractable Packing Problems For a fixed constant k, let C(hw, k) denote the class of all the hypergraphs whose dual hypergraphs have hypertree width bounded by k. The maximum weighted-set packing problem can be solved in <br>polynomial time</br> on the class C(hw, k) by means of the algorithm ComputeSetPackingk, shown in Figure 4.",
                "The algorithm receives in input a hypergraph H, a weighting function w, and a k-width hypertree decomposition HD = T=(N, E), χ, λ of ¯H.",
                "For each vertex v ∈ N, let Hv be the hypergraph whose set of nodes N(Hv) ⊆ N(H) coincides with λ(v), and whose set of edges E(Hv) ⊆ E(H) coincides with χ(v).",
                "In an initialization step, the algorithm equips each vertex v with all the possible packings for Hv, which are stored in the set Hv.",
                "Note that the size of Hv is bounded by (|E(H)| + 1)k , since each node in λ(v) is either left uncovered in a packing or is covered with precisely one of the hyperedges in χ(v) ⊆ E(H).",
                "Then, ComputeSetPackingk is designed to filter these packings by retaining only those that conform with some packing for Hc, for each children c of v in T, as formalized next.",
                "Let hv and hc be two packings for Hv and Hc, respectively.",
                "We say that hv conforms with hc, denoted by hv ≈ hc if: for each h ∈ hc ∩ E(Hv), h is in hv; and, for each h ∈ (E(Hc) − hc), h is not in hv.",
                "Example 4.",
                "Consider again the hypertree decomposition of ¯H1 reported in Figure 3.(c).",
                "Then, the set of all the possible packings (which are build in the initialization step of ComputeSetPackingk), for each of its vertices, is reFigure 5: Example application of Algorithm ComputeSetPackingk. 157 Input: H, w, and a k-width hypertree decomposition HD = T =(N, E), χ, λ of ¯H; Output: A solution to MaxWSP(H, w); var Hv : set of packings for Hv, for each v ∈ N; h∗ : packing for H; v hv : rational number, for each partial packing hv for Hv; hhv,c : partial packing for Hc, for each partial packing hv for Hv, and for each (v, c) ∈ E; -------------------------------------------Procedure BottomUp; begin Done := the set of all the leaves of T ; while ∃v ∈ T such that (i) v ∈ Done, and (ii) {c | c is child of v} ⊆ Done do for each c such that (v, c) ∈ E do Hv := Hv − {hv | ∃hc ∈ Hc s.t. hv ≈ hc}; for each hv ∈ Hv do v hv := w(hv); for each c such that (v, c) ∈ E do ¯hc := arg maxhc∈Hc|hv≈ hc c hc − w(hc ∩ hv) ; hhv,c := ¯hc; (* set best packing *) v hv := v hv + c ¯hc − w(¯hc ∩ hv); end for end for Done := Done ∪ {v}; end while end; -------------------------------------------begin (* MAIN *) for each vertex v in T do Hv := {hv packing for Hv}; BottomUp; let r be the root of T ; ¯hr := arg maxhr∈Hr r hr ; h∗ := ¯hr; (* include packing *) T opDown(r, hr); return h∗ ; end.",
                "Procedure T opDown(v : vertex of N, ¯hv ∈ Hv); begin for each c ∈ N s.t. (v, c) ∈ E do ¯hc := h¯hv,c; h∗ := h∗ ∪ ¯hc; (* include packing *) T opDown(c, ¯hc); end for end; Figure 4: Algorithm ComputeSetPackingk. ported in Figure 5.(a).",
                "For instance, the root v1 is such that Hv1 = { {}, {h1}, {h3}, {h5} }.",
                "Moreover, an arrow from a packing hc to hv denotes that hv conforms with hc.",
                "For instance, the reader may check that the packing {h3} ∈ Hv1 conforms with the packing {h2, h3} ∈ Hv3 , but do not conform with {h1} ∈ Hv3 . ¡ ComputeSetPackingk builds a solution by traversing T in two phases.",
                "In the first phase, vertices of T are processed from the leaves to the root r, by means of the procedure BottomUp.",
                "For each node v being processed, the set Hv is preliminary updated by removing all the packings hv that do not conform with any packing for some of the children of v. After this filtering is performed, the weight hv is updated.",
                "Intuitively, v hv stores the weight of the best partial packing for H computed by using only the hyperedges occurring in χ(Tv).",
                "Indeed, if v is a leaf, then v hv = w(hv).",
                "Otherwise, for each child c of v in T, v hv is updated with the maximum of c hc − w(hc ∩ hv) over all the packings hc that conforms with hv (resolving ties arbitrarily).",
                "The packing ¯hc for which this maximum is achieved is stored in the variable hhv,c.",
                "In the second phase, the tree T is processed starting from the root.",
                "Firstly, the packing h∗ is selected that maximizes the weight equipped with the packings in Hr.",
                "Then, procedure TopDown is used to extend h∗ to all the other partial packings for vertices of T. In particular, at each vertex v, h∗ is extended with the packing hhv,c, for each child c of v. Example 5.",
                "Assume that, in our running example, w(h1) = w(h2) = w(h3) = w(h4) = 1.",
                "Then, an execution of ComputeSetPackingk is graphically depicted in Figure 5. (b), where an arrow from a packing hc to a packing hv is used to denote that hc = hhv,c.",
                "Specifically, the choices made during the computation are such that the packing {h2, h3} is computed.",
                "In particular, during the bottom-up phase, we have that: (1) v4 is processed, and we set v4 {h2} = v4 {h4} = 1 and v4 {} = 0; (2) v3 is processed, and we set v3 {h1} = v3 {h3} = 1 and v3 {} = 0; (3) v2 is processed, and we set v2 {h1} = v2 {h2} = v2 {h3} = v2 {h4} = 1, v2 {h2,h3} = 2 and v3 {} = 0; (4) v1 is processed and we set v1 {h1} = 1, v1 {h5} = v1 {h3} = 2 and v1 {} = 0.",
                "For instance, note that v1 {h5} = 2 since {h5} conforms with the packing {h4} of Hv2 such that v2 {h4} = 1.",
                "Then, at the beginning of the top-down phase, ComputeSetPackingk selects {h3} as a packing for Hv1 and propagates this choice in the tree.",
                "Equivalently, the algorithm may have chosen {h5}.",
                "As a further example, the way the solution {h1} is obtained by the algorithm when w(h1) = 5 and w(h2) = w(h3) = w(h4) = 1 is reported in Figure 5.(c).",
                "Notice that, this time, in the top-down phase, ComputeSetPackingk starts selecting {h1} as the best packing for Hv1 . ¡ Theorem 4.",
                "Let H be a hypergraph and w be a weighting function for it.",
                "Let HD = T, χ, λ be a complete k-width hypertree decomposition of ¯H.",
                "Then, ComputeSetPackingk on input H, w, and HD correctly outputs a solution for MaxWSP(H, w) in time O(|T| × (|E(H)| + 1)2k ).",
                "Proof. [Sketch] We observe that h∗ (computed by ComputeSetPackingk) is a packing for H. Indeed, consider a pair of hyperedges h1 and h2 in h∗ , and assume, for the sake of contradiction, that h1 ∩ h2 = ∅.",
                "Let v1 (resp., v2) be an arbitrary vertex of T, for which ComputeSetPackingk included h1 (resp., h2) in h∗ in the bottom-down computation.",
                "By construction, we have h1 ∈ χ(v1) and h2 ∈ χ(v2). 158 Let I be an element in h1 ∩ h2.",
                "In the dual hypergraph H, I is a hyperedge in E( ¯H) which covers both the nodes h1 and h2.",
                "Hence, by condition (1) in Definition 1, there is a vertex v ∈ vertices(T) such that {h1, h2} ⊆ χ(v).",
                "Note that, because of the connectedness condition in Definition 1, we can also assume, w.l.o.g., that v is in the path connecting v1 and v2 in T. Let hv ∈ Hv denote the element added by ComputeSetPackingk into h∗ during the bottom-down phase.",
                "Since the elements in Hv are packings for Hv, it is the case that either h1 ∈ hv or h2 ∈ hv.",
                "Assume, w.l.o.g., that h1 ∈ hv, and notice that each vertex w in T in the path connecting v to v1 is such that h1 ∈ χ(w), because of the connectedness condition.",
                "Hence, because of definition of conformance, the packing hw selected by ComputeSetPackingk to be added at vertex w in h∗ must be such that h1 ∈ hw.",
                "This holds in particular for w = v1.",
                "Contradiction with the definition of v1.",
                "Therefore, h∗ is a packing for H. It remains then to show that it has the maximum weight over all the packings for H. To this aim, we can use structural induction on T to prove that, in the bottom-up phase, the variable v hv is updated to contain the weight of the packing on the edges in χ(Tv), which contains hv and which has the maximum weight over all such packings for the edges in χ(Tv).",
                "Then, the result follows, since in the top-down phase, the packing hr giving the maximum weight over χ(Tr) = E(H) is first included in h∗ , and then extended at each node c with the packing hhv,c conformingly with hv and such that the maximum value of v hv is achieved.",
                "As for the complexity, observe that the initialization step requires the construction of the set Hv, for each vertex v, and each set has size (|E(H)| + 1)k at most.",
                "Then, the function BottomUp checks for the conformance between strategies in Hv with strategies in Hc, for each pair (v, c) ∈ E, and updates the weight v hv .",
                "These tasks can be carried out in time O((|E(H)| + 1)2k ) and must be repeated for each edge in T, i.e., O(|T|) times.",
                "Finally, the function TopDown can be implemented in linear time in the size of T, since it just requires updating h∗ by accessing the variable hhv,c.",
                "The above result shows that if a hypertree decomposition of width k is given, the MaxWSP problem can be efficiently solved.",
                "Moreover, differently from the case of structured item graphs, it is well known that deciding the existence of a k-bounded hypertree decomposition and computing one (if any) are problems which can be efficiently solved in <br>polynomial time</br> [7].",
                "Therefore, Theorem 4 witnesses that the class C(hw, k) actually constitutes a tractable class for the winner determination problem.",
                "As the following theorem shows, for large subclasses (that depend only on how the weight function is specified), MaxWSP(H, w) is even highly parallelizeable.",
                "Let us call a weighting function smooth if it is logspace computable and if all weights are polynomial (and thus just require O(log n) bits for their representation).",
                "Recall that LOGCFL is a parallel complexity class contained in NC2, cf. [9].",
                "The functional version of LOGCFL is LLOGCFL , which is obtained by equipping a logspace transducer with an oracle in LOGCFL.",
                "Theorem 5.",
                "Let H be a hypergraph in C(hw, k), and let w be a smooth weighting function for it.",
                "Then, MaxWSP(H, w) is in LLOGCFL . 4.",
                "HYPERTREE DECOMPOSITIONS VS STRUCTURED ITEM GRAPHS Given that the class C(hw, k) has been shown to be an island of tractability for the winner determination problem, and given that the class C(ig, k) has been shown not to be efficiently recognizable, one may be inclined to think that there are instances having unbounded hypertree width, but admitting an item graph of bounded tree width (so that the intractability of structured item graphs would lie in their generality).",
                "Surprisingly, we establish this is not the case.",
                "The line of the proof is to first show that structured item graphs are in one-to-one correspondence with a special kind of hypertree decompositions of the dual hypergraph, which we shall call strict.",
                "Then, the result will follow by proving that k-width strict hypertree decompositions are less powerful than kwith hypertree decompositions. 4.1 Strict Hypertree Decompositions Let H be a hypergraph, and let V ⊆ N(H) be a set of nodes and X, Y ∈ N(H).",
                "X is [V ]-adjacent to Y if there exists an edge h ∈ E(H) such that {X, Y } ⊆ (h − V ).",
                "A [V ]-path π from X to Y is a sequence X = X0, . . . , X = Y of variables such that: Xi is [V ]-adjacent to Xi+1, for each i ∈ [0... -1].",
                "A set W ⊆ N(H) of nodes is [V ]-connected if ∀X, Y ∈ W there is a [V ]-path from X to Y .",
                "A [V ]-component is a maximal [V ]-connected non-empty set of nodes W ⊆ (N(H) − V ).",
                "For any [V ]-component C, let E(C) = {h ∈ E(H) | h ∩ C = ∅}.",
                "Definition 2.",
                "A hypertree decomposition HD = T, χ, λ of H is strict if the following conditions hold: 1. for each pair of vertices r and s in vertices(T) such that s is a child of r, and for each [χ(r)]-component Cr s.t.",
                "Cr ∩ χ(Ts) = ∅, Cr is a [χ(r) ∩ N(λ(r) ∩ λ(s))]-component; 2. for each edge h ∈ E(H), there is a vertex p such that h ∈ λ(p) and h ⊆ χ(p) (we say p strongly covers h); 3. for each edge h ∈ E(H), the set {p ∈ vertices(T) | h ∈ λ(p)} induces a (connected) subtree of T. The strict hypertree width shw(H) of H is the minimum width over all its strict hypertree decompositions.",
                "P The basic relationship between nice hypertree decompositions and structured item graphs is shown in the following theorem.",
                "Theorem 6.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, a k-width tree decomposition of an item graph for H exists if and only if ¯H has a (k + 1)-width strict hypertree decomposition2 .",
                "Note that, as far as the maximum weighted-set packing problem is concerned, given a hypergraph H, we can always assume that for each node v ∈ N(H), {v} is in E(H).",
                "In fact, if this hyperedge is not in the hypergraph, then it can be added without loss of generality, by setting w({v}) = 0.",
                "Therefore, letting C(shw, k) denote the class of all the hypergraphs whose dual hypergraphs (associated with maximum 2 The term +1 only plays the technical role of taking care of the different definition of width for tree decompositions and hypertree decompositions. 159 weighted-set packing problems) have strict hypertree width bounded by k, we have that C(shw, k + 1) = C(ig, k).",
                "By definition, strict hypertree decompositions are special hypertree decompositions.",
                "In fact, we are able to show that the additional conditions in Definition 2 induce an actual restriction on the decomposition power.",
                "Theorem 7.",
                "C(ig, k) = C(shw, k + 1) ⊂ C(hw, k + 1).",
                "A Game Theoretic View.",
                "We shed further lights on strict hypertree decompositions by discussing an interesting characterization based on the strict Robber and Marshals Game, defined by adapting the Robber and Marshals game defined in [6], which characterizes hypertree width.",
                "The game is played on a hypergraph H by a robber against k marshals which act in coordination.",
                "Marshals move on the hyperedges of H, while the robber moves on nodes of H. The robber sees where the marshals intend to move, and reacts by moving to another node which is connected with its current position and through a path in G(H) which does not use any node contained in a hyperedge that is occupied by the marshals before and after their move-we say that these hyperedges are blocked.",
                "Note that in the basic game defined in [6], the robber is not allowed to move on vertices that are occupied by the marshals before and after their move, even if they do not belong to blocked hyperedges.",
                "Importantly, marshals are required to play monotonically, i.e., they cannot occupy an edge that was previously occupied in the game, and which is currently not.",
                "The marshals win the game if they capture the robber, by occupying an edge covering a node where the robber is.",
                "Otherwise, the robber wins.",
                "Theorem 8.",
                "Let H be a hypergraph such that for each node v ∈ N(H), {v} is in E(H).",
                "Then, ¯H has a k-width strict hypertree decomposition if and only if k marshals can win the strict Robber and Marshals Game on ¯H, no matter of the robbers moves. 5.",
                "CONCLUSIONS We have solved the open question of determining the complexity of computing a structured item graph associated with a combinatorial auction scenario.",
                "The result is bad news, since it turned out that it is NP-complete to check whether a combinatorial auction has a structured item graph, even for treewidth 3.",
                "Motivated by this result, we investigated the use of hypertree decomposition (on the dual hypergraph associated with the scenario) and we shown that the problem is tractable on the class of those instances whose dual hypergraphs have bounded hypertree width.",
                "For some special, yet relevant cases, a highly parallelizable algorithm is also discussed.",
                "Interestingly, it also emerged that the class of structured item graphs is properly contained in the class of instances having bounded hypertree width (hence, the reason of their intractability is not their generality).",
                "In particular, the latter result is established by showing a precise relationship between structured item graphs and restricted forms of hypertree decompositions (on the dual hypergraph), called query decompositions (see, e.g., [7]).",
                "In the light of this observation, we note that proving some approximability results for structured item graphs requires a deep understanding of the approximability of query decompositions, which is currently missing in the literature.",
                "As a further avenue of research, it would be relevant to enhance the algorithm ComputeSetPackingk, e.g., by using specialized data structures, in order to avoid the quadratic dependency from (|E(H)| + 1)k .",
                "Finally, an other interesting question is to assess whether the structural decomposition techniques discussed in the paper can be used to efficiently deal with generalizations of the winner determination problem.",
                "For instance, it might be relevant in several application scenarios to design algorithms that can find a selling strategy when several copies of the same item are available for selling, and when moreover the auctioneer is satisfied when at least a given number of copies is actually sold.",
                "Acknowledgement G. Gottlobs work was supported by the EC3 - E-Commerce Competence Center (Vienna) and by a Royal Society Wolfson Research Merit Award.",
                "In particular, this Award allowed Gottlob to invite G. Greco for a research visit to Oxford.",
                "In addition, G. Greco is supported by ICAR-CNR, and by M.I.U.R. under project TOCAI.IT. 6.",
                "REFERENCES [1] I. Adler, G. Gottlob, and M. Grohe.",
                "Hypertree-Width and Related Hypergraph Invariants.",
                "In Proc. of EUROCOMB05, pages 5-10, 2005. [2] C. Boutilier.",
                "Solving Concisely Expressed Combinatorial Auction Problems.",
                "In Proc. of AAAI02, pages 359-366, 2002. [3] V. Conitzer, J. Derryberry, and T. Sandholm.",
                "Combinatorial auctions with structured item graphs.",
                "In Proc. of AAAI04, pages 212-218, 2004. [4] E. M. Eschen and J. P. Sinrad.",
                "An o(n2 ) algorithm for circular-arc graph recognition.",
                "In Proc. of SODA93, pages 128-137, 1993. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate.",
                "In Proc. of IJCAI99, pages 548-553, 1999. [6] G. Gottlob, N. Leone, and F. Scarcello.",
                "Robbers, marshals, and guards: game theoretic and logical characterizations of hypertree width.",
                "Journal of Computer and System Sciences, 66(4):775-808, 2003. [7] G. Gottlob, N. Leone, and S. Scarcello.",
                "Hypertree decompositions and tractable queries.",
                "Journal of Computer and System Sciences, 63(3):579-627, 2002. [8] H. H. Hoos and C. Boutilier.",
                "Solving combinatorial auctions using stochastic local search.",
                "In Proc. of AAAI00, pages 22-29, 2000. [9] D. Johnson.",
                "A Catalog of Complexity Classes.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, pages 67-161. 1990. [10] N. Korte and R. H. Mohring.",
                "An incremental linear-time algorithm for recognizing interval graphs.",
                "SIAM Journal on Computing, 18(1):68-81, 1989. [11] D. Lehmann, R. M¨uller, and T. Sandholm.",
                "The Winner Determination Problem.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [12] D. Lehmann, L. I. OCallaghan, and Y. Shoham.",
                "Truth revelation in approximately efficient 160 combinatorial auctions.",
                "J. ACM, 49(5):577-602, 2002. [13] R. McAfee and J. McMillan.",
                "Analyzing the airwaves auction.",
                "Journal of Economic Perspectives, 10(1):159175, 1996. [14] J. McMillan.",
                "Selling spectrum rights.",
                "Journal of Economic Perspectives, 8(3):145-62, 1994. [15] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. of EC00, pages 1-12, 2000. [16] N. Robertson and P. Seymour.",
                "Graph minors ii. algorithmic aspects of tree width.",
                "Journal of Algorithms, 7:309-322, 1986. [17] M. H. Rothkopf, A. Pekec, and R. M. Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44:1131-1147, 1998. [18] T. Sandholm.",
                "An implementation of the contract net protocol based on marginal cost calculations.",
                "In Proc. of AAAI93, pages 256-262, 1993. [19] T. Sandholm.",
                "Algorithm for optimal winner determination in combinatorial auctions.",
                "Artificial Intelligence, 135(1-2):1-54, 2002. [20] T. Sandholm.",
                "Winner determination algorithms.",
                "In P. Cramton, Y. Shoham, and R. Steinberg, editors, Combinatorial Auctions.",
                "MIT Press, 2006. [21] T. Sandholm and S. Suri.",
                "Bob: Improved winner determination in combinatorial auctions and generalizations.",
                "Artificial Intelligence, 7:33-58, 2003. [22] M. Tennenholtz.",
                "Some tractable combinatorial auctions.",
                "In Proc. of AAAI00, pages 98-103, 2000. [23] E. Zurel and N. Nisan.",
                "An efficient approximate allocation algorithm for combinatorial auctions.",
                "In Proc. of EC01, pages 125-136, 2001. 161"
            ],
            "original_annotated_samples": [
                "While this problem is in general NPhard, it is known to be feasible in <br>polynomial time</br> on those instances whose associated item graphs have bounded treewidth (called structured item graphs).",
                "Indeed, we show that the winner determination problem is solvable in <br>polynomial time</br> on instances whose bidder interactions can be represented with (dual) hypergraphs having bounded hypertree width.",
                "This problem, called winner determination problem (e.g., [11]), is known to be intractable, actually NP-hard [17], and even not approximable in <br>polynomial time</br> unless NP = ZPP [19].",
                "Hence, it comes with no surprise that several efforts have been spent to design practically efficient algorithms for general auctions (e.g., [20, 5, 2, 8, 23]) and to identify classes of instances where solving the winner determination problem is feasible in <br>polynomial time</br> (e.g., [15, 22, 12, 21]).",
                "Indeed, the winner determination problem was proven to be solvable in <br>polynomial time</br> if interactions among bidders can be represented by means of a structured item graph, i.e., a tree or, more generally, a graph having tree-like structure [3]-formally bounded treewidth [16]."
            ],
            "translated_annotated_samples": [
                "Si bien este problema es en general NP-difícil, se sabe que es factible en <br>tiempo polinómico</br> en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados).",
                "De hecho, demostramos que el problema de determinación del ganador es soluble en <br>tiempo polinómico</br> en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado.",
                "Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en <br>tiempo polinómico</br> a menos que NP = ZPP [19].",
                "Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en <br>tiempo polinómico</br> (por ejemplo, [15, 22, 12, 21]).",
                "De hecho, se demostró que el problema de determinación del ganador es soluble en <br>tiempo polinómico</br> si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]."
            ],
            "translated_text": "La determinación del ganador en subastas combinatorias es el problema de determinar la asignación de los artículos entre los postores que maximiza la suma de los precios de las ofertas aceptadas. Si bien este problema es en general NP-difícil, se sabe que es factible en <br>tiempo polinómico</br> en aquellas instancias cuyos grafos de elementos asociados tienen un ancho de árbol acotado (llamados grafos de elementos estructurados). Formalmente, un grafo de elementos es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que aparecen en ella inducen un subgrafo conectado. Ten en cuenta que muchos grafos de elementos pueden estar asociados con una subasta combinatoria dada, dependiendo de las aristas seleccionadas para garantizar la conectividad. De hecho, la tratabilidad de determinar si existe un grafo de ítems estructurados con un ancho de árbol fijo (y en caso afirmativo, calcularlo) se dejó como un problema abierto crucial. En este artículo, resolvemos este problema demostrando que la existencia de un grafo de elementos estructurados es computacionalmente intratable, incluso para una treewidth de 3. Motivados por estas malas noticias, investigamos diferentes tipos de requisitos estructurales que se pueden utilizar para aislar clases manejables de subastas combinatorias. Mostramos que la noción de descomposición de hiperárboles, una medida recientemente introducida de ciclicidad de hipergrafos, resulta ser muy útil aquí. De hecho, demostramos que el problema de determinación del ganador es soluble en <br>tiempo polinómico</br> en instancias cuyas interacciones de licitantes pueden ser representadas con hipergrafos (duales) que tienen un ancho de hiperárbol acotado. Aún más sorprendentemente, demostramos que la clase de instancias tratables identificadas mediante nuestro enfoque contiene adecuadamente la clase de instancias que tienen un grafo de elementos estructurado. Categorías y Descriptores de Asignaturas J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía; F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas 1. INTRODUCCIÓN Subastas combinatorias. Las subastas combinatorias son mecanismos bien conocidos para la asignación de recursos y tareas donde a los postores se les permite pujar simultáneamente por combinaciones de artículos. Esto es deseable cuando la valoración de un postor de un conjunto de artículos no es igual a la suma de sus valoraciones de los artículos individuales. Este marco se utiliza actualmente para regular las interacciones de agentes en varios dominios de aplicación (cf., por ejemplo, [21]), como mercados de electricidad [13], subastas de ancho de banda [14] e intercambios de transporte [18]. Formalmente, una subasta combinatoria es un par I, B, donde I = {I1, ..., Im} es el conjunto de artículos que el subastador tiene para vender, y B = {B1, ..., Bn} es el conjunto de ofertas de los compradores interesados en los artículos en I. Cada oferta Bi tiene la forma item(Bi), pay(Bi), donde pay(Bi) es un número racional que denota el precio que un comprador ofrece por los artículos en item(Bi) ⊆ I. Un resultado para I, B es un subconjunto b de B tal que item(Bi)∩item(Bj) = ∅, para cada par Bi y Bj de ofertas en b con i = j. El problema de determinación del ganador. Un problema crucial para las subastas combinatorias es determinar el resultado b∗ que maximiza la suma de los precios de las ofertas aceptadas (es decir, Bi∈b∗ paga(Bi)) sobre todos los resultados posibles. Este problema, llamado problema de determinación del ganador (por ejemplo, [11]), se sabe que es intratable, de hecho NP-duro [17], e incluso no aproximable en <br>tiempo polinómico</br> a menos que NP = ZPP [19]. Por lo tanto, no sorprende que se hayan dedicado varios esfuerzos para diseñar algoritmos prácticamente eficientes para subastas generales (por ejemplo, [20, 5, 2, 8, 23]) e identificar clases de instancias donde resolver el problema de determinación del ganador sea factible en <br>tiempo polinómico</br> (por ejemplo, [15, 22, 12, 21]). De hecho, se demostró que restringir la interacción de los postores es útil para identificar clases de subastas combinatorias manejables. Gráficos de ítems. Actualmente, la clase más general de subastas combinatorias tratables ha sido identificada mediante la modelización de las interacciones entre postores con la noción de grafo de elementos, que es un grafo cuyos nodos están en correspondencia uno a uno con los elementos, y las aristas son tales que para cualquier oferta, los elementos que la componen inducen un subgrafo conectado. De hecho, se demostró que el problema de determinación del ganador es soluble en <br>tiempo polinómico</br> si las interacciones entre los postores pueden ser representadas mediante un grafo de elementos estructurado, es decir, un árbol o, más generalmente, un grafo con estructura similar a un árbol [3]-formalmente limitado por el ancho del árbol [16]. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        }
    }
}